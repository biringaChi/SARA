version,hash,sourcecode,build,test
sc1_v1,4830ac9,"package seedu.addressbook.util;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;

/**
 * Utility methods for testing.
 */
public class TestUtil {
    /**
     * Creates an address book containing the given persons.
     */
    public static AddressBook createAddressBook(Person... persons) {
        AddressBook addressBook = new AddressBook();

        for (Person person : persons) {
            try {
                addressBook.addPerson(person);
            } catch (DuplicatePersonException e) {
                throw new AssertionError(e);
            }
        }

        return addressBook;
    }

    /**
     * Creates a list of persons.
     */
    public static List<ReadOnlyPerson> createList(Person...persons) {
        List<ReadOnlyPerson> list = new ArrayList<ReadOnlyPerson>();

        for (Person person : persons) {
            list.add(person);
        }

        return list;
    }

    /**
     * Creates a copy of the original address book with the same entries
     * of Persons and Tags. The Persons and Tags are not cloned.
     */
    public static AddressBook clone(AddressBook addressBook) {
        return new AddressBook(addressBook.getAllPersons());
    }

    /**
     * Returns true if every pair of corresponding elements two iterables are (deeply) identical.
     * In other words, the two containers must have the same elements, in the same order.
     */
    public static <T> boolean isIdentical(Iterable<T> firstIterable, Iterable<T> secondIterable) {
        Iterator<T> currentPtr0 = firstIterable.iterator();
        Iterator<T> currentPtr1 = secondIterable.iterator();

        while (currentPtr0.hasNext() && currentPtr1.hasNext()) {
            T val0 = currentPtr0.next();
            T val1 = currentPtr1.next();

            if (!val0.equals(val1)) {
                return false;
            }
        }

        // If any of the two iterables still have elements, then they have different sizes.
        return !(currentPtr0.hasNext() || currentPtr1.hasNext());
    }

    /**
     * Returns true if the underlying container behind an iterable is empty.
     */
    public static <T> boolean isEmpty(Iterable<T> it) {
        return !it.iterator().hasNext();
    }

    /**
     * Returns the number of elements in the container behind an iterable.
     */
    public static <T> int getSize(Iterable<T> it) {
        int numberOfElementsSeen = 0;

        for (T elem : it) {
            numberOfElementsSeen++;
        }

        return numberOfElementsSeen;
    }

    /**
     * Generates an instance of a {@code Person} from valid test data.
     * @return an instance of a {@code Person}.
     */
    public static Person generateTestPerson() {
        try {
            return new Person(new Name(Name.EXAMPLE), new Phone(Phone.EXAMPLE, false),
                    new Email(Email.EXAMPLE, true), new Address(Address.EXAMPLE, false), Collections.emptySet());
        } catch (IllegalValueException e) {
            fail(""test person data should be valid by definition"");
            return null;
        }
    }

    /**
     * Asserts whether the text in the two given files are the same. Ignores any
     * differences in line endings
     */
    public static void assertTextFilesEqual(Path path1, Path path2) throws IOException {
        List<String> list1 = Files.readAllLines(path1, Charset.defaultCharset());
        List<String> list2 = Files.readAllLines(path2, Charset.defaultCharset());
        assertEquals(String.join(""\n"", list1), String.join(""\n"", list2));
    }

    /**
     * Asserts that the file given does not exist on the filesystem.
     */
    public static void assertFileDoesNotExist(String filePath) {
        assertTrue(Files.notExists(Paths.get(filePath)));
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.util;

import java.util.Collections;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;

/**
 * Class to generate typical test persons
 */
public class TypicalPersons {

    private Person amy;
    private Person bill;
    private Person candy;
    private Person dan;

    public TypicalPersons() {
        try {
            amy = new Person(new Name(""Amy Buck""), new Phone(""91119111"", false), new Email(""ab@gmail.com"", false),
                    new Address(""1 Clementi Road"", false), Collections.emptySet());
            bill = new Person(new Name(""Bill Clint""), new Phone(""92229222"", false), new Email(""bc@gmail.com"", false),
                    new Address(""2 Clementi Road"", true), Collections.emptySet());
            candy = new Person(new Name(""Candy Destiny""), new Phone(""93339333"", true),
                    new Email(""cd@gmail.com"", false), new Address(""3 Clementi Road"", true), Collections.emptySet());
            dan = new Person(new Name(""Dan Smith""), new Phone(""1234556"", true), new Email(""ss@tt.com"", true),
                    new Address(""NUS"", true), Collections.singleton(new Tag(""test"")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : ""not possible"";
        }
    }

    /**
     * Inserts predefined {@code Person} objects into a given instance of {@code AddressBook}
     * @param ab AddressBook in which {@code Person} objects will be added.
     */
    private void loadAddressBookWithSampleData(AddressBook ab) {
        try {
            for (Person p : this.getTypicalPersons()) {
                ab.addPerson(new Person(p));
            }
        } catch (IllegalValueException e) {
            assert false : ""not possible"";
        }
    }

    public Person[] getTypicalPersons() {
        return new Person[]{amy, bill, candy, dan};
    }

    public AddressBook getTypicalAddressBook() {
        AddressBook ab = new AddressBook();
        loadAddressBookWithSampleData(ab);
        return ab;
    }

    public Person getAmy() {
        return amy;
    }

    public Person getBill() {
        return bill;
    }

    public Person getCandy() {
        return candy;
    }

    public Person getDan() {
        return dan;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.parser;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.tag.Tag;

public class ParserTest {

    private Parser parser;

    @BeforeEach
    public void setUp() {
        parser = new Parser();
    }

    /*
     * Note how the names of the test methods does not follow the normal naming convention.
     * That is because our coding standard allows a different naming convention for test methods.
     */

    @Test
    public void parse_emptyInput_returnsIncorrect() {
        final String[] emptyInputs = { """", ""  "", ""\n  \n"" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, emptyInputs);
    }

    @Test
    public void parse_unknownCommandWord_returnsHelp() {
        final String input = ""unknowncommandword arguments arguments"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    /*
     * Tests for 0-argument commands =======================================================================
     */

    @Test
    public void parse_helpCommand_parsedCorrectly() {
        final String input = ""help"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    @Test
    public void parse_clearCommand_parsedCorrectly() {
        final String input = ""clear"";
        parseAndAssertCommandType(input, ClearCommand.class);
    }

    @Test
    public void parse_listCommand_parsedCorrectly() {
        final String input = ""list"";
        parseAndAssertCommandType(input, ListCommand.class);
    }

    @Test
    public void parse_exitCommand_parsedCorrectly() {
        final String input = ""exit"";
        parseAndAssertCommandType(input, ExitCommand.class);
    }

    /*
     * Tests for single index argument commands ===============================================================
     */

    @Test
    public void parse_deleteCommandNoArgs_errorMessage() {
        final String[] inputs = { ""delete"", ""delete "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""delete notAnumber "", ""delete 8*wh12"", ""delete 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 1;
        final String input = ""delete "" + testIndex;
        final DeleteCommand result = parseAndAssertCommandType(input, DeleteCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void viewCommandNoArgs_errorMessage() {
        final String[] inputs = { ""view"", ""view "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""view notAnumber "", ""view 8*wh12"", ""view 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 2;
        final String input = ""view "" + testIndex;
        final ViewCommand result = parseAndAssertCommandType(input, ViewCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void parse_viewAllCommandNoArgs_errorMessage() {
        final String[] inputs = { ""viewall"", ""viewall "" };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewAllCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""viewall notAnumber "", ""viewall 8*wh12"", ""viewall 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 3;
        final String input = ""viewall "" + testIndex;
        final ViewAllCommand result = parseAndAssertCommandType(input, ViewAllCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    /*
     * Tests for find persons by keyword in name command ===================================================
     */

    @Test
    public void parse_findCommandInvalidArgs_errorMessage() {
        // no keywords
        final String[] inputs = {
            ""find"",
            ""find ""
        };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_findCommandValidArgs_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        final String input = ""find "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    @Test
    public void parse_findCommandDuplicateKeys_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        // duplicate every keyword
        final String input = ""find "" + String.join("" "", keySet) + "" "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    /*
     * Tests for add person command ==============================================================================
     */

    @Test
    public void parse_addCommandInvalidArgs_errorMessage() {
        final String[] inputs = {
            ""add"",
            ""add "",
            ""add wrong args format"",
            // no phone prefix
            String.format(""add %s %s e/%s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no email prefix
            String.format(""add %s p/%s %s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no address prefix
            String.format(""add %s p/%s e/%s %s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE)
        };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_addCommandInvalidPersonDataInArgs_errorMessge() {
        final String invalidName = ""[]\\[;]"";
        final String validName = Name.EXAMPLE;
        final String invalidPhoneArg = ""p/not__numbers"";
        final String validPhoneArg = ""p/"" + Phone.EXAMPLE;
        final String invalidEmailArg = ""e/notAnEmail123"";
        final String validEmailArg = ""e/"" + Email.EXAMPLE;
        final String invalidTagArg = ""t/invalid_-[.tag"";

        // address can be any string, so no invalid address
        final String addCommandFormatString = ""add %s %s %s a/"" + Address.EXAMPLE;

        // test each incorrect person data field argument individually
        final String[] inputs = {
                // invalid name
                String.format(addCommandFormatString, invalidName, validPhoneArg, validEmailArg),
                // invalid phone
                String.format(addCommandFormatString, validName, invalidPhoneArg, validEmailArg),
                // invalid email
                String.format(addCommandFormatString, validName, validPhoneArg, invalidEmailArg),
                // invalid tag
                String.format(addCommandFormatString, validName, validPhoneArg, validEmailArg) + "" "" + invalidTagArg
        };
        for (String input : inputs) {
            parseAndAssertCommandType(input, IncorrectCommand.class);
        }
    }

    @Test
    public void parse_addCommandValidPersonData_parsedCorrectly() {
        final Person testPerson = generateTestPerson();
        final String input = convertPersonToAddCommandString(testPerson);
        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    @Test
    public void parse_addCommandDuplicateTags_merged() {
        final Person testPerson = generateTestPerson();
        String input = convertPersonToAddCommandString(testPerson);
        for (Tag tag : testPerson.getTags()) {
            // create duplicates by doubling each tag
            input += "" t/"" + tag.tagName;
        }

        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    /**
     * Generates an instance of a {@code Person} from valid test data.
     * @return an instance of a {@code Person}.
     */
    private static Person generateTestPerson() {
        try {
            return new Person(
                new Name(Name.EXAMPLE),
                new Phone(Phone.EXAMPLE, true),
                new Email(Email.EXAMPLE, false),
                new Address(Address.EXAMPLE, true),
                new HashSet<>(Arrays.asList(new Tag(""tag1""), new Tag (""tag2""), new Tag(""tag3"")))
            );
        } catch (IllegalValueException ive) {
            throw new RuntimeException(""test person data should be valid by definition"");
        }
    }

    /**
     * Generates an add command from a {@code ReadOnlyPerson}.
     * @param person whose data will be filled into the string.
     * @return a string describing an {@code AddCommand}.
     */
    private static String convertPersonToAddCommandString(ReadOnlyPerson person) {
        String addCommand = ""add ""
                + person.getName().fullName
                + (person.getPhone().isPrivate() ? "" pp/"" : "" p/"") + person.getPhone().value
                + (person.getEmail().isPrivate() ? "" pe/"" : "" e/"") + person.getEmail().value
                + (person.getAddress().isPrivate() ? "" pa/"" : "" a/"") + person.getAddress().value;
        for (Tag tag : person.getTags()) {
            addCommand += "" t/"" + tag.tagName;
        }
        return addCommand;
    }

    /*
     * Utility methods ====================================================================================
     */

    /**
     * Asserts that parsing the given inputs will return IncorrectCommand with the given feedback message.
     */
    private void parseAndAssertIncorrectWithMessage(String feedbackMessage, String... inputs) {
        for (String input : inputs) {
            final IncorrectCommand result = parseAndAssertCommandType(input, IncorrectCommand.class);
            assertEquals(result.feedbackToUser, feedbackMessage);
        }
    }

    /**
     * Parses input and asserts the class/type of the returned command object.
     *
     * @param input to be parsed
     * @param expectedCommandClass expected class of returned command
     * @return the parsed command object
     */
    private <T extends Command> T parseAndAssertCommandType(String input, Class<T> expectedCommandClass) {
        final Command result = parser.parseCommand(input);
        assertTrue(result.getClass().isAssignableFrom(expectedCommandClass));
        return (T) result;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.storage;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static seedu.addressbook.util.TestUtil.assertFileDoesNotExist;
import static seedu.addressbook.util.TestUtil.assertTextFilesEqual;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

public class StorageFileTest {
    @TempDir
    public static Path testFolder;

    private static final String TEST_DATA_FOLDER = ""test/data/StorageFileTest"";
    private static final String NON_EXISTANT_FILE_NAME = ""ThisFileDoesNotExist.txt"";

    @Test
    public void constructor_nullFilePath_exceptionThrown() throws Exception {
        assertThrows(NullPointerException.class, () -> new StorageFile(null));
    }

    @Test
    public void constructor_noTxtExtension_exceptionThrown() throws Exception {
        assertThrows(IllegalValueException.class, () ->
                new StorageFile(TEST_DATA_FOLDER + ""/"" + ""InvalidfileName""));
    }

    @Test
    public void load_invalidFormat_exceptionThrown() throws Exception {
        // The file contains valid txt data, but does not match the Person format
        StorageFile storage = getStorage(""InvalidData.txt"");
        assertThrows(StorageOperationException.class, () -> storage.load());
    }

    @Test
    public void load_validFormat() throws Exception {
        AddressBook actualAb = getStorage(""ValidData.txt"").load();
        AddressBook expectedAb = getTestAddressBook();

        // ensure loaded AddressBook is properly constructed with test data
        // TODO: overwrite equals method in AddressBook class and replace with equals method below
        assertEquals(actualAb.getAllPersons(), expectedAb.getAllPersons());
    }

    @Test
    public void load_nonExistantFile_returnsEmptyAddressBook() throws Exception {
        AddressBook actualAb = getStorage(NON_EXISTANT_FILE_NAME).load();
        AddressBook expectedAb = new AddressBook();

        assertEquals(actualAb, expectedAb);

        // verify that loading does not result in the file being created
        assertFileDoesNotExist(TEST_DATA_FOLDER + ""/"" + NON_EXISTANT_FILE_NAME);
    }

    @Test
    public void save_nullAddressBook_exceptionThrown() throws Exception {
        StorageFile storage = getTempStorage();
        assertThrows(NullPointerException.class, () -> storage.save(null));
    }

    @Test
    public void save_validAddressBook() throws Exception {
        AddressBook ab = getTestAddressBook();
        StorageFile storage = getTempStorage();
        storage.save(ab);

        assertStorageFilesEqual(storage, getStorage(""ValidData.txt""));
    }

    // getPath() method in StorageFile class is trivial so it is not tested

    /**
     * Asserts that the contents of two storage files are the same.
     */
    private void assertStorageFilesEqual(StorageFile sf1, StorageFile sf2) throws Exception {
        assertTextFilesEqual(Paths.get(sf1.getPath()), Paths.get(sf2.getPath()));
    }

    private StorageFile getStorage(String fileName) throws Exception {
        return new StorageFile(TEST_DATA_FOLDER + ""/"" + fileName);
    }

    private StorageFile getTempStorage() throws Exception {
        return new StorageFile(testFolder.resolve(""temp.txt"").toString());
    }

    private AddressBook getTestAddressBook() throws Exception {
        AddressBook ab = new AddressBook();
        ab.addPerson(new Person(new Name(""John Doe""),
                                new Phone(""98765432"", false),
                                new Email(""johnd@gmail.com"", false),
                                new Address(""John street, block 123, #01-01"", false),
                                Collections.emptySet()));
        ab.addPerson(new Person(new Name(""Betsy Crowe""),
                                new Phone(""1234567"", true),
                                new Email(""betsycrowe@gmail.com"", false),
                                new Address(""Newgate Prison"", true),
                                new HashSet<>(Arrays.asList(new Tag(""friend""), new Tag(""criminal"")))));
        return ab;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.common;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.Arrays;

import org.junit.jupiter.api.Test;

public class UtilsTest {


    @Test
    public void elementsAreUnique() throws Exception {
        // empty list
        assertAreUnique();

        // only one object
        assertAreUnique((Object) null);
        assertAreUnique(1);
        assertAreUnique("""");
        assertAreUnique(""abc"");

        // all objects unique
        assertAreUnique(""abc"", ""ab"", ""a"");
        assertAreUnique(1, 2);

        // some identical objects
        assertNotUnique(""abc"", ""abc"");
        assertNotUnique(""abc"", """", ""abc"", ""ABC"");
        assertNotUnique("""", ""abc"", ""a"", ""abc"");
        assertNotUnique(1, Integer.valueOf(1));
        assertNotUnique(null, 1, Integer.valueOf(1));
        assertNotUnique(null, null);
        assertNotUnique(null, ""a"", ""b"", null);
    }

    @Test
    public void isAnyNull() {
        // no items
        assertFalse(Utils.isAnyNull());

        // varargs array that is null (i.e. no array)
        assertFalse(Utils.isAnyNull((Object[]) null));

        // one item which is null (i.e. an array with one null item)
        assertTrue(Utils.isAnyNull((Object) null));

        // at least one item, none of which are null
        assertFalse(Utils.isAnyNull(""A""));
        assertFalse(Utils.isAnyNull(""A"", """"));
        assertFalse(Utils.isAnyNull(1, 2, ""C""));

        // at least one item, some of which are null
        assertTrue(Utils.isAnyNull(null, 1));
        assertTrue(Utils.isAnyNull(""A"", null, ""C""));
    }

    private void assertAreUnique(Object... objects) {
        assertTrue(Utils.elementsAreUnique(Arrays.asList(objects)));
    }

    private void assertNotUnique(Object... objects) {
        assertFalse(Utils.elementsAreUnique(Arrays.asList(objects)));
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.ui.TextUi;
import seedu.addressbook.util.TestUtil;

public class DeleteCommandTest {

    private AddressBook emptyAddressBook;
    private AddressBook addressBook;

    private List<ReadOnlyPerson> emptyDisplayList;
    private List<ReadOnlyPerson> listWithEveryone;
    private List<ReadOnlyPerson> listWithSurnameDoe;

    @BeforeEach
    public void setUp() throws Exception {
        Person johnDoe = new Person(new Name(""John Doe""), new Phone(""61234567"", false),
                new Email(""john@doe.com"", false), new Address(""395C Ben Road"", false), Collections.emptySet());
        Person janeDoe = new Person(new Name(""Jane Doe""), new Phone(""91234567"", false),
                new Email(""jane@doe.com"", false), new Address(""33G Ohm Road"", false), Collections.emptySet());
        Person samDoe = new Person(new Name(""Sam Doe""), new Phone(""63345566"", false),
                new Email(""sam@doe.com"", false), new Address(""55G Abc Road"", false), Collections.emptySet());
        Person davidGrant = new Person(new Name(""David Grant""), new Phone(""61121122"", false),
                new Email(""david@grant.com"", false), new Address(""44H Define Road"", false),
                Collections.emptySet());

        emptyAddressBook = TestUtil.createAddressBook();
        addressBook = TestUtil.createAddressBook(johnDoe, janeDoe, davidGrant, samDoe);

        emptyDisplayList = TestUtil.createList();

        listWithEveryone = TestUtil.createList(johnDoe, janeDoe, davidGrant, samDoe);
        listWithSurnameDoe = TestUtil.createList(johnDoe, janeDoe, samDoe);
    }

    @Test
    public void execute_emptyAddressBook_returnsPersonNotFoundMessage() {
        assertDeletionFailsDueToNoSuchPerson(1, emptyAddressBook, listWithEveryone);
    }

    @Test
    public void execute_noPersonDisplayed_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(1, addressBook, emptyDisplayList);
    }

    @Test
    public void execute_targetPersonNotInAddressBook_returnsPersonNotFoundMessage()
            throws IllegalValueException {
        Person notInAddressBookPerson = new Person(new Name(""Not In Book""), new Phone(""63331444"", false),
                new Email(""notin@book.com"", false), new Address(""156D Grant Road"", false), Collections.emptySet());
        List<ReadOnlyPerson> listWithPersonNotInAddressBook = TestUtil.createList(notInAddressBookPerson);

        assertDeletionFailsDueToNoSuchPerson(1, addressBook, listWithPersonNotInAddressBook);
    }

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(0, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(-1, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(listWithEveryone.size() + 1, addressBook, listWithEveryone);
    }

    @Test
    public void execute_validIndex_personIsDeleted() throws PersonNotFoundException {
        assertDeletionSuccessful(1, addressBook, listWithSurnameDoe);
        assertDeletionSuccessful(listWithSurnameDoe.size(), addressBook, listWithSurnameDoe);

        int middleIndex = (listWithSurnameDoe.size() / 2) + 1;
        assertDeletionSuccessful(middleIndex, addressBook, listWithSurnameDoe);
    }

    /**
     * Creates a new delete command.
     *
     * @param targetVisibleIndex of the person that we want to delete
     */
    private DeleteCommand createDeleteCommand(int targetVisibleIndex, AddressBook addressBook,
                                                                      List<ReadOnlyPerson> displayList) {

        DeleteCommand command = new DeleteCommand(targetVisibleIndex);
        command.setData(addressBook, displayList);

        return command;
    }

    /**
     * Executes the command, and checks that the execution was what we had expected.
     */
    private void assertCommandBehaviour(DeleteCommand deleteCommand, String expectedMessage,
                                        AddressBook expectedAddressBook, AddressBook actualAddressBook) {

        CommandResult result = deleteCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedAddressBook.getAllPersons(), actualAddressBook.getAllPersons());
    }

    /**
     * Asserts that the index is not valid for the given display list.
     */
    private void assertDeletionFailsDueToInvalidIndex(int invalidVisibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

        DeleteCommand command = createDeleteCommand(invalidVisibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index cannot be deleted, because that person
     * is not in the address book.
     */
    private void assertDeletionFailsDueToNoSuchPerson(int visibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK;

        DeleteCommand command = createDeleteCommand(visibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index can be successfully deleted.
     *
     * The addressBook passed in will not be modified (no side effects).
     *
     * @throws PersonNotFoundException if the selected person is not in the address book
     */
    private void assertDeletionSuccessful(int targetVisibleIndex, AddressBook addressBook,
                                          List<ReadOnlyPerson> displayList) throws PersonNotFoundException {

        ReadOnlyPerson targetPerson = displayList.get(targetVisibleIndex - TextUi.DISPLAYED_INDEX_OFFSET);

        AddressBook expectedAddressBook = TestUtil.clone(addressBook);
        expectedAddressBook.removePerson(targetPerson);
        String expectedMessage = String.format(DeleteCommand.MESSAGE_DELETE_PERSON_SUCCESS, targetPerson);

        AddressBook actualAddressBook = TestUtil.clone(addressBook);

        DeleteCommand command = createDeleteCommand(targetVisibleIndex, actualAddressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, expectedAddressBook, actualAddressBook);
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

public class ViewAllCommandTest {
    // ViewAllCommand is tested together with ViewCommand in ViewCommandTest.
    // This is because they function similarly but ViewCommand hides private information.
    // They are tested with same test data input.
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TestUtil;
import seedu.addressbook.util.TypicalPersons;

public class ViewCommandTest {
    private TypicalPersons td = new TypicalPersons();

    private AddressBook typicalAddressBook = td.getTypicalAddressBook();
    private AddressBook emptyAddressBook = TestUtil.createAddressBook();
    private List<ReadOnlyPerson> emptyPersonList = Collections.emptyList();
    private List<ReadOnlyPerson> listWithAllTypicalPersons = Arrays.asList(td.getTypicalPersons());
    private List<ReadOnlyPerson> listWithSomeTypicalPersons = Arrays.asList(td.getAmy(), td.getCandy(), td.getDan());

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        // empty addressbook
        assertViewErrorInvalidIndex(emptyAddressBook, emptyPersonList, 1);

        // non-empty addressbook
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, -1);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, 0);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons,
                                              listWithAllTypicalPersons.size() + 1);
    }

    @Test
    public void execute_personNotInAddressBook_returnsPersonNotInAddressBookMessage() throws Exception {
        // generate list with person not in addressbook, add to list
        ReadOnlyPerson stranger = new Person(new Name(""me""),
                                             new Phone(""123"", true),
                                             new Email(""some@hey.go"", true),
                                             new Address(""nus"", false),
                                             Collections.emptySet());
        List<ReadOnlyPerson> listWithExtraPerson = new ArrayList<ReadOnlyPerson>(listWithAllTypicalPersons);
        listWithExtraPerson.add(stranger);

        // empty addressbook
        assertViewErrorPersonNotInAddressBook(emptyAddressBook, listWithExtraPerson, 1);

        // non-empty addressbook
        assertViewErrorPersonNotInAddressBook(typicalAddressBook, listWithExtraPerson,
                                                            listWithExtraPerson.size());
    }

    @Test
    public void execute_validIndex_returnsPersonDetails() {
        // person with no private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 1);

        // person with some private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 2);

        // person with all private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 4);

        // Addressbook has more people than the list.
        // This can happen when a command causes the list to show only a sub-set of persons(e.g. FindCommand).
        assertViewSuccess(typicalAddressBook, listWithSomeTypicalPersons, 1);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * invalid index.
     */
    private void assertViewErrorInvalidIndex(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                     int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                          Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * person not existing in the addressbook.
     */
    private void assertViewErrorPersonNotInAddressBook(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                               int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                               Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
    }

    /**
     * Asserts that both a ViewCommand and a ViewAllCommand can retrieve from
     * the {@code addressBook} details of the person at the given {@code targetVisibleIndex}
     * in the given {@code relevantPersons} list.
     *
     * @param targetVisibleIndex one-indexed position of the target person in the list
     */
    private void assertViewSuccess(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                           int targetVisibleIndex) {
        // get person to be viewed (targetVisibleIndex - 1 because index is one-indexed)
        ReadOnlyPerson personToBeViewed = relevantPersons.get(targetVisibleIndex - 1);

        String expectedMessage = String.format(ViewCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextHidePrivate());
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);

        expectedMessage = String.format(ViewAllCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextShowAll());
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Asserts that the Viewcommand and ViewAllcommand reports the given error for the given input.
     */
    private static void assertViewError(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                        int targetVisibleIndex, String expectedMessage) {
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Executes the test command for the given addressbook data.
     * Checks that ViewCommand and ViewAllCommand exhibits the correct command behavior, namely:
     * 1. The feedback message of the CommandResult it returns matches expectedMessage.
     * 2. The CommandResult it returns has no relevant persons.
     * 3. The original addressbook data is not modified after executing ViewCommand and ViewAllCommand.
     */
    private static void assertViewBehavior(Command viewCommand, AddressBook addressBook,
                                           List<ReadOnlyPerson> relevantPersons, String expectedMessage) {
        AddressBook expectedAddressBook = TestUtil.clone(addressBook);

        viewCommand.setData(addressBook, relevantPersons);
        CommandResult result = viewCommand.execute();

        // feedback message is as expected and there are no relevant persons returned.
        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(Optional.empty(), result.getRelevantPersons());

        // addressbook was not modified.
        assertEquals(expectedAddressBook.getAllPersons(), addressBook.getAllPersons());
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TypicalPersons;

public class FindCommandTest {

    private final AddressBook addressBook = new TypicalPersons().getTypicalAddressBook();
    private final TypicalPersons td = new TypicalPersons();

    @Test
    public void execute() throws IllegalValueException {
        //same word, same case: matched
        assertFindCommandBehavior(new String[]{""Amy""}, Arrays.asList(td.getAmy()));

        //same word, different case: not matched
        assertFindCommandBehavior(new String[]{""aMy""}, Collections.emptyList());

        //partial word: not matched
        assertFindCommandBehavior(new String[]{""my""}, Collections.emptyList());

        //multiple words: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Bill"", ""Candy"", ""Destiny""},
                Arrays.asList(td.getAmy(), td.getBill(), td.getCandy()));

        //repeated keywords: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Amy""}, Arrays.asList(td.getAmy()));

        //Keyword matching a word in address: not matched
        assertFindCommandBehavior(new String[]{""Clementi""}, Collections.emptyList());
    }

    /**
     * Executes the find command for the given keywords and verifies
     * the result matches the persons in the expectedPersonList exactly.
     */
    private void assertFindCommandBehavior(String[] keywords, List<ReadOnlyPerson> expectedPersonList) {
        FindCommand command = createFindCommand(keywords);
        CommandResult result = command.execute();

        assertEquals(Command.getMessageForPersonListShownSummary(expectedPersonList), result.feedbackToUser);
    }

    /**
     * Factory method that creates and returns a {@code FindCommand}.
     * @param keywords list of keywords to search for.
     * @return an instance of {@FindCommand} that searches the test AddressBook.
     */
    private FindCommand createFindCommand(String[] keywords) {
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        FindCommand command = new FindCommand(keywordSet);
        command.setData(addressBook, Collections.emptyList());
        return command;
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.util.TestUtil;

public class AddCommandTest {
    private static final List<ReadOnlyPerson> EMPTY_PERSON_LIST = Collections.emptyList();
    private static final Set<String> EMPTY_STRING_SET = Collections.emptySet();

    @Test
    public void addCommand_invalidName_throwsException() {
        final String[] invalidNames = { """", "" "", ""[]\\[;]"" };
        for (String name : invalidNames) {
            assertConstructingInvalidAddCmdThrowsException(name, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                    Address.EXAMPLE, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidPhone_throwsException() {
        final String[] invalidNumbers = { """", "" "", ""1234-5678"", ""[]\\[;]"", ""abc"", ""a123"", ""+651234"" };
        for (String number : invalidNumbers) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, number, false, Email.EXAMPLE, true,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidEmail_throwsException() {
        final String[] invalidEmails = { """", "" "", ""def.com"", ""@"", ""@def"", ""@def.com"", ""abc@"",
                                         ""@invalid@email"", ""invalid@email!"", ""!invalid@email"" };
        for (String email : invalidEmails) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, false, email, false,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidAddress_throwsException() {
        final String[] invalidAddresses = { """", "" "" };
        for (String address : invalidAddresses) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, address, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidTags_throwsException() {
        final String[][] invalidTags = { { """" }, { "" "" }, { ""'"" }, { ""[]\\[;]"" }, { ""validTag"", """" },
                                         { """", "" "" } };
        for (String[] tags : invalidTags) {
            Set<String> tagsToAdd = new HashSet<>(Arrays.asList(tags));
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, Address.EXAMPLE, false, tagsToAdd);
        }
    }

    /**
     * Asserts that attempting to construct an add command with the supplied
     * invalid data throws an IllegalValueException
     */
    private void assertConstructingInvalidAddCmdThrowsException(String name, String phone,
            boolean isPhonePrivate, String email, boolean isEmailPrivate, String address,
            boolean isAddressPrivate, Set<String> tags) {
        try {
            new AddCommand(name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate,
                    tags);
        } catch (IllegalValueException e) {
            return;
        }
        String error = String.format(
                ""An add command was successfully constructed with invalid input: %s %s %s %s %s %s %s %s"",
                name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate, tags);
        fail(error);
    }

    @Test
    public void addCommand_validData_correctlyConstructed() throws Exception {
        AddCommand command = new AddCommand(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                Address.EXAMPLE, true, EMPTY_STRING_SET);
        ReadOnlyPerson p = command.getPerson();

        // TODO: add comparison of tags to person.equals and equality methods to
        // individual fields that compare privacy to simplify this
        assertEquals(Name.EXAMPLE, p.getName().fullName);
        assertEquals(Phone.EXAMPLE, p.getPhone().value);
        assertTrue(p.getPhone().isPrivate());
        assertEquals(Email.EXAMPLE, p.getEmail().value);
        assertFalse(p.getEmail().isPrivate());
        assertEquals(Address.EXAMPLE, p.getAddress().value);
        assertTrue(p.getAddress().isPrivate());
        boolean isTagListEmpty = !p.getTags().iterator().hasNext();
        assertTrue(isTagListEmpty);
    }

    @Test
    public void addCommand_emptyAddressBook_addressBookContainsPerson() {
        Person p = TestUtil.generateTestPerson();
        AddCommand command = new AddCommand(p);
        AddressBook book = new AddressBook();
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();
        UniquePersonList people = book.getAllPersons();

        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS, p), result.feedbackToUser);
    }

    @Test
    public void addCommand_addressBookAlreadyContainsPerson_addressBookUnmodified() throws Exception {
        Person p = TestUtil.generateTestPerson();
        AddressBook book = new AddressBook();
        book.addPerson(p);
        AddCommand command = new AddCommand(p);
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();

        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(AddCommand.MESSAGE_DUPLICATE_PERSON, result.feedbackToUser);
        UniquePersonList people = book.getAllPersons();
        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static seedu.addressbook.util.TestUtil.getSize;
import static seedu.addressbook.util.TestUtil.isEmpty;
import static seedu.addressbook.util.TestUtil.isIdentical;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.data.tag.Tag;

public class AddressBookTest {

    private Tag tagPrizeWinner;
    private Tag tagScientist;
    private Tag tagMathematician;
    private Tag tagEconomist;

    private Person aliceBetsy;
    private Person bobChaplin;
    private Person charlieDouglas;
    private Person davidElliot;

    private AddressBook defaultAddressBook;
    private AddressBook emptyAddressBook;


    @BeforeEach
    public void setUp() throws Exception {
        tagPrizeWinner = new Tag(""prizewinner"");
        tagScientist = new Tag(""scientist"");
        tagMathematician = new Tag(""mathematician"");
        tagEconomist = new Tag(""economist"");

        aliceBetsy = new Person(new Name(""Alice Betsy""),
                                new Phone(""91235468"", false),
                                new Email(""alice@nushackers.org"", false),
                                new Address(""8 Computing Drive, Singapore"", false),
                                Collections.singleton(tagMathematician));

        bobChaplin = new Person(new Name(""Bob Chaplin""),
                                new Phone(""94321500"", false),
                                new Email(""bob@nusgreyhats.org"", false),
                                new Address(""9 Computing Drive"", false),
                                Collections.singleton(tagMathematician));

        charlieDouglas = new Person(new Name(""Charlie Douglas""),
                                    new Phone(""98751365"", false),
                                    new Email(""charlie@nusgdg.org"", false),
                                    new Address(""10 Science Drive"", false),
                                    Collections.singleton(tagScientist));

        davidElliot = new Person(new Name(""David Elliot""),
                                 new Phone(""84512575"", false),
                                 new Email(""douglas@nuscomputing.com"", false),
                                 new Address(""11 Arts Link"", false),
                                 new HashSet<>(Arrays.asList(tagEconomist, tagPrizeWinner)));

        emptyAddressBook = new AddressBook();
        defaultAddressBook = new AddressBook(new UniquePersonList(aliceBetsy, bobChaplin));
    }

    @Test
    public void addPerson_personAlreadyInList_throwsDuplicatePersonException() {
        assertThrows(DuplicatePersonException.class, () -> defaultAddressBook.addPerson(aliceBetsy));
    }

    @Test
    public void containsPerson() throws Exception {
        UniquePersonList personsWhoShouldBeIn = new UniquePersonList(aliceBetsy, bobChaplin);
        UniquePersonList personsWhoShouldNotBeIn = new UniquePersonList(charlieDouglas, davidElliot);

        for (Person personWhoShouldBeIn : personsWhoShouldBeIn) {
            assertTrue(defaultAddressBook.containsPerson(personWhoShouldBeIn));
        }
        for (Person personWhoShouldNotBeIn : personsWhoShouldNotBeIn) {
            assertFalse(defaultAddressBook.containsPerson(personWhoShouldNotBeIn));
        }

        UniquePersonList allPersons = new UniquePersonList(aliceBetsy, bobChaplin, charlieDouglas, davidElliot);

        for (Person person : allPersons) {
            assertFalse(emptyAddressBook.containsPerson(person));
        }
    }

    @Test
    public void removePerson_personExists_removesNormally() throws Exception {
        int numberOfPersonsBeforeRemoval = getSize(defaultAddressBook.getAllPersons());
        defaultAddressBook.removePerson(aliceBetsy);

        assertFalse(defaultAddressBook.containsPerson(aliceBetsy));

        int numberOfPersonsAfterRemoval = getSize(defaultAddressBook.getAllPersons());
        assertTrue(numberOfPersonsAfterRemoval == numberOfPersonsBeforeRemoval - 1);

    }

    @Test
    public void removePerson_personNotExists_throwsPersonNotFoundException() {
        assertThrows(PersonNotFoundException.class, () -> defaultAddressBook.removePerson(charlieDouglas));
    }

    @Test
    public void clear() {
        defaultAddressBook.clear();

        assertTrue(isEmpty(defaultAddressBook.getAllPersons()));
    }

    @Test
    public void getAllPersons() throws Exception {
        UniquePersonList allPersons = defaultAddressBook.getAllPersons();
        UniquePersonList personsToCheck = new UniquePersonList(aliceBetsy, bobChaplin);

        assertTrue(isIdentical(allPersons, personsToCheck));
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.parser.Parser;
import seedu.addressbook.storage.StorageFile;
import seedu.addressbook.storage.StorageFile.InvalidStorageFilePathException;
import seedu.addressbook.storage.StorageFile.StorageOperationException;
import seedu.addressbook.ui.TextUi;


/**
 * Entry point of the Address Book application.
 * Initializes the application and starts the interaction with the user.
 */
public class Main {

    /** Version info of the program. */
    public static final String VERSION = ""AddressBook Level 2 - Version 1.0"";

    private TextUi ui;
    private StorageFile storage;
    private AddressBook addressBook;

    /** The list of person shown to the user most recently.  */
    private List<? extends ReadOnlyPerson> lastShownList = Collections.emptyList();


    public static void main(String... launchArgs) {
        new Main().run(launchArgs);
    }

    /** Runs the program until termination.  */
    public void run(String[] launchArgs) {
        start(launchArgs);
        runCommandLoopUntilExitCommand();
        exit();
    }

    /**
     * Sets up the required objects, loads up the data from the storage file, and prints the welcome message.
     *
     * @param launchArgs arguments supplied by the user at program launch
     *
     */
    private void start(String[] launchArgs) {
        try {
            this.ui = new TextUi();
            this.storage = initializeStorage(launchArgs);
            this.addressBook = storage.load();
            ui.showWelcomeMessage(VERSION, storage.getPath());

        } catch (InvalidStorageFilePathException | StorageOperationException e) {
            ui.showInitFailedMessage();
            /*
             * ==============NOTE TO STUDENTS=========================================================================
             * We are throwing a RuntimeException which is an 'unchecked' exception. Unchecked exceptions do not need
             * to be declared in the method signature.
             * The reason we are using an unchecked exception here is because the caller cannot reasonably be expected
             * to recover from an exception.
             * Cf https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html
             * =======================================================================================================
             */
            throw new RuntimeException(e);
        }
    }

    /** Prints the Goodbye message and exits. */
    private void exit() {
        ui.showGoodbyeMessage();
        System.exit(0);
    }

    /** Reads the user command and executes it, until the user issues the exit command.  */
    private void runCommandLoopUntilExitCommand() {
        Command command;
        do {
            String userCommandText = ui.getUserCommand();
            command = new Parser().parseCommand(userCommandText);
            CommandResult result = executeCommand(command);
            recordResult(result);
            ui.showResultToUser(result);

        } while (!ExitCommand.isExit(command));
    }

    /** Updates the {@link #lastShownList} if the result contains a list of Persons. */
    private void recordResult(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> personList = result.getRelevantPersons();
        if (personList.isPresent()) {
            lastShownList = personList.get();
        }
    }

    /**
     * Executes the command and returns the result.
     *
     * @param command user command
     * @return result of the command
     */
    private CommandResult executeCommand(Command command) {
        try {
            command.setData(addressBook, lastShownList);
            CommandResult result = command.execute();
            storage.save(addressBook);
            return result;
        } catch (Exception e) {
            ui.showToUser(e.getMessage());
            throw new RuntimeException(e);
        }
    }

    /**
     * Creates the StorageFile object based on the user specified path (if any) or the default storage path.
     * @param launchArgs arguments supplied by the user at program launch
     * @throws InvalidStorageFilePathException if the target file path is incorrect.
     */
    private StorageFile initializeStorage(String[] launchArgs) throws InvalidStorageFilePathException {
        boolean isStorageFileSpecifiedByUser = launchArgs.length > 0;
        return isStorageFileSpecifiedByUser ? new StorageFile(launchArgs[0]) : new StorageFile();
    }


}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.ui;

import static seedu.addressbook.common.Messages.MESSAGE_GOODBYE;
import static seedu.addressbook.common.Messages.MESSAGE_INIT_FAILED;
import static seedu.addressbook.common.Messages.MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE;
import static seedu.addressbook.common.Messages.MESSAGE_USING_STORAGE_FILE;
import static seedu.addressbook.common.Messages.MESSAGE_WELCOME;

import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Scanner;

import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Text UI of the application.
 */
public class TextUi {

    /** Offset required to convert between 1-indexing and 0-indexing.  */
    public static final int DISPLAYED_INDEX_OFFSET = 1;

    /** A decorative prefix added to the beginning of lines printed by AddressBook */
    private static final String LINE_PREFIX = ""|| "";

    /** A platform independent line separator. */
    private static final String LS = System.lineSeparator();

    private static final String DIVIDER = ""==================================================="";

    /** Format of indexed list item */
    private static final String MESSAGE_INDEXED_LIST_ITEM = ""\t%1$d. %2$s"";

    /** Format of a comment input line. Comment lines are silently consumed when reading user input. */
    private static final String COMMENT_LINE_FORMAT_REGEX = ""#.*"";

    private final Scanner in;
    private final PrintStream out;

    public TextUi() {
        this(System.in, System.out);
    }

    public TextUi(InputStream in, PrintStream out) {
        this.in = new Scanner(in);
        this.out = out;
    }

    /**
     * Returns true if the user input line should be ignored.
     * Input should be ignored if it is parsed as a comment, is only whitespace, or is empty.
     *
     * @param rawInputLine full raw user input line.
     * @return true if the entire user input line should be ignored.
     */
    private boolean shouldIgnore(String rawInputLine) {
        return rawInputLine.trim().isEmpty() || isCommentLine(rawInputLine);
    }

    /**
     * Returns true if the user input line is a comment line.
     *
     * @param rawInputLine full raw user input line.
     * @return true if input line is a comment.
     */
    private boolean isCommentLine(String rawInputLine) {
        return rawInputLine.trim().matches(COMMENT_LINE_FORMAT_REGEX);
    }

    /**
     * Prompts for the command and reads the text entered by the user.
     * Ignores empty, pure whitespace, and comment lines.
     * Echos the command back to the user.
     * @return command (full line) entered by the user
     */
    public String getUserCommand() {
        out.print(LINE_PREFIX + ""Enter command: "");
        String fullInputLine = in.nextLine();

        // silently consume all ignored lines
        while (shouldIgnore(fullInputLine)) {
            fullInputLine = in.nextLine();
        }

        showToUser(""[Command entered:"" + fullInputLine + ""]"");
        return fullInputLine;
    }

    /**
     * Generates and prints the welcome message upon the start of the application.
     * @param version current version of the application.
     * @param storageFilePath path to the storage file being used.
     */
    public void showWelcomeMessage(String version, String storageFilePath) {
        String storageFileInfo = String.format(MESSAGE_USING_STORAGE_FILE, storageFilePath);
        showToUser(
                DIVIDER,
                DIVIDER,
                MESSAGE_WELCOME,
                version,
                MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE,
                storageFileInfo,
                DIVIDER);
    }

    public void showGoodbyeMessage() {
        showToUser(MESSAGE_GOODBYE, DIVIDER, DIVIDER);
    }


    public void showInitFailedMessage() {
        showToUser(MESSAGE_INIT_FAILED, DIVIDER, DIVIDER);
    }

    /** Shows message(s) to the user */
    public void showToUser(String... message) {
        for (String m : message) {
            out.println(LINE_PREFIX + m.replace(""\n"", LS + LINE_PREFIX));
        }
    }

    /**
     * Shows the result of a command execution to the user. Includes additional formatting to demarcate different
     * command execution segments.
     */
    public void showResultToUser(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> resultPersons = result.getRelevantPersons();
        if (resultPersons.isPresent()) {
            showPersonListView(resultPersons.get());
        }
        showToUser(result.feedbackToUser, DIVIDER);
    }

    /**
     * Shows a list of persons to the user, formatted as an indexed list.
     * Private contact details are hidden.
     */
    private void showPersonListView(List<? extends ReadOnlyPerson> persons) {
        final List<String> formattedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : persons) {
            formattedPersons.add(person.getAsTextHidePrivate());
        }
        showToUserAsIndexedList(formattedPersons);
    }

    /** Shows a list of strings to the user, formatted as an indexed list. */
    private void showToUserAsIndexedList(List<String> list) {
        showToUser(getIndexedListForViewing(list));
    }

    /** Formats a list of strings as a viewable indexed list. */
    private static String getIndexedListForViewing(List<String> listItems) {
        final StringBuilder formatted = new StringBuilder();
        int displayIndex = 0 + DISPLAYED_INDEX_OFFSET;
        for (String listItem : listItems) {
            formatted.append(getIndexedListItem(displayIndex, listItem)).append(""\n"");
            displayIndex++;
        }
        return formatted.toString();
    }

    /**
     * Formats a string as a viewable indexed list item.
     *
     * @param visibleIndex visible index for this listing
     */
    private static String getIndexedListItem(int visibleIndex, String listItem) {
        return String.format(MESSAGE_INDEXED_LIST_ITEM, visibleIndex, listItem);
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.parser;

import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Parses user input.
 */
public class Parser {

    public static final Pattern PERSON_INDEX_ARGS_FORMAT = Pattern.compile(""(?<targetIndex>.+)"");

    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile(""(?<keywords>\\S+(?:\\s+\\S+)*)""); // one or more keywords separated by whitespace

    public static final Pattern PERSON_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile(""(?<name>[^/]+)""
                    + "" (?<isPhonePrivate>p?)p/(?<phone>[^/]+)""
                    + "" (?<isEmailPrivate>p?)e/(?<email>[^/]+)""
                    + "" (?<isAddressPrivate>p?)a/(?<address>[^/]+)""
                    + ""(?<tagArguments>(?: t/[^/]+)*)""); // variable number of tags


    /**
     * Used for initial separation of command word and args.
     */
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile(""(?<commandWord>\\S+)(?<arguments>.*)"");

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group(""commandWord"");
        final String arguments = matcher.group(""arguments"");

        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return prepareFind(arguments);

        case ListCommand.COMMAND_WORD:
            return new ListCommand();

        case ViewCommand.COMMAND_WORD:
            return prepareView(arguments);

        case ViewAllCommand.COMMAND_WORD:
            return prepareViewAll(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD: // Fallthrough
        default:
            return new HelpCommand();
        }
    }

    /**
     * Parses arguments in the context of the add person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return new AddCommand(
                    matcher.group(""name""),

                    matcher.group(""phone""),
                    isPrivatePrefixPresent(matcher.group(""isPhonePrivate"")),

                    matcher.group(""email""),
                    isPrivatePrefixPresent(matcher.group(""isEmailPrivate"")),

                    matcher.group(""address""),
                    isPrivatePrefixPresent(matcher.group(""isAddressPrivate"")),

                    getTagsFromArgs(matcher.group(""tagArguments""))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Returns true if the private prefix is present for a contact detail in the add command's arguments string.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return matchedPrefix.equals(""p"");
    }

    /**
     * Extracts the new person's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst("" t/"", """").split("" t/""));
        return new HashSet<>(tagStrings);
    }


    /**
     * Parses arguments in the context of the delete person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new DeleteCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view all command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareViewAll(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewAllCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewAllCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses the given arguments string as a single index number.
     *
     * @param args arguments string to parse as index number
     * @return the parsed index number
     * @throws ParseException if no region of the args string could be found for the index
     * @throws NumberFormatException the args string region is not a valid number
     */
    private int parseArgsAsDisplayedIndex(String args) throws ParseException, NumberFormatException {
        final Matcher matcher = PERSON_INDEX_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            throw new ParseException(""Could not find index number to parse"");
        }
        return Integer.parseInt(matcher.group(""targetIndex""));
    }


    /**
     * Parses arguments in the context of the find person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group(""keywords"").split(""\\s+"");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    /**
     * Signals that the user input could not be parsed.
     */
    public static class ParseException extends Exception {
        ParseException(String message) {
            super(message);
        }
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.storage;

import static seedu.addressbook.parser.Parser.PERSON_DATA_ARGS_FORMAT;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

/**
 * Decodes the storage data file into an {@code AddressBook} object.
 */
public class AddressBookDecoder {

    /**
     * Decodes {@code encodedAddressBook} into an {@code AddressBook} containing the decoded persons.
     *
     * @throws IllegalValueException if any of the fields in any encoded person string is invalid.
     * @throws StorageOperationException if the {@code encodedAddressBook} is in an invalid format.
     */
    public static AddressBook decodeAddressBook(List<String> encodedAddressBook)
            throws IllegalValueException, StorageOperationException {
        final List<Person> decodedPersons = new ArrayList<>();
        for (String encodedPerson : encodedAddressBook) {
            decodedPersons.add(decodePersonFromString(encodedPerson));
        }
        return new AddressBook(new UniquePersonList(decodedPersons));
    }

    /**
     * Decodes {@code encodedPerson} into a {@code Person}.
     *
     * @throws IllegalValueException if any field in the {@code encodedPerson} is invalid.
     * @throws StorageOperationException if {@code encodedPerson} is in an invalid format.
     */
    private static Person decodePersonFromString(String encodedPerson)
            throws IllegalValueException, StorageOperationException {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(encodedPerson);
        if (!matcher.matches()) {
            throw new StorageOperationException(""Encoded person in invalid format. Unable to decode."");
        }

        return new Person(
                new Name(matcher.group(""name"")),
                new Phone(matcher.group(""phone""), isPrivatePrefixPresent(matcher.group(""isPhonePrivate""))),
                new Email(matcher.group(""email""), isPrivatePrefixPresent(matcher.group(""isEmailPrivate""))),
                new Address(matcher.group(""address""), isPrivatePrefixPresent(matcher.group(""isAddressPrivate""))),
                getTagsFromEncodedPerson(matcher.group(""tagArguments""))
        );
    }

    /**
     * Returns true if {@code matchedPrefix} is equal to the private prefix for contact details.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return ""p"".equals(matchedPrefix);
    }

    /**
     * Extracts the {@code Tag}s from the {@code tagArguments} string.
     * Merges duplicate tag strings.
     */
    private static Set<Tag> getTagsFromEncodedPerson(String tagArguments) throws IllegalValueException {
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }

        // replace first delimiter prefix, then split
        final String[] tagStrings = tagArguments.replaceFirst("" t/"", """").split("" t/"");
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tagStrings) {
            tagSet.add(new Tag(tagName));
        }

        return tagSet;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.storage;

import java.util.ArrayList;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Person;

/**
 * Encodes the {@code AddressBook} object into a data file for storage.
 */
public class AddressBookEncoder {

    /**
     * Encodes all the {@code Person} in the {@code toSave} into a list of decodable and readable string presentation
     * for storage.
     */
    public static List<String> encodeAddressBook(AddressBook toSave) {
        final List<String> encodedPersons = new ArrayList<>();
        toSave.getAllPersons().forEach(person -> encodedPersons.add(encodePersonToString(person)));
        return encodedPersons;
    }

    /**
     * Encodes the {@code person} into a decodable and readable string representation.
     */
    private static String encodePersonToString(Person person) {
        final StringBuilder encodedPersonBuilder = new StringBuilder();

        encodedPersonBuilder.append(person.getName());

        encodedPersonBuilder.append(person.getPhone().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""p/"").append(person.getPhone().value);

        encodedPersonBuilder.append(person.getEmail().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""e/"").append(person.getEmail().value);

        encodedPersonBuilder.append(person.getAddress().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""a/"").append(person.getAddress().value);

        person.getTags().forEach(tag -> encodedPersonBuilder.append("" t/"").append(tag.tagName));

        return encodedPersonBuilder.toString();
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.storage;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents the file used to store address book data.
 */
public class StorageFile {

    /** Default file path used if the user doesn't provide the file name. */
    public static final String DEFAULT_STORAGE_FILEPATH = ""addressbook.txt"";


    public final Path path;

    /**
     * @throws InvalidStorageFilePathException if the default path is invalid
     */
    public StorageFile() throws InvalidStorageFilePathException {
        this(DEFAULT_STORAGE_FILEPATH);
    }

    /**
     * @throws InvalidStorageFilePathException if the given file path is invalid
     */
    public StorageFile(String filePath) throws InvalidStorageFilePathException {
        path = Paths.get(filePath);
        if (!isValidPath(path)) {
            throw new InvalidStorageFilePathException(""Storage file should end with '.txt'"");
        }
    }

    /**
     * Returns true if the given path is acceptable as a storage file.
     * The file path is considered acceptable if it ends with '.txt'
     */
    private static boolean isValidPath(Path filePath) {
        return filePath.toString().endsWith("".txt"");
    }

    /**
     * Saves the {@code addressBook} data to the storage file.
     *
     * @throws StorageOperationException if there were errors converting and/or storing data to file.
     */
    public void save(AddressBook addressBook) throws StorageOperationException {
        try {
            List<String> encodedAddressBook = AddressBookEncoder.encodeAddressBook(addressBook);
            Files.write(path, encodedAddressBook);
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        }
    }

    /**
     * Loads the {@code AddressBook} data from this storage file, and then returns it.
     * Returns an empty {@code AddressBook} if the file does not exist, or is not a regular file.
     *
     * @throws StorageOperationException if there were errors reading and/or converting data from file.
     */
    public AddressBook load() throws StorageOperationException {

        if (!Files.exists(path) || !Files.isRegularFile(path)) {
            return new AddressBook();
        }

        try {
            return AddressBookDecoder.decodeAddressBook(Files.readAllLines(path));
        } catch (FileNotFoundException fnfe) {
            throw new AssertionError(""A non-existent file scenario is already handled earlier."");
        // other errors
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        } catch (IllegalValueException ive) {
            throw new StorageOperationException(""File contains illegal data values; data type constraints not met"");
        }
    }

    public String getPath() {
        return path.toString();
    }

    /* Note: Note the use of nested classes below.
     * More info https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
     */

    /**
     * Signals that the given file path does not fulfill the storage filepath constraints.
     */
    public static class InvalidStorageFilePathException extends IllegalValueException {
        public InvalidStorageFilePathException(String message) {
            super(message);
        }
    }

    /**
     * Signals that some error has occured while trying to convert and read/write data between the application
     * and the storage file.
     */
    public static class StorageOperationException extends Exception {
        public StorageOperationException(String message) {
            super(message);
        }
    }


}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.common;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * Utility methods
 */
public class Utils {

    /**
     * Returns true if any of the given items are null.
     */
    public static boolean isAnyNull(Object... items) {
        if (items == null) {
            return false;
        }
        for (Object item : items) {
            if (item == null) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if every element the given collection are unique by {@link Object#equals(Object)}.
     */
    public static boolean elementsAreUnique(Collection<?> items) {
        final Set<Object> testSet = new HashSet<>();
        for (Object item : items) {
            final boolean itemAlreadyExists = !testSet.add(item); // see Set documentation
            if (itemAlreadyExists) {
                return false;
            }
        }
        return true;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.common;

/**
 * Container for user visible messages.
 */
public class Messages {

    public static final String MESSAGE_GOODBYE = ""Good bye!"";
    public static final String MESSAGE_INIT_FAILED = ""Failed to initialise address book application. Exiting..."";
    public static final String MESSAGE_INVALID_COMMAND_FORMAT = ""Invalid command format! \n%1$s"";
    public static final String MESSAGE_INVALID_PERSON_DISPLAYED_INDEX = ""The person index provided is invalid"";
    public static final String MESSAGE_PERSON_NOT_IN_ADDRESSBOOK = ""Person could not be found in address book"";
    public static final String MESSAGE_PERSONS_LISTED_OVERVIEW = ""%1$d persons listed!"";
    public static final String MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE = ""Launch command format: ""
            + ""java seedu.addressbook.Main [STORAGE_FILE_PATH]"";
    public static final String MESSAGE_WELCOME = ""Welcome to your Address Book!"";
    public static final String MESSAGE_USING_STORAGE_FILE = ""Using storage file : %1$s"";
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows details of the person identified using the last displayed index.
 * Private contact details are not shown.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = ""view"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextHidePrivate()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;


/**
 * Deletes a person identified using it's last displayed index from the address book.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = ""delete"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Deletes the person identified by the index number used in the last person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_DELETE_PERSON_SUCCESS = ""Deleted Person: %1$s"";


    public DeleteCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            addressBook.removePerson(target);
            return new CommandResult(String.format(MESSAGE_DELETE_PERSON_SUCCESS, target));

        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        } catch (PersonNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
        }
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import java.util.List;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = ""list"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Displays all persons in the address book as a list with index numbers.\n""
            + ""Example: "" + COMMAND_WORD;


    @Override
    public CommandResult execute() {
        List<ReadOnlyPerson> allPersons = addressBook.getAllPersons().immutableListView();
        return new CommandResult(getMessageForPersonListShownSummary(allPersons), allPersons);
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows all details of the person identified using the last displayed index.
 * Private contact details are shown.
 */
public class ViewAllCommand extends Command {

    public static final String COMMAND_WORD = ""viewall"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewAllCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextShowAll()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

/**
 * Clears the address book.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = ""clear"";
    public static final String MESSAGE_USAGE = ""Clears address book permanently.\n""
            + ""Example: "" + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = ""Address book has been cleared!"";

    @Override
    public CommandResult execute() {
        addressBook.clear();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import static seedu.addressbook.ui.TextUi.DISPLAYED_INDEX_OFFSET;

import java.util.List;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Represents an executable command.
 */
public class Command {
    protected AddressBook addressBook;
    protected List<? extends ReadOnlyPerson> relevantPersons;
    private int targetIndex = -1;

    /**
     * @param targetIndex last visible listing index of the target person
     */
    public Command(int targetIndex) {
        this.setTargetIndex(targetIndex);
    }

    protected Command() {
    }

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of persons.
     *
     * @param personsDisplayed used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForPersonListShownSummary(List<? extends ReadOnlyPerson> personsDisplayed) {
        return String.format(Messages.MESSAGE_PERSONS_LISTED_OVERVIEW, personsDisplayed.size());
    }

    /**
     * Executes the command and returns the result.
     */
    public CommandResult execute() {
        throw new UnsupportedOperationException(""This method is to be implemented by child classes"");
    };

    /**
     * Supplies the data the command will operate on.
     */
    public void setData(AddressBook addressBook, List<? extends ReadOnlyPerson> relevantPersons) {
        this.addressBook = addressBook;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Extracts the the target person in the last shown list from the given arguments.
     *
     * @throws IndexOutOfBoundsException if the target index is out of bounds of the last viewed listing
     */
    protected ReadOnlyPerson getTargetPerson() throws IndexOutOfBoundsException {
        return relevantPersons.get(getTargetIndex() - DISPLAYED_INDEX_OFFSET);
    }

    public int getTargetIndex() {
        return targetIndex;
    }

    public void setTargetIndex(int targetIndex) {
        this.targetIndex = targetIndex;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;

/**
 * Adds a person to the address book.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = ""add"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Adds a person to the address book. ""
            + ""Contact details can be marked private by prepending 'p' to the prefix.\n""
            + ""Parameters: NAME [p]p/PHONE [p]e/EMAIL [p]a/ADDRESS  [t/TAG]...\n""
            + ""Example: "" + COMMAND_WORD
            + "" John Doe p/98765432 e/johnd@gmail.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney"";

    public static final String MESSAGE_SUCCESS = ""New person added: %1$s"";
    public static final String MESSAGE_DUPLICATE_PERSON = ""This person already exists in the address book"";

    private final Person toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name,
                      String phone, boolean isPhonePrivate,
                      String email, boolean isEmailPrivate,
                      String address, boolean isAddressPrivate,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Person(
                new Name(name),
                new Phone(phone, isPhonePrivate),
                new Email(email, isEmailPrivate),
                new Address(address, isAddressPrivate),
                tagSet
        );
    }

    public AddCommand(Person toAdd) {
        this.toAdd = toAdd;
    }

    public ReadOnlyPerson getPerson() {
        return toAdd;
    }

    @Override
    public CommandResult execute() {
        try {
            addressBook.addPerson(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniquePersonList.DuplicatePersonException dpe) {
            return new CommandResult(MESSAGE_DUPLICATE_PERSON);
        }
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;


/**
 * Shows help instructions.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = ""help"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Shows program usage instructions.\n""
            + ""Example: "" + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        return new CommandResult(
                AddCommand.MESSAGE_USAGE
                + ""\n"" + DeleteCommand.MESSAGE_USAGE
                + ""\n"" + ClearCommand.MESSAGE_USAGE
                + ""\n"" + FindCommand.MESSAGE_USAGE
                + ""\n"" + ListCommand.MESSAGE_USAGE
                + ""\n"" + ViewCommand.MESSAGE_USAGE
                + ""\n"" + ViewAllCommand.MESSAGE_USAGE
                + ""\n"" + HelpCommand.MESSAGE_USAGE
                + ""\n"" + ExitCommand.MESSAGE_USAGE
        );
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;


/**
 * Represents an incorrect command. Upon execution, produces some feedback to the user.
 */
public class IncorrectCommand extends Command {

    public final String feedbackToUser;

    public IncorrectCommand(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
    }

    @Override
    public CommandResult execute() {
        return new CommandResult(feedbackToUser);
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Finds and lists all persons in address book whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = ""find"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Finds all persons whose names contain any of ""
            + ""the specified keywords (case-sensitive) and displays them as a list with index numbers.\n""
            + ""Parameters: KEYWORD [MORE_KEYWORDS]...\n""
            + ""Example: "" + COMMAND_WORD + "" alice bob charlie"";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    /**
     * Returns a copy of keywords in this command.
     */
    public Set<String> getKeywords() {
        return new HashSet<>(keywords);
    }

    @Override
    public CommandResult execute() {
        final List<ReadOnlyPerson> personsFound = getPersonsWithNameContainingAnyKeyword(keywords);
        return new CommandResult(getMessageForPersonListShownSummary(personsFound), personsFound);
    }

    /**
     * Retrieves all persons in the address book whose names contain some of the specified keywords.
     *
     * @param keywords for searching
     * @return list of persons found
     */
    private List<ReadOnlyPerson> getPersonsWithNameContainingAnyKeyword(Set<String> keywords) {
        final List<ReadOnlyPerson> matchedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : addressBook.getAllPersons()) {
            final Set<String> wordsInName = new HashSet<>(person.getName().getWordsInName());
            if (!Collections.disjoint(wordsInName, keywords)) {
                matchedPersons.add(person);
            }
        }
        return matchedPersons;
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = ""exit"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Exits the program.\n""
            + ""Example: "" + COMMAND_WORD;
    public static final String MESSAGE_EXIT_ACKNOWEDGEMENT = ""Exiting Address Book as requested ..."";

    @Override
    public CommandResult execute() {
        return new CommandResult(MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    public static boolean isExit(Command command) {
        return command instanceof ExitCommand; // instanceof returns false if it is null
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.commands;

import java.util.List;
import java.util.Optional;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Represents the result of a command execution.
 */
public class CommandResult {

    /** The feedback message to be shown to the user. Contains a description of the execution result */
    public final String feedbackToUser;

    /** The list of persons that was produced by the command */
    private final List<? extends ReadOnlyPerson> relevantPersons;

    public CommandResult(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
        relevantPersons = null;
    }

    public CommandResult(String feedbackToUser, List<? extends ReadOnlyPerson> relevantPersons) {
        this.feedbackToUser = feedbackToUser;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Returns a list of persons relevant to the command command result, if any.
     */
    public Optional<List<? extends ReadOnlyPerson>> getRelevantPersons() {
        return Optional.ofNullable(relevantPersons);
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data;

import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;

/**
 * Represents the entire address book. Contains the data of the address book.
 */
public class AddressBook {

    private final UniquePersonList allPersons;

    /**
     * Creates an empty address book.
     */
    public AddressBook() {
        allPersons = new UniquePersonList();
    }

    /**
     * Constructs an address book with the given data.
     *
     * @param persons external changes to this will not affect this address book
     */
    public AddressBook(UniquePersonList persons) {
        this.allPersons = new UniquePersonList(persons);
    }

    /**
     * Adds a person to the address book.
     *
     * @throws DuplicatePersonException if an equivalent person already exists.
     */
    public void addPerson(Person toAdd) throws DuplicatePersonException {
        allPersons.add(toAdd);
    }

    /**
     * Returns true if an equivalent person exists in the address book.
     */
    public boolean containsPerson(ReadOnlyPerson key) {
        return allPersons.contains(key);
    }

    /**
     * Removes the equivalent person from the address book.
     *
     * @throws PersonNotFoundException if no such Person could be found.
     */
    public void removePerson(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        allPersons.remove(toRemove);
    }

    /**
     * Clears all persons and tags from the address book.
     */
    public void clear() {
        allPersons.clear();
    }

    /**
     * Returns a new UniquePersonList of all persons in the address book at the time of the call.
     */
    public UniquePersonList getAllPersons() {
        return new UniquePersonList(allPersons);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddressBook // instanceof handles nulls
                        && this.allPersons.equals(((AddressBook) other).allPersons));
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's phone number in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidPhone(String)}
 */
public class Phone {

    public static final String EXAMPLE = ""123456789"";
    public static final String MESSAGE_PHONE_CONSTRAINTS = ""Person phone numbers should only contain numbers"";
    public static final String PHONE_VALIDATION_REGEX = ""\\d+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given phone number.
     *
     * @throws IllegalValueException if given phone string is invalid.
     */
    public Phone(String phone, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedPhone = phone.trim();
        if (!isValidPhone(trimmedPhone)) {
            throw new IllegalValueException(MESSAGE_PHONE_CONSTRAINTS);
        }
        this.value = trimmedPhone;
    }

    /**
     * Returns true if the given string is a valid person phone number.
     */
    public static boolean isValidPhone(String test) {
        return test.matches(PHONE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Phone // instanceof handles nulls
                && this.value.equals(((Phone) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's email in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidEmail(String)}
 */
public class Email {

    public static final String EXAMPLE = ""valid@e.mail"";
    public static final String MESSAGE_EMAIL_CONSTRAINTS =
            ""Person emails should be 2 alphanumeric/period strings separated by '@'"";
    public static final String EMAIL_VALIDATION_REGEX = ""[\\w\\.]+@[\\w\\.]+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given email.
     *
     * @throws IllegalValueException if given email address string is invalid.
     */
    public Email(String email, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedEmail = email.trim();
        if (!isValidEmail(trimmedEmail)) {
            throw new IllegalValueException(MESSAGE_EMAIL_CONSTRAINTS);
        }
        this.value = trimmedEmail;
    }

    /**
     * Returns true if the given string is a valid person email.
     */
    public static boolean isValidEmail(String test) {
        return test.matches(EMAIL_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Email // instanceof handles nulls
                && this.value.equals(((Email) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }


    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.person;

import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * A read-only immutable interface for a Person in the addressbook.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyPerson {

    Name getName();
    Phone getPhone();
    Email getEmail();
    Address getAddress();

    /**
     * Returns a new TagSet that is a deep copy of the internal TagSet,
     * changes on the returned set will not affect the person's internal tags.
     */
    Set<Tag> getTags();

    /**
     * Returns true if both persons have the same identity fields (name and telephone).
     */
    default boolean isSamePerson(ReadOnlyPerson other) {
        return (other == this)
                || (other != null
                    && other.getName().equals(this.getName())
                    && other.getPhone().equals(this.getPhone()));
    }

    /**
     * Returns true if all data in this object is the same as that in another
     * (Note: interfaces cannot override .equals)
     */
    default boolean hasSameData(ReadOnlyPerson other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) // state checks here onwards
                    && other.getPhone().equals(this.getPhone())
                    && other.getEmail().equals(this.getEmail())
                    && other.getAddress().equals(this.getAddress())
                    && other.getTags().equals(this.getTags()));
    }

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsTextShowAll() {
        final StringBuilder builder = new StringBuilder();
        final String detailIsPrivate = ""(private) "";
        builder.append(getName())
                .append("" Phone: "");
        if (getPhone().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getPhone())
                .append("" Email: "");
        if (getEmail().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getEmail())
                .append("" Address: "");
        if (getAddress().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getAddress())
                .append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }

    /**
     * Formats a person as text, showing only non-private contact details.
     */
    default String getAsTextHidePrivate() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (!getPhone().isPrivate()) {
            builder.append("" Phone: "").append(getPhone());
        }
        if (!getEmail().isPrivate()) {
            builder.append("" Email: "").append(getEmail());
        }
        if (!getAddress().isPrivate()) {
            builder.append("" Address: "").append(getAddress());
        }
        builder.append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.person;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.common.Utils;
import seedu.addressbook.data.exception.DuplicateDataException;



/**
 * A list of persons. Does not allow null elements or duplicates.
 *
 * @see Person#equals(Object)
 * @see Utils#elementsAreUnique(Collection)
 */
public class UniquePersonList implements Iterable<Person> {



    private final List<Person> internalList = new ArrayList<>();

    /**
     * Constructs empty person list.
     */
    public UniquePersonList() {}

    /**
     * Constructs a person list with the given persons.
     */
    public UniquePersonList(Person... persons) throws DuplicatePersonException {
        final List<Person> initialTags = Arrays.asList(persons);
        if (!Utils.elementsAreUnique(initialTags)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(initialTags);
    }

    /**
     * Constructs a list from the items in the given collection.
     * @param persons a collection of persons
     * @throws DuplicatePersonException if the {@code persons} contains duplicate persons
     */
    public UniquePersonList(Collection<Person> persons) throws DuplicatePersonException {
        if (!Utils.elementsAreUnique(persons)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(persons);
    }

    /**
     * Constructs a shallow copy of the list.
     */
    public UniquePersonList(UniquePersonList source) {
        internalList.addAll(source.internalList);
    }

    /**
     * Returns an unmodifiable java List view with elements cast as immutable {@link ReadOnlyPerson}s.
     * For use with other methods/libraries.
     * Any changes to the internal list/elements are immediately visible in the returned list.
     */
    public List<ReadOnlyPerson> immutableListView() {
        return Collections.unmodifiableList(internalList);
    }


    /**
     * Checks if the list contains an equivalent person as the given argument.
     * The {@link ReadOnlyPerson#isSamePerson} method is used for this comparison, which
     * defines a weaker notion of equality.
     */
    public boolean contains(ReadOnlyPerson toCheck) {
        for (Person p : internalList) {
            if (p.isSamePerson(toCheck)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a person to the list.
     *
     * @throws DuplicatePersonException if the person to add is a duplicate of an existing person in the list.
     *    The @link{ReadOnlyPerson#isSamePerson} method is used for this comparison,
     *    which defines a weaker notion of equality.
     */
    public void add(Person toAdd) throws DuplicatePersonException {
        if (contains(toAdd)) {
            throw new DuplicatePersonException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent person from the list.
     *
     * @throws PersonNotFoundException if no such person could be found in the list.
     */
    public void remove(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        final boolean personFoundAndDeleted = internalList.remove(toRemove);
        if (!personFoundAndDeleted) {
            throw new PersonNotFoundException();
        }
    }

    /**
     * Clears all persons in list.
     */
    public void clear() {
        internalList.clear();
    }

    @Override
    public Iterator<Person> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniquePersonList // instanceof handles nulls
                        && this.internalList.equals(((UniquePersonList) other).internalList));
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicatePersonException extends DuplicateDataException {
        protected DuplicatePersonException() {
            super(""Operation would result in duplicate persons"");
        }
    }

    /**
     * Signals that an operation targeting a specified person in the list would fail because
     * there is no such matching person in the list.
     */
    public static class PersonNotFoundException extends Exception {}
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's address in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidAddress(String)}
 */
public class Address {

    public static final String EXAMPLE = ""123, some street"";
    public static final String MESSAGE_ADDRESS_CONSTRAINTS = ""Person addresses can be in any format"";
    public static final String ADDRESS_VALIDATION_REGEX = "".+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given address.
     *
     * @throws IllegalValueException if given address string is invalid.
     */
    public Address(String address, boolean isPrivate) throws IllegalValueException {
        String trimmedAddress = address.trim();
        this.isPrivate = isPrivate;
        if (!isValidAddress(trimmedAddress)) {
            throw new IllegalValueException(MESSAGE_ADDRESS_CONSTRAINTS);
        }
        this.value = trimmedAddress;
    }

    /**
     * Returns true if a given string is a valid person address.
     */
    public static boolean isValidAddress(String test) {
        return test.matches(ADDRESS_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Address // instanceof handles nulls
                && this.value.equals(((Address) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.person;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * Represents a Person in the address book.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Person implements ReadOnlyPerson {

    private Name name;
    private Phone phone;
    private Email email;
    private Address address;

    private final Set<Tag> tags = new HashSet<>();

    /**
     * Assumption: Every field must be present and not null.
     */
    public Person(Name name, Phone phone, Email email, Address address, Set<Tag> tags) {
        this.name = name;
        this.phone = phone;
        this.email = email;
        this.address = address;
        this.tags.addAll(tags);
    }

    /**
     * Copy constructor.
     */
    public Person(ReadOnlyPerson source) {
        this(source.getName(), source.getPhone(), source.getEmail(), source.getAddress(), source.getTags());
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public Phone getPhone() {
        return phone;
    }

    @Override
    public Email getEmail() {
        return email;
    }

    @Override
    public Address getAddress() {
        return address;
    }

    @Override
    public Set<Tag> getTags() {
        return new HashSet<>(tags);
    }

    /**
     * Replaces this person's tags with the tags in the argument tag set.
     */
    public void setTags(Set<Tag> replacement) {
        tags.clear();
        tags.addAll(replacement);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyPerson // instanceof handles nulls
                && this.hasSameData((ReadOnlyPerson) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, phone, email, address, tags);
    }

    @Override
    public String toString() {
        return getAsTextShowAll();
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.person;

import java.util.Arrays;
import java.util.List;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's name in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String EXAMPLE = ""John Doe"";
    public static final String MESSAGE_NAME_CONSTRAINTS = ""Person names should be spaces or alphabetic characters"";
    public static final String NAME_VALIDATION_REGEX = ""[\\p{Alpha} ]+"";
    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = trimmedName;
    }

    /**
     * Returns true if the given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }

    /**
     * Retrieves a listing of every word in the name, in order.
     */
    public List<String> getWordsInName() {
        return Arrays.asList(fullName.split(""\\s+""));
    }

    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.exception;

/**
 * Signals an error caused by duplicate data where there should be none.
 */
public abstract class DuplicateDataException extends IllegalValueException {
    public DuplicateDataException(String message) {
        super(message);
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.exception;

/**
 * Signals that some given data does not fulfill some constraints.
 */
public class IllegalValueException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public IllegalValueException(String message) {
        super(message);
    }
}
",0.7,2.17
sc1_v1,4830ac9,"package seedu.addressbook.data.tag;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Tag in the address book.
 * Guarantees: immutable; name is valid as declared in {@link #isValidTagName(String)}
 */
public class Tag {

    public static final String MESSAGE_TAG_CONSTRAINTS = ""Tags names should be alphanumeric"";
    public static final String TAG_VALIDATION_REGEX = ""\\p{Alnum}+"";

    public final String tagName;

    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid tag name.
     */
    public static boolean isValidTagName(String test) {
        return test.matches(TAG_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    @Override
    public String toString() {
        return '[' + tagName + ']';
    }

}
",0.7,2.17
sc1_v2,157fcf1,"package seedu.addressbook.util;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;

/**
 * Utility methods for testing.
 */
public class TestUtil {
    /**
     * Creates an address book containing the given persons.
     */
    public static AddressBook createAddressBook(Person... persons) {
        AddressBook addressBook = new AddressBook();

        for (Person person : persons) {
            try {
                addressBook.addPerson(person);
            } catch (DuplicatePersonException e) {
                throw new AssertionError(e);
            }
        }

        return addressBook;
    }

    /**
     * Creates a list of persons.
     */
    public static List<ReadOnlyPerson> createList(Person...persons) {
        List<ReadOnlyPerson> list = new ArrayList<ReadOnlyPerson>();

        for (Person person : persons) {
            list.add(person);
        }

        return list;
    }

    /**
     * Creates a copy of the original address book with the same entries
     * of Persons and Tags. The Persons and Tags are not cloned.
     */
    public static AddressBook clone(AddressBook addressBook) {
        return new AddressBook(addressBook.getAllPersons());
    }

    /**
     * Returns true if every pair of corresponding elements two iterables are (deeply) identical.
     * In other words, the two containers must have the same elements, in the same order.
     */
    public static <T> boolean isIdentical(Iterable<T> firstIterable, Iterable<T> secondIterable) {
        Iterator<T> currentPtr0 = firstIterable.iterator();
        Iterator<T> currentPtr1 = secondIterable.iterator();

        while (currentPtr0.hasNext() && currentPtr1.hasNext()) {
            T val0 = currentPtr0.next();
            T val1 = currentPtr1.next();

            if (!val0.equals(val1)) {
                return false;
            }
        }

        // If any of the two iterables still have elements, then they have different sizes.
        return !(currentPtr0.hasNext() || currentPtr1.hasNext());
    }

    /**
     * Returns true if the underlying container behind an iterable is empty.
     */
    public static <T> boolean isEmpty(Iterable<T> it) {
        return !it.iterator().hasNext();
    }

    /**
     * Returns the number of elements in the container behind an iterable.
     */
    public static <T> int getSize(Iterable<T> it) {
        int numberOfElementsSeen = 0;

        for (T elem : it) {
            numberOfElementsSeen++;
        }

        return numberOfElementsSeen;
    }

    /**
     * Generates an instance of a {@code Person} from valid test data.
     * @return an instance of a {@code Person}.
     */
    public static Person generateTestPerson() {
        try {
            return new Person(new Name(Name.EXAMPLE), new Phone(Phone.EXAMPLE, false),
                    new Email(Email.EXAMPLE, true), new Address(Address.EXAMPLE, false), Collections.emptySet());
        } catch (IllegalValueException e) {
            fail(""test person data should be valid by definition"");
            return null;
        }
    }

    /**
     * Asserts whether the text in the two given files are the same. Ignores any
     * differences in line endings
     */
    public static void assertTextFilesEqual(Path path1, Path path2) throws IOException {
        List<String> list1 = Files.readAllLines(path1, Charset.defaultCharset());
        List<String> list2 = Files.readAllLines(path2, Charset.defaultCharset());
        assertEquals(String.join(""\n"", list1), String.join(""\n"", list2));
    }

    /**
     * Asserts that the file given does not exist on the filesystem.
     */
    public static void assertFileDoesNotExist(String filePath) {
        assertTrue(Files.notExists(Paths.get(filePath)));
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.util;

import java.util.Collections;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;

/**
 * Class to generate typical test persons
 */
public class TypicalPersons {

    private Person amy;
    private Person bill;
    private Person candy;
    private Person dan;

    public TypicalPersons() {
        try {
            amy = new Person(new Name(""Amy Buck""), new Phone(""91119111"", false), new Email(""ab@gmail.com"", false),
                    new Address(""1 Clementi Road"", false), Collections.emptySet());
            bill = new Person(new Name(""Bill Clint""), new Phone(""92229222"", false), new Email(""bc@gmail.com"", false),
                    new Address(""2 Clementi Road"", true), Collections.emptySet());
            candy = new Person(new Name(""Candy Destiny""), new Phone(""93339333"", true),
                    new Email(""cd@gmail.com"", false), new Address(""3 Clementi Road"", true), Collections.emptySet());
            dan = new Person(new Name(""Dan Smith""), new Phone(""1234556"", true), new Email(""ss@tt.com"", true),
                    new Address(""NUS"", true), Collections.singleton(new Tag(""test"")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : ""not possible"";
        }
    }

    /**
     * Inserts predefined {@code Person} objects into a given instance of {@code AddressBook}
     * @param ab AddressBook in which {@code Person} objects will be added.
     */
    private void loadAddressBookWithSampleData(AddressBook ab) {
        try {
            for (Person p : this.getTypicalPersons()) {
                ab.addPerson(new Person(p));
            }
        } catch (IllegalValueException e) {
            assert false : ""not possible"";
        }
    }

    public Person[] getTypicalPersons() {
        return new Person[]{amy, bill, candy, dan};
    }

    public AddressBook getTypicalAddressBook() {
        AddressBook ab = new AddressBook();
        loadAddressBookWithSampleData(ab);
        return ab;
    }

    public Person getAmy() {
        return amy;
    }

    public Person getBill() {
        return bill;
    }

    public Person getCandy() {
        return candy;
    }

    public Person getDan() {
        return dan;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.parser;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.tag.Tag;

public class ParserTest {

    private Parser parser;

    @BeforeEach
    public void setUp() {
        parser = new Parser();
    }

    /*
     * Note how the names of the test methods does not follow the normal naming convention.
     * That is because our coding standard allows a different naming convention for test methods.
     */

    @Test
    public void parse_emptyInput_returnsIncorrect() {
        final String[] emptyInputs = { """", ""  "", ""\n  \n"" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, emptyInputs);
    }

    @Test
    public void parse_unknownCommandWord_returnsHelp() {
        final String input = ""unknowncommandword arguments arguments"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    /*
     * Tests for 0-argument commands =======================================================================
     */

    @Test
    public void parse_helpCommand_parsedCorrectly() {
        final String input = ""help"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    @Test
    public void parse_clearCommand_parsedCorrectly() {
        final String input = ""clear"";
        parseAndAssertCommandType(input, ClearCommand.class);
    }

    @Test
    public void parse_listCommand_parsedCorrectly() {
        final String input = ""list"";
        parseAndAssertCommandType(input, ListCommand.class);
    }

    @Test
    public void parse_exitCommand_parsedCorrectly() {
        final String input = ""exit"";
        parseAndAssertCommandType(input, ExitCommand.class);
    }

    /*
     * Tests for single index argument commands ===============================================================
     */

    @Test
    public void parse_deleteCommandNoArgs_errorMessage() {
        final String[] inputs = { ""delete"", ""delete "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""delete notAnumber "", ""delete 8*wh12"", ""delete 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 1;
        final String input = ""delete "" + testIndex;
        final DeleteCommand result = parseAndAssertCommandType(input, DeleteCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void viewCommandNoArgs_errorMessage() {
        final String[] inputs = { ""view"", ""view "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""view notAnumber "", ""view 8*wh12"", ""view 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 2;
        final String input = ""view "" + testIndex;
        final ViewCommand result = parseAndAssertCommandType(input, ViewCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void parse_viewAllCommandNoArgs_errorMessage() {
        final String[] inputs = { ""viewall"", ""viewall "" };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewAllCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""viewall notAnumber "", ""viewall 8*wh12"", ""viewall 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 3;
        final String input = ""viewall "" + testIndex;
        final ViewAllCommand result = parseAndAssertCommandType(input, ViewAllCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    /*
     * Tests for find persons by keyword in name command ===================================================
     */

    @Test
    public void parse_findCommandInvalidArgs_errorMessage() {
        // no keywords
        final String[] inputs = {
            ""find"",
            ""find ""
        };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_findCommandValidArgs_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        final String input = ""find "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    @Test
    public void parse_findCommandDuplicateKeys_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        // duplicate every keyword
        final String input = ""find "" + String.join("" "", keySet) + "" "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    /*
     * Tests for add person command ==============================================================================
     */

    @Test
    public void parse_addCommandInvalidArgs_errorMessage() {
        final String[] inputs = {
            ""add"",
            ""add "",
            ""add wrong args format"",
            // no phone prefix
            String.format(""add %s %s e/%s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no email prefix
            String.format(""add %s p/%s %s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no address prefix
            String.format(""add %s p/%s e/%s %s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE)
        };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_addCommandInvalidPersonDataInArgs_errorMessge() {
        final String invalidName = ""[]\\[;]"";
        final String validName = Name.EXAMPLE;
        final String invalidPhoneArg = ""p/not__numbers"";
        final String validPhoneArg = ""p/"" + Phone.EXAMPLE;
        final String invalidEmailArg = ""e/notAnEmail123"";
        final String validEmailArg = ""e/"" + Email.EXAMPLE;
        final String invalidTagArg = ""t/invalid_-[.tag"";

        // address can be any string, so no invalid address
        final String addCommandFormatString = ""add %s %s %s a/"" + Address.EXAMPLE;

        // test each incorrect person data field argument individually
        final String[] inputs = {
                // invalid name
                String.format(addCommandFormatString, invalidName, validPhoneArg, validEmailArg),
                // invalid phone
                String.format(addCommandFormatString, validName, invalidPhoneArg, validEmailArg),
                // invalid email
                String.format(addCommandFormatString, validName, validPhoneArg, invalidEmailArg),
                // invalid tag
                String.format(addCommandFormatString, validName, validPhoneArg, validEmailArg) + "" "" + invalidTagArg
        };
        for (String input : inputs) {
            parseAndAssertCommandType(input, IncorrectCommand.class);
        }
    }

    @Test
    public void parse_addCommandValidPersonData_parsedCorrectly() {
        final Person testPerson = generateTestPerson();
        final String input = convertPersonToAddCommandString(testPerson);
        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    @Test
    public void parse_addCommandDuplicateTags_merged() {
        final Person testPerson = generateTestPerson();
        String input = convertPersonToAddCommandString(testPerson);
        for (Tag tag : testPerson.getTags()) {
            // create duplicates by doubling each tag
            input += "" t/"" + tag.tagName;
        }

        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    /**
     * Generates an instance of a {@code Person} from valid test data.
     * @return an instance of a {@code Person}.
     */
    private static Person generateTestPerson() {
        try {
            return new Person(
                new Name(Name.EXAMPLE),
                new Phone(Phone.EXAMPLE, true),
                new Email(Email.EXAMPLE, false),
                new Address(Address.EXAMPLE, true),
                new HashSet<>(Arrays.asList(new Tag(""tag1""), new Tag (""tag2""), new Tag(""tag3"")))
            );
        } catch (IllegalValueException ive) {
            throw new RuntimeException(""test person data should be valid by definition"");
        }
    }

    /**
     * Generates an add command from a {@code ReadOnlyPerson}.
     * @param person whose data will be filled into the string.
     * @return a string describing an {@code AddCommand}.
     */
    private static String convertPersonToAddCommandString(ReadOnlyPerson person) {
        String addCommand = ""add ""
                + person.getName().fullName
                + (person.getPhone().isPrivate() ? "" pp/"" : "" p/"") + person.getPhone().value
                + (person.getEmail().isPrivate() ? "" pe/"" : "" e/"") + person.getEmail().value
                + (person.getAddress().isPrivate() ? "" pa/"" : "" a/"") + person.getAddress().value;
        for (Tag tag : person.getTags()) {
            addCommand += "" t/"" + tag.tagName;
        }
        return addCommand;
    }

    /*
     * Utility methods ====================================================================================
     */

    /**
     * Asserts that parsing the given inputs will return IncorrectCommand with the given feedback message.
     */
    private void parseAndAssertIncorrectWithMessage(String feedbackMessage, String... inputs) {
        for (String input : inputs) {
            final IncorrectCommand result = parseAndAssertCommandType(input, IncorrectCommand.class);
            assertEquals(result.feedbackToUser, feedbackMessage);
        }
    }

    /**
     * Parses input and asserts the class/type of the returned command object.
     *
     * @param input to be parsed
     * @param expectedCommandClass expected class of returned command
     * @return the parsed command object
     */
    private <T extends Command> T parseAndAssertCommandType(String input, Class<T> expectedCommandClass) {
        final Command result = parser.parseCommand(input);
        assertTrue(result.getClass().isAssignableFrom(expectedCommandClass));
        return (T) result;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.storage;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static seedu.addressbook.util.TestUtil.assertFileDoesNotExist;
import static seedu.addressbook.util.TestUtil.assertTextFilesEqual;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

public class StorageFileTest {
    @TempDir
    public static Path testFolder;

    private static final String TEST_DATA_FOLDER = ""test/data/StorageFileTest"";
    private static final String NON_EXISTANT_FILE_NAME = ""ThisFileDoesNotExist.txt"";

    @Test
    public void constructor_nullFilePath_exceptionThrown() throws Exception {
        assertThrows(NullPointerException.class, () -> new StorageFile(null));
    }

    @Test
    public void constructor_noTxtExtension_exceptionThrown() throws Exception {
        assertThrows(IllegalValueException.class, () ->
                new StorageFile(TEST_DATA_FOLDER + ""/"" + ""InvalidfileName""));
    }

    @Test
    public void load_invalidFormat_exceptionThrown() throws Exception {
        // The file contains valid txt data, but does not match the Person format
        StorageFile storage = getStorage(""InvalidData.txt"");
        assertThrows(StorageOperationException.class, () -> storage.load());
    }

    @Test
    public void load_validFormat() throws Exception {
        AddressBook actualAb = getStorage(""ValidData.txt"").load();
        AddressBook expectedAb = getTestAddressBook();

        // ensure loaded AddressBook is properly constructed with test data
        // TODO: overwrite equals method in AddressBook class and replace with equals method below
        assertEquals(actualAb.getAllPersons(), expectedAb.getAllPersons());
    }

    @Test
    public void load_nonExistantFile_returnsEmptyAddressBook() throws Exception {
        AddressBook actualAb = getStorage(NON_EXISTANT_FILE_NAME).load();
        AddressBook expectedAb = new AddressBook();

        assertEquals(actualAb, expectedAb);

        // verify that loading does not result in the file being created
        assertFileDoesNotExist(TEST_DATA_FOLDER + ""/"" + NON_EXISTANT_FILE_NAME);
    }

    @Test
    public void save_nullAddressBook_exceptionThrown() throws Exception {
        StorageFile storage = getTempStorage();
        assertThrows(NullPointerException.class, () -> storage.save(null));
    }

    @Test
    public void save_validAddressBook() throws Exception {
        AddressBook ab = getTestAddressBook();
        StorageFile storage = getTempStorage();
        storage.save(ab);

        assertStorageFilesEqual(storage, getStorage(""ValidData.txt""));
    }

    // getPath() method in StorageFile class is trivial so it is not tested

    /**
     * Asserts that the contents of two storage files are the same.
     */
    private void assertStorageFilesEqual(StorageFile sf1, StorageFile sf2) throws Exception {
        assertTextFilesEqual(Paths.get(sf1.getPath()), Paths.get(sf2.getPath()));
    }

    private StorageFile getStorage(String fileName) throws Exception {
        return new StorageFile(TEST_DATA_FOLDER + ""/"" + fileName);
    }

    private StorageFile getTempStorage() throws Exception {
        return new StorageFile(testFolder.resolve(""temp.txt"").toString());
    }

    private AddressBook getTestAddressBook() throws Exception {
        AddressBook ab = new AddressBook();
        ab.addPerson(new Person(new Name(""John Doe""),
                                new Phone(""98765432"", false),
                                new Email(""johnd@gmail.com"", false),
                                new Address(""John street, block 123, #01-01"", false),
                                Collections.emptySet()));
        ab.addPerson(new Person(new Name(""Betsy Crowe""),
                                new Phone(""1234567"", true),
                                new Email(""betsycrowe@gmail.com"", false),
                                new Address(""Newgate Prison"", true),
                                new HashSet<>(Arrays.asList(new Tag(""friend""), new Tag(""criminal"")))));
        return ab;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.common;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.Arrays;

import org.junit.jupiter.api.Test;

public class UtilsTest {


    @Test
    public void elementsAreUnique() throws Exception {
        // empty list
        assertAreUnique();

        // only one object
        assertAreUnique((Object) null);
        assertAreUnique(1);
        assertAreUnique("""");
        assertAreUnique(""abc"");

        // all objects unique
        assertAreUnique(""abc"", ""ab"", ""a"");
        assertAreUnique(1, 2);

        // some identical objects
        assertNotUnique(""abc"", ""abc"");
        assertNotUnique(""abc"", """", ""abc"", ""ABC"");
        assertNotUnique("""", ""abc"", ""a"", ""abc"");
        assertNotUnique(1, Integer.valueOf(1));
        assertNotUnique(null, 1, Integer.valueOf(1));
        assertNotUnique(null, null);
        assertNotUnique(null, ""a"", ""b"", null);
    }

    @Test
    public void isAnyNull() {
        // no items
        assertFalse(Utils.isAnyNull());

        // varargs array that is null (i.e. no array)
        assertFalse(Utils.isAnyNull((Object[]) null));

        // one item which is null (i.e. an array with one null item)
        assertTrue(Utils.isAnyNull((Object) null));

        // at least one item, none of which are null
        assertFalse(Utils.isAnyNull(""A""));
        assertFalse(Utils.isAnyNull(""A"", """"));
        assertFalse(Utils.isAnyNull(1, 2, ""C""));

        // at least one item, some of which are null
        assertTrue(Utils.isAnyNull(null, 1));
        assertTrue(Utils.isAnyNull(""A"", null, ""C""));
    }

    private void assertAreUnique(Object... objects) {
        assertTrue(Utils.elementsAreUnique(Arrays.asList(objects)));
    }

    private void assertNotUnique(Object... objects) {
        assertFalse(Utils.elementsAreUnique(Arrays.asList(objects)));
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.ui.TextUi;
import seedu.addressbook.util.TestUtil;

public class DeleteCommandTest {

    private AddressBook emptyAddressBook;
    private AddressBook addressBook;

    private List<ReadOnlyPerson> emptyDisplayList;
    private List<ReadOnlyPerson> listWithEveryone;
    private List<ReadOnlyPerson> listWithSurnameDoe;

    @BeforeEach
    public void setUp() throws Exception {
        Person johnDoe = new Person(new Name(""John Doe""), new Phone(""61234567"", false),
                new Email(""john@doe.com"", false), new Address(""395C Ben Road"", false), Collections.emptySet());
        Person janeDoe = new Person(new Name(""Jane Doe""), new Phone(""91234567"", false),
                new Email(""jane@doe.com"", false), new Address(""33G Ohm Road"", false), Collections.emptySet());
        Person samDoe = new Person(new Name(""Sam Doe""), new Phone(""63345566"", false),
                new Email(""sam@doe.com"", false), new Address(""55G Abc Road"", false), Collections.emptySet());
        Person davidGrant = new Person(new Name(""David Grant""), new Phone(""61121122"", false),
                new Email(""david@grant.com"", false), new Address(""44H Define Road"", false),
                Collections.emptySet());

        emptyAddressBook = TestUtil.createAddressBook();
        addressBook = TestUtil.createAddressBook(johnDoe, janeDoe, davidGrant, samDoe);

        emptyDisplayList = TestUtil.createList();

        listWithEveryone = TestUtil.createList(johnDoe, janeDoe, davidGrant, samDoe);
        listWithSurnameDoe = TestUtil.createList(johnDoe, janeDoe, samDoe);
    }

    @Test
    public void execute_emptyAddressBook_returnsPersonNotFoundMessage() {
        assertDeletionFailsDueToNoSuchPerson(1, emptyAddressBook, listWithEveryone);
    }

    @Test
    public void execute_noPersonDisplayed_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(1, addressBook, emptyDisplayList);
    }

    @Test
    public void execute_targetPersonNotInAddressBook_returnsPersonNotFoundMessage()
            throws IllegalValueException {
        Person notInAddressBookPerson = new Person(new Name(""Not In Book""), new Phone(""63331444"", false),
                new Email(""notin@book.com"", false), new Address(""156D Grant Road"", false), Collections.emptySet());
        List<ReadOnlyPerson> listWithPersonNotInAddressBook = TestUtil.createList(notInAddressBookPerson);

        assertDeletionFailsDueToNoSuchPerson(1, addressBook, listWithPersonNotInAddressBook);
    }

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(0, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(-1, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(listWithEveryone.size() + 1, addressBook, listWithEveryone);
    }

    @Test
    public void execute_validIndex_personIsDeleted() throws PersonNotFoundException {
        assertDeletionSuccessful(1, addressBook, listWithSurnameDoe);
        assertDeletionSuccessful(listWithSurnameDoe.size(), addressBook, listWithSurnameDoe);

        int middleIndex = (listWithSurnameDoe.size() / 2) + 1;
        assertDeletionSuccessful(middleIndex, addressBook, listWithSurnameDoe);
    }

    /**
     * Creates a new delete command.
     *
     * @param targetVisibleIndex of the person that we want to delete
     */
    private DeleteCommand createDeleteCommand(int targetVisibleIndex, AddressBook addressBook,
                                                                      List<ReadOnlyPerson> displayList) {

        DeleteCommand command = new DeleteCommand(targetVisibleIndex);
        command.setData(addressBook, displayList);

        return command;
    }

    /**
     * Executes the command, and checks that the execution was what we had expected.
     */
    private void assertCommandBehaviour(DeleteCommand deleteCommand, String expectedMessage,
                                        AddressBook expectedAddressBook, AddressBook actualAddressBook) {

        CommandResult result = deleteCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedAddressBook.getAllPersons(), actualAddressBook.getAllPersons());
    }

    /**
     * Asserts that the index is not valid for the given display list.
     */
    private void assertDeletionFailsDueToInvalidIndex(int invalidVisibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

        DeleteCommand command = createDeleteCommand(invalidVisibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index cannot be deleted, because that person
     * is not in the address book.
     */
    private void assertDeletionFailsDueToNoSuchPerson(int visibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK;

        DeleteCommand command = createDeleteCommand(visibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index can be successfully deleted.
     *
     * The addressBook passed in will not be modified (no side effects).
     *
     * @throws PersonNotFoundException if the selected person is not in the address book
     */
    private void assertDeletionSuccessful(int targetVisibleIndex, AddressBook addressBook,
                                          List<ReadOnlyPerson> displayList) throws PersonNotFoundException {

        ReadOnlyPerson targetPerson = displayList.get(targetVisibleIndex - TextUi.DISPLAYED_INDEX_OFFSET);

        AddressBook expectedAddressBook = TestUtil.clone(addressBook);
        expectedAddressBook.removePerson(targetPerson);
        String expectedMessage = String.format(DeleteCommand.MESSAGE_DELETE_PERSON_SUCCESS, targetPerson);

        AddressBook actualAddressBook = TestUtil.clone(addressBook);

        DeleteCommand command = createDeleteCommand(targetVisibleIndex, actualAddressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, expectedAddressBook, actualAddressBook);
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

public class ViewAllCommandTest {
    // ViewAllCommand is tested together with ViewCommand in ViewCommandTest.
    // This is because they function similarly but ViewCommand hides private information.
    // They are tested with same test data input.
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TestUtil;
import seedu.addressbook.util.TypicalPersons;

public class ViewCommandTest {
    private TypicalPersons td = new TypicalPersons();

    private AddressBook typicalAddressBook = td.getTypicalAddressBook();
    private AddressBook emptyAddressBook = TestUtil.createAddressBook();
    private List<ReadOnlyPerson> emptyPersonList = Collections.emptyList();
    private List<ReadOnlyPerson> listWithAllTypicalPersons = Arrays.asList(td.getTypicalPersons());
    private List<ReadOnlyPerson> listWithSomeTypicalPersons = Arrays.asList(td.getAmy(), td.getCandy(), td.getDan());

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        // empty addressbook
        assertViewErrorInvalidIndex(emptyAddressBook, emptyPersonList, 1);

        // non-empty addressbook
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, -1);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, 0);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons,
                                              listWithAllTypicalPersons.size() + 1);
    }

    @Test
    public void execute_personNotInAddressBook_returnsPersonNotInAddressBookMessage() throws Exception {
        // generate list with person not in addressbook, add to list
        ReadOnlyPerson stranger = new Person(new Name(""me""),
                                             new Phone(""123"", true),
                                             new Email(""some@hey.go"", true),
                                             new Address(""nus"", false),
                                             Collections.emptySet());
        List<ReadOnlyPerson> listWithExtraPerson = new ArrayList<ReadOnlyPerson>(listWithAllTypicalPersons);
        listWithExtraPerson.add(stranger);

        // empty addressbook
        assertViewErrorPersonNotInAddressBook(emptyAddressBook, listWithExtraPerson, 1);

        // non-empty addressbook
        assertViewErrorPersonNotInAddressBook(typicalAddressBook, listWithExtraPerson,
                                                            listWithExtraPerson.size());
    }

    @Test
    public void execute_validIndex_returnsPersonDetails() {
        // person with no private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 1);

        // person with some private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 2);

        // person with all private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 4);

        // Addressbook has more people than the list.
        // This can happen when a command causes the list to show only a sub-set of persons(e.g. FindCommand).
        assertViewSuccess(typicalAddressBook, listWithSomeTypicalPersons, 1);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * invalid index.
     */
    private void assertViewErrorInvalidIndex(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                     int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                          Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * person not existing in the addressbook.
     */
    private void assertViewErrorPersonNotInAddressBook(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                               int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                               Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
    }

    /**
     * Asserts that both a ViewCommand and a ViewAllCommand can retrieve from
     * the {@code addressBook} details of the person at the given {@code targetVisibleIndex}
     * in the given {@code relevantPersons} list.
     *
     * @param targetVisibleIndex one-indexed position of the target person in the list
     */
    private void assertViewSuccess(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                           int targetVisibleIndex) {
        // get person to be viewed (targetVisibleIndex - 1 because index is one-indexed)
        ReadOnlyPerson personToBeViewed = relevantPersons.get(targetVisibleIndex - 1);

        String expectedMessage = String.format(ViewCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextHidePrivate());
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);

        expectedMessage = String.format(ViewAllCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextShowAll());
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Asserts that the Viewcommand and ViewAllcommand reports the given error for the given input.
     */
    private static void assertViewError(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                        int targetVisibleIndex, String expectedMessage) {
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Executes the test command for the given addressbook data.
     * Checks that ViewCommand and ViewAllCommand exhibits the correct command behavior, namely:
     * 1. The feedback message of the CommandResult it returns matches expectedMessage.
     * 2. The CommandResult it returns has no relevant persons.
     * 3. The original addressbook data is not modified after executing ViewCommand and ViewAllCommand.
     */
    private static void assertViewBehavior(Command viewCommand, AddressBook addressBook,
                                           List<ReadOnlyPerson> relevantPersons, String expectedMessage) {
        AddressBook expectedAddressBook = TestUtil.clone(addressBook);

        viewCommand.setData(addressBook, relevantPersons);
        CommandResult result = viewCommand.execute();

        // feedback message is as expected and there are no relevant persons returned.
        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(Optional.empty(), result.getRelevantPersons());

        // addressbook was not modified.
        assertEquals(expectedAddressBook.getAllPersons(), addressBook.getAllPersons());
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TypicalPersons;

public class FindCommandTest {

    private final AddressBook addressBook = new TypicalPersons().getTypicalAddressBook();
    private final TypicalPersons td = new TypicalPersons();

    @Test
    public void execute() throws IllegalValueException {
        //same word, same case: matched
        assertFindCommandBehavior(new String[]{""Amy""}, Arrays.asList(td.getAmy()));

        //same word, different case: not matched
        assertFindCommandBehavior(new String[]{""aMy""}, Collections.emptyList());

        //partial word: not matched
        assertFindCommandBehavior(new String[]{""my""}, Collections.emptyList());

        //multiple words: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Bill"", ""Candy"", ""Destiny""},
                Arrays.asList(td.getAmy(), td.getBill(), td.getCandy()));

        //repeated keywords: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Amy""}, Arrays.asList(td.getAmy()));

        //Keyword matching a word in address: not matched
        assertFindCommandBehavior(new String[]{""Clementi""}, Collections.emptyList());
    }

    /**
     * Executes the find command for the given keywords and verifies
     * the result matches the persons in the expectedPersonList exactly.
     */
    private void assertFindCommandBehavior(String[] keywords, List<ReadOnlyPerson> expectedPersonList) {
        FindCommand command = createFindCommand(keywords);
        CommandResult result = command.execute();

        assertEquals(Command.getMessageForPersonListShownSummary(expectedPersonList), result.feedbackToUser);
    }

    /**
     * Factory method that creates and returns a {@code FindCommand}.
     * @param keywords list of keywords to search for.
     * @return an instance of {@FindCommand} that searches the test AddressBook.
     */
    private FindCommand createFindCommand(String[] keywords) {
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        FindCommand command = new FindCommand(keywordSet);
        command.setData(addressBook, Collections.emptyList());
        return command;
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.util.TestUtil;

public class AddCommandTest {
    private static final List<ReadOnlyPerson> EMPTY_PERSON_LIST = Collections.emptyList();
    private static final Set<String> EMPTY_STRING_SET = Collections.emptySet();

    @Test
    public void addCommand_invalidName_throwsException() {
        final String[] invalidNames = { """", "" "", ""[]\\[;]"" };
        for (String name : invalidNames) {
            assertConstructingInvalidAddCmdThrowsException(name, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                    Address.EXAMPLE, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidPhone_throwsException() {
        final String[] invalidNumbers = { """", "" "", ""1234-5678"", ""[]\\[;]"", ""abc"", ""a123"", ""+651234"" };
        for (String number : invalidNumbers) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, number, false, Email.EXAMPLE, true,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidEmail_throwsException() {
        final String[] invalidEmails = { """", "" "", ""def.com"", ""@"", ""@def"", ""@def.com"", ""abc@"",
                                         ""@invalid@email"", ""invalid@email!"", ""!invalid@email"" };
        for (String email : invalidEmails) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, false, email, false,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidAddress_throwsException() {
        final String[] invalidAddresses = { """", "" "" };
        for (String address : invalidAddresses) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, address, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidTags_throwsException() {
        final String[][] invalidTags = { { """" }, { "" "" }, { ""'"" }, { ""[]\\[;]"" }, { ""validTag"", """" },
                                         { """", "" "" } };
        for (String[] tags : invalidTags) {
            Set<String> tagsToAdd = new HashSet<>(Arrays.asList(tags));
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, Address.EXAMPLE, false, tagsToAdd);
        }
    }

    /**
     * Asserts that attempting to construct an add command with the supplied
     * invalid data throws an IllegalValueException
     */
    private void assertConstructingInvalidAddCmdThrowsException(String name, String phone,
            boolean isPhonePrivate, String email, boolean isEmailPrivate, String address,
            boolean isAddressPrivate, Set<String> tags) {
        try {
            new AddCommand(name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate,
                    tags);
        } catch (IllegalValueException e) {
            return;
        }
        String error = String.format(
                ""An add command was successfully constructed with invalid input: %s %s %s %s %s %s %s %s"",
                name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate, tags);
        fail(error);
    }

    @Test
    public void addCommand_validData_correctlyConstructed() throws Exception {
        AddCommand command = new AddCommand(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                Address.EXAMPLE, true, EMPTY_STRING_SET);
        ReadOnlyPerson p = command.getPerson();

        // TODO: add comparison of tags to person.equals and equality methods to
        // individual fields that compare privacy to simplify this
        assertEquals(Name.EXAMPLE, p.getName().fullName);
        assertEquals(Phone.EXAMPLE, p.getPhone().value);
        assertTrue(p.getPhone().isPrivate());
        assertEquals(Email.EXAMPLE, p.getEmail().value);
        assertFalse(p.getEmail().isPrivate());
        assertEquals(Address.EXAMPLE, p.getAddress().value);
        assertTrue(p.getAddress().isPrivate());
        boolean isTagListEmpty = !p.getTags().iterator().hasNext();
        assertTrue(isTagListEmpty);
    }

    @Test
    public void addCommand_emptyAddressBook_addressBookContainsPerson() {
        Person p = TestUtil.generateTestPerson();
        AddCommand command = new AddCommand(p);
        AddressBook book = new AddressBook();
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();
        UniquePersonList people = book.getAllPersons();

        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS, p), result.feedbackToUser);
    }

    @Test
    public void addCommand_addressBookAlreadyContainsPerson_addressBookUnmodified() throws Exception {
        Person p = TestUtil.generateTestPerson();
        AddressBook book = new AddressBook();
        book.addPerson(p);
        AddCommand command = new AddCommand(p);
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();

        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(AddCommand.MESSAGE_DUPLICATE_PERSON, result.feedbackToUser);
        UniquePersonList people = book.getAllPersons();
        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static seedu.addressbook.util.TestUtil.getSize;
import static seedu.addressbook.util.TestUtil.isEmpty;
import static seedu.addressbook.util.TestUtil.isIdentical;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.data.tag.Tag;

public class AddressBookTest {

    private Tag tagPrizeWinner;
    private Tag tagScientist;
    private Tag tagMathematician;
    private Tag tagEconomist;

    private Person aliceBetsy;
    private Person bobChaplin;
    private Person charlieDouglas;
    private Person davidElliot;

    private AddressBook defaultAddressBook;
    private AddressBook emptyAddressBook;


    @BeforeEach
    public void setUp() throws Exception {
        tagPrizeWinner = new Tag(""prizewinner"");
        tagScientist = new Tag(""scientist"");
        tagMathematician = new Tag(""mathematician"");
        tagEconomist = new Tag(""economist"");

        aliceBetsy = new Person(new Name(""Alice Betsy""),
                                new Phone(""91235468"", false),
                                new Email(""alice@nushackers.org"", false),
                                new Address(""8 Computing Drive, Singapore"", false),
                                Collections.singleton(tagMathematician));

        bobChaplin = new Person(new Name(""Bob Chaplin""),
                                new Phone(""94321500"", false),
                                new Email(""bob@nusgreyhats.org"", false),
                                new Address(""9 Computing Drive"", false),
                                Collections.singleton(tagMathematician));

        charlieDouglas = new Person(new Name(""Charlie Douglas""),
                                    new Phone(""98751365"", false),
                                    new Email(""charlie@nusgdg.org"", false),
                                    new Address(""10 Science Drive"", false),
                                    Collections.singleton(tagScientist));

        davidElliot = new Person(new Name(""David Elliot""),
                                 new Phone(""84512575"", false),
                                 new Email(""douglas@nuscomputing.com"", false),
                                 new Address(""11 Arts Link"", false),
                                 new HashSet<>(Arrays.asList(tagEconomist, tagPrizeWinner)));

        emptyAddressBook = new AddressBook();
        defaultAddressBook = new AddressBook(new UniquePersonList(aliceBetsy, bobChaplin));
    }

    @Test
    public void addPerson_personAlreadyInList_throwsDuplicatePersonException() {
        assertThrows(DuplicatePersonException.class, () -> defaultAddressBook.addPerson(aliceBetsy));
    }

    @Test
    public void containsPerson() throws Exception {
        UniquePersonList personsWhoShouldBeIn = new UniquePersonList(aliceBetsy, bobChaplin);
        UniquePersonList personsWhoShouldNotBeIn = new UniquePersonList(charlieDouglas, davidElliot);

        for (Person personWhoShouldBeIn : personsWhoShouldBeIn) {
            assertTrue(defaultAddressBook.containsPerson(personWhoShouldBeIn));
        }
        for (Person personWhoShouldNotBeIn : personsWhoShouldNotBeIn) {
            assertFalse(defaultAddressBook.containsPerson(personWhoShouldNotBeIn));
        }

        UniquePersonList allPersons = new UniquePersonList(aliceBetsy, bobChaplin, charlieDouglas, davidElliot);

        for (Person person : allPersons) {
            assertFalse(emptyAddressBook.containsPerson(person));
        }
    }

    @Test
    public void removePerson_personExists_removesNormally() throws Exception {
        int numberOfPersonsBeforeRemoval = getSize(defaultAddressBook.getAllPersons());
        defaultAddressBook.removePerson(aliceBetsy);

        assertFalse(defaultAddressBook.containsPerson(aliceBetsy));

        int numberOfPersonsAfterRemoval = getSize(defaultAddressBook.getAllPersons());
        assertTrue(numberOfPersonsAfterRemoval == numberOfPersonsBeforeRemoval - 1);

    }

    @Test
    public void removePerson_personNotExists_throwsPersonNotFoundException() {
        assertThrows(PersonNotFoundException.class, () -> defaultAddressBook.removePerson(charlieDouglas));
    }

    @Test
    public void clear() {
        defaultAddressBook.clear();

        assertTrue(isEmpty(defaultAddressBook.getAllPersons()));
    }

    @Test
    public void getAllPersons() throws Exception {
        UniquePersonList allPersons = defaultAddressBook.getAllPersons();
        UniquePersonList personsToCheck = new UniquePersonList(aliceBetsy, bobChaplin);

        assertTrue(isIdentical(allPersons, personsToCheck));
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.parser.Parser;
import seedu.addressbook.storage.StorageFile;
import seedu.addressbook.storage.StorageFile.InvalidStorageFilePathException;
import seedu.addressbook.storage.StorageFile.StorageOperationException;
import seedu.addressbook.ui.TextUi;


/**
 * Entry point of the Address Book application.
 * Initializes the application and starts the interaction with the user.
 */
public class Main {

    /** Version info of the program. */
    public static final String VERSION = ""AddressBook Level 2 - Version 1.0"";

    private TextUi ui;
    private StorageFile storage;
    private AddressBook addressBook;

    /** The list of person shown to the user most recently.  */
    private List<? extends ReadOnlyPerson> lastShownList = Collections.emptyList();


    public static void main(String... launchArgs) {
        new Main().run(launchArgs);
    }

    /** Runs the program until termination.  */
    public void run(String[] launchArgs) {
        start(launchArgs);
        runCommandLoopUntilExitCommand();
        exit();
    }

    /**
     * Sets up the required objects, loads up the data from the storage file, and prints the welcome message.
     *
     * @param launchArgs arguments supplied by the user at program launch
     *
     */
    private void start(String[] launchArgs) {
        try {
            this.ui = new TextUi();
            this.storage = initializeStorage(launchArgs);
            this.addressBook = storage.load();
            ui.showWelcomeMessage(VERSION, storage.getPath());

        } catch (InvalidStorageFilePathException | StorageOperationException e) {
            ui.showInitFailedMessage();
            /*
             * ==============NOTE TO STUDENTS=========================================================================
             * We are throwing a RuntimeException which is an 'unchecked' exception. Unchecked exceptions do not need
             * to be declared in the method signature.
             * The reason we are using an unchecked exception here is because the caller cannot reasonably be expected
             * to recover from an exception.
             * Cf https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html
             * =======================================================================================================
             */
            throw new RuntimeException(e);
        }
    }

    /** Prints the Goodbye message and exits. */
    private void exit() {
        ui.showGoodbyeMessage();
        System.exit(0);
    }

    /** Reads the user command and executes it, until the user issues the exit command.  */
    private void runCommandLoopUntilExitCommand() {
        Command command;
        do {
            String userCommandText = ui.getUserCommand();
            command = new Parser().parseCommand(userCommandText);
            CommandResult result = executeCommand(command);
            recordResult(result);
            ui.showResultToUser(result);

        } while (!ExitCommand.isExit(command));
    }

    /** Updates the {@link #lastShownList} if the result contains a list of Persons. */
    private void recordResult(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> personList = result.getRelevantPersons();
        if (personList.isPresent()) {
            lastShownList = personList.get();
        }
    }

    /**
     * Executes the command and returns the result.
     *
     * @param command user command
     * @return result of the command
     */
    private CommandResult executeCommand(Command command) {
        try {
            command.setData(addressBook, lastShownList);
            CommandResult result = command.execute();
            storage.save(addressBook);
            return result;
        } catch (Exception e) {
            ui.showToUser(e.getMessage());
            throw new RuntimeException(e);
        }
    }

    /**
     * Creates the StorageFile object based on the user specified path (if any) or the default storage path.
     * @param launchArgs arguments supplied by the user at program launch
     * @throws InvalidStorageFilePathException if the target file path is incorrect.
     */
    private StorageFile initializeStorage(String[] launchArgs) throws InvalidStorageFilePathException {
        boolean isStorageFileSpecifiedByUser = launchArgs.length > 0;
        return isStorageFileSpecifiedByUser ? new StorageFile(launchArgs[0]) : new StorageFile();
    }


}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.ui;

import static seedu.addressbook.common.Messages.MESSAGE_GOODBYE;
import static seedu.addressbook.common.Messages.MESSAGE_INIT_FAILED;
import static seedu.addressbook.common.Messages.MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE;
import static seedu.addressbook.common.Messages.MESSAGE_USING_STORAGE_FILE;
import static seedu.addressbook.common.Messages.MESSAGE_WELCOME;

import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Scanner;

import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Text UI of the application.
 */
public class TextUi {

    /** Offset required to convert between 1-indexing and 0-indexing.  */
    public static final int DISPLAYED_INDEX_OFFSET = 1;

    /** A decorative prefix added to the beginning of lines printed by AddressBook */
    private static final String LINE_PREFIX = ""|| "";

    /** A platform independent line separator. */
    private static final String LS = System.lineSeparator();

    private static final String DIVIDER = ""==================================================="";

    /** Format of indexed list item */
    private static final String MESSAGE_INDEXED_LIST_ITEM = ""\t%1$d. %2$s"";

    /** Format of a comment input line. Comment lines are silently consumed when reading user input. */
    private static final String COMMENT_LINE_FORMAT_REGEX = ""#.*"";

    private final Scanner in;
    private final PrintStream out;

    public TextUi() {
        this(System.in, System.out);
    }

    public TextUi(InputStream in, PrintStream out) {
        this.in = new Scanner(in);
        this.out = out;
    }

    /**
     * Returns true if the user input line should be ignored.
     * Input should be ignored if it is parsed as a comment, is only whitespace, or is empty.
     *
     * @param rawInputLine full raw user input line.
     * @return true if the entire user input line should be ignored.
     */
    private boolean shouldIgnore(String rawInputLine) {
        return rawInputLine.trim().isEmpty() || isCommentLine(rawInputLine);
    }

    /**
     * Returns true if the user input line is a comment line.
     *
     * @param rawInputLine full raw user input line.
     * @return true if input line is a comment.
     */
    private boolean isCommentLine(String rawInputLine) {
        return rawInputLine.trim().matches(COMMENT_LINE_FORMAT_REGEX);
    }

    /**
     * Prompts for the command and reads the text entered by the user.
     * Ignores empty, pure whitespace, and comment lines.
     * Echos the command back to the user.
     * @return command (full line) entered by the user
     */
    public String getUserCommand() {
        out.print(LINE_PREFIX + ""Enter command: "");
        String fullInputLine = in.nextLine();

        // silently consume all ignored lines
        while (shouldIgnore(fullInputLine)) {
            fullInputLine = in.nextLine();
        }

        showToUser(""[Command entered:"" + fullInputLine + ""]"");
        return fullInputLine;
    }

    /**
     * Generates and prints the welcome message upon the start of the application.
     * @param version current version of the application.
     * @param storageFilePath path to the storage file being used.
     */
    public void showWelcomeMessage(String version, String storageFilePath) {
        String storageFileInfo = String.format(MESSAGE_USING_STORAGE_FILE, storageFilePath);
        showToUser(
                DIVIDER,
                DIVIDER,
                MESSAGE_WELCOME,
                version,
                MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE,
                storageFileInfo,
                DIVIDER);
    }

    public void showGoodbyeMessage() {
        showToUser(MESSAGE_GOODBYE, DIVIDER, DIVIDER);
    }


    public void showInitFailedMessage() {
        showToUser(MESSAGE_INIT_FAILED, DIVIDER, DIVIDER);
    }

    /** Shows message(s) to the user */
    public void showToUser(String... message) {
        for (String m : message) {
            out.println(LINE_PREFIX + m.replace(""\n"", LS + LINE_PREFIX));
        }
    }

    /**
     * Shows the result of a command execution to the user. Includes additional formatting to demarcate different
     * command execution segments.
     */
    public void showResultToUser(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> resultPersons = result.getRelevantPersons();
        if (resultPersons.isPresent()) {
            showPersonListView(resultPersons.get());
        }
        showToUser(result.feedbackToUser, DIVIDER);
    }

    /**
     * Shows a list of persons to the user, formatted as an indexed list.
     * Private contact details are hidden.
     */
    private void showPersonListView(List<? extends ReadOnlyPerson> persons) {
        final List<String> formattedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : persons) {
            formattedPersons.add(person.getAsTextHidePrivate());
        }
        showToUserAsIndexedList(formattedPersons);
    }

    /** Shows a list of strings to the user, formatted as an indexed list. */
    private void showToUserAsIndexedList(List<String> list) {
        showToUser(getIndexedListForViewing(list));
    }

    /** Formats a list of strings as a viewable indexed list. */
    private static String getIndexedListForViewing(List<String> listItems) {
        final StringBuilder formatted = new StringBuilder();
        int displayIndex = 0 + DISPLAYED_INDEX_OFFSET;
        for (String listItem : listItems) {
            formatted.append(getIndexedListItem(displayIndex, listItem)).append(""\n"");
            displayIndex++;
        }
        return formatted.toString();
    }

    /**
     * Formats a string as a viewable indexed list item.
     *
     * @param visibleIndex visible index for this listing
     */
    private static String getIndexedListItem(int visibleIndex, String listItem) {
        return String.format(MESSAGE_INDEXED_LIST_ITEM, visibleIndex, listItem);
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.parser;

import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Parses user input.
 */
public class Parser {

    public static final Pattern PERSON_INDEX_ARGS_FORMAT = Pattern.compile(""(?<targetIndex>.+)"");

    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile(""(?<keywords>\\S+(?:\\s+\\S+)*)""); // one or more keywords separated by whitespace

    public static final Pattern PERSON_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile(""(?<name>[^/]+)""
                    + "" (?<isPhonePrivate>p?)p/(?<phone>[^/]+)""
                    + "" (?<isEmailPrivate>p?)e/(?<email>[^/]+)""
                    + "" (?<isAddressPrivate>p?)a/(?<address>[^/]+)""
                    + ""(?<tagArguments>(?: t/[^/]+)*)""); // variable number of tags


    /**
     * Used for initial separation of command word and args.
     */
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile(""(?<commandWord>\\S+)(?<arguments>.*)"");

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group(""commandWord"");
        final String arguments = matcher.group(""arguments"");

        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return prepareFind(arguments);

        case ListCommand.COMMAND_WORD:
            return new ListCommand();

        case ViewCommand.COMMAND_WORD:
            return prepareView(arguments);

        case ViewAllCommand.COMMAND_WORD:
            return prepareViewAll(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD: // Fallthrough
        default:
            return new HelpCommand();
        }
    }

    /**
     * Parses arguments in the context of the add person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return new AddCommand(
                    matcher.group(""name""),

                    matcher.group(""phone""),
                    isPrivatePrefixPresent(matcher.group(""isPhonePrivate"")),

                    matcher.group(""email""),
                    isPrivatePrefixPresent(matcher.group(""isEmailPrivate"")),

                    matcher.group(""address""),
                    isPrivatePrefixPresent(matcher.group(""isAddressPrivate"")),

                    getTagsFromArgs(matcher.group(""tagArguments""))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Returns true if the private prefix is present for a contact detail in the add command's arguments string.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return matchedPrefix.equals(""p"");
    }

    /**
     * Extracts the new person's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst("" t/"", """").split("" t/""));
        return new HashSet<>(tagStrings);
    }


    /**
     * Parses arguments in the context of the delete person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new DeleteCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view all command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareViewAll(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewAllCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewAllCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses the given arguments string as a single index number.
     *
     * @param args arguments string to parse as index number
     * @return the parsed index number
     * @throws ParseException if no region of the args string could be found for the index
     * @throws NumberFormatException the args string region is not a valid number
     */
    private int parseArgsAsDisplayedIndex(String args) throws ParseException, NumberFormatException {
        final Matcher matcher = PERSON_INDEX_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            throw new ParseException(""Could not find index number to parse"");
        }
        return Integer.parseInt(matcher.group(""targetIndex""));
    }


    /**
     * Parses arguments in the context of the find person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group(""keywords"").split(""\\s+"");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    /**
     * Signals that the user input could not be parsed.
     */
    public static class ParseException extends Exception {
        ParseException(String message) {
            super(message);
        }
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.storage;

import static seedu.addressbook.parser.Parser.PERSON_DATA_ARGS_FORMAT;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

/**
 * Decodes the storage data file into an {@code AddressBook} object.
 */
public class AddressBookDecoder {

    /**
     * Decodes {@code encodedAddressBook} into an {@code AddressBook} containing the decoded persons.
     *
     * @throws IllegalValueException if any of the fields in any encoded person string is invalid.
     * @throws StorageOperationException if the {@code encodedAddressBook} is in an invalid format.
     */
    public static AddressBook decodeAddressBook(List<String> encodedAddressBook)
            throws IllegalValueException, StorageOperationException {
        final List<Person> decodedPersons = new ArrayList<>();
        for (String encodedPerson : encodedAddressBook) {
            decodedPersons.add(decodePersonFromString(encodedPerson));
        }
        return new AddressBook(new UniquePersonList(decodedPersons));
    }

    /**
     * Decodes {@code encodedPerson} into a {@code Person}.
     *
     * @throws IllegalValueException if any field in the {@code encodedPerson} is invalid.
     * @throws StorageOperationException if {@code encodedPerson} is in an invalid format.
     */
    private static Person decodePersonFromString(String encodedPerson)
            throws IllegalValueException, StorageOperationException {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(encodedPerson);
        if (!matcher.matches()) {
            throw new StorageOperationException(""Encoded person in invalid format. Unable to decode."");
        }

        return new Person(
                new Name(matcher.group(""name"")),
                new Phone(matcher.group(""phone""), isPrivatePrefixPresent(matcher.group(""isPhonePrivate""))),
                new Email(matcher.group(""email""), isPrivatePrefixPresent(matcher.group(""isEmailPrivate""))),
                new Address(matcher.group(""address""), isPrivatePrefixPresent(matcher.group(""isAddressPrivate""))),
                getTagsFromEncodedPerson(matcher.group(""tagArguments""))
        );
    }

    /**
     * Returns true if {@code matchedPrefix} is equal to the private prefix for contact details.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return ""p"".equals(matchedPrefix);
    }

    /**
     * Extracts the {@code Tag}s from the {@code tagArguments} string.
     * Merges duplicate tag strings.
     */
    private static Set<Tag> getTagsFromEncodedPerson(String tagArguments) throws IllegalValueException {
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }

        // replace first delimiter prefix, then split
        final String[] tagStrings = tagArguments.replaceFirst("" t/"", """").split("" t/"");
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tagStrings) {
            tagSet.add(new Tag(tagName));
        }

        return tagSet;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.storage;

import java.util.ArrayList;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Person;

/**
 * Encodes the {@code AddressBook} object into a data file for storage.
 */
public class AddressBookEncoder {

    /**
     * Encodes all the {@code Person} in the {@code toSave} into a list of decodable and readable string presentation
     * for storage.
     */
    public static List<String> encodeAddressBook(AddressBook toSave) {
        final List<String> encodedPersons = new ArrayList<>();
        toSave.getAllPersons().forEach(person -> encodedPersons.add(encodePersonToString(person)));
        return encodedPersons;
    }

    /**
     * Encodes the {@code person} into a decodable and readable string representation.
     */
    private static String encodePersonToString(Person person) {
        final StringBuilder encodedPersonBuilder = new StringBuilder();

        encodedPersonBuilder.append(person.getName());

        encodedPersonBuilder.append(person.getPhone().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""p/"").append(person.getPhone().value);

        encodedPersonBuilder.append(person.getEmail().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""e/"").append(person.getEmail().value);

        encodedPersonBuilder.append(person.getAddress().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""a/"").append(person.getAddress().value);

        person.getTags().forEach(tag -> encodedPersonBuilder.append("" t/"").append(tag.tagName));

        return encodedPersonBuilder.toString();
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.storage;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents the file used to store address book data.
 */
public class StorageFile {

    /** Default file path used if the user doesn't provide the file name. */
    public static final String DEFAULT_STORAGE_FILEPATH = ""addressbook.txt"";


    public final Path path;

    /**
     * @throws InvalidStorageFilePathException if the default path is invalid
     */
    public StorageFile() throws InvalidStorageFilePathException {
        this(DEFAULT_STORAGE_FILEPATH);
    }

    /**
     * @throws InvalidStorageFilePathException if the given file path is invalid
     */
    public StorageFile(String filePath) throws InvalidStorageFilePathException {
        path = Paths.get(filePath);
        if (!isValidPath(path)) {
            throw new InvalidStorageFilePathException(""Storage file should end with '.txt'"");
        }
    }

    /**
     * Returns true if the given path is acceptable as a storage file.
     * The file path is considered acceptable if it ends with '.txt'
     */
    private static boolean isValidPath(Path filePath) {
        return filePath.toString().endsWith("".txt"");
    }

    /**
     * Saves the {@code addressBook} data to the storage file.
     *
     * @throws StorageOperationException if there were errors converting and/or storing data to file.
     */
    public void save(AddressBook addressBook) throws StorageOperationException {
        try {
            List<String> encodedAddressBook = AddressBookEncoder.encodeAddressBook(addressBook);
            Files.write(path, encodedAddressBook);
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        }
    }

    /**
     * Loads the {@code AddressBook} data from this storage file, and then returns it.
     * Returns an empty {@code AddressBook} if the file does not exist, or is not a regular file.
     *
     * @throws StorageOperationException if there were errors reading and/or converting data from file.
     */
    public AddressBook load() throws StorageOperationException {

        if (!Files.exists(path) || !Files.isRegularFile(path)) {
            return new AddressBook();
        }

        try {
            return AddressBookDecoder.decodeAddressBook(Files.readAllLines(path));
        } catch (FileNotFoundException fnfe) {
            throw new AssertionError(""A non-existent file scenario is already handled earlier."");
        // other errors
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        } catch (IllegalValueException ive) {
            throw new StorageOperationException(""File contains illegal data values; data type constraints not met"");
        }
    }

    public String getPath() {
        return path.toString();
    }

    /* Note: Note the use of nested classes below.
     * More info https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
     */

    /**
     * Signals that the given file path does not fulfill the storage filepath constraints.
     */
    public static class InvalidStorageFilePathException extends IllegalValueException {
        public InvalidStorageFilePathException(String message) {
            super(message);
        }
    }

    /**
     * Signals that some error has occured while trying to convert and read/write data between the application
     * and the storage file.
     */
    public static class StorageOperationException extends Exception {
        public StorageOperationException(String message) {
            super(message);
        }
    }


}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.common;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * Utility methods
 */
public class Utils {

    /**
     * Returns true if any of the given items are null.
     */
    public static boolean isAnyNull(Object... items) {
        if (items == null) {
            return false;
        }
        for (Object item : items) {
            if (item == null) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if every element the given collection are unique by {@link Object#equals(Object)}.
     */
    public static boolean elementsAreUnique(Collection<?> items) {
        final Set<Object> testSet = new HashSet<>();
        for (Object item : items) {
            final boolean itemAlreadyExists = !testSet.add(item); // see Set documentation
            if (itemAlreadyExists) {
                return false;
            }
        }
        return true;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.common;

/**
 * Container for user visible messages.
 */
public class Messages {

    public static final String MESSAGE_GOODBYE = ""Good bye!"";
    public static final String MESSAGE_INIT_FAILED = ""Failed to initialise address book application. Exiting..."";
    public static final String MESSAGE_INVALID_COMMAND_FORMAT = ""Invalid command format! \n%1$s"";
    public static final String MESSAGE_INVALID_PERSON_DISPLAYED_INDEX = ""The person index provided is invalid"";
    public static final String MESSAGE_PERSON_NOT_IN_ADDRESSBOOK = ""Person could not be found in address book"";
    public static final String MESSAGE_PERSONS_LISTED_OVERVIEW = ""%1$d persons listed!"";
    public static final String MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE = ""Launch command format: ""
            + ""java seedu.addressbook.Main [STORAGE_FILE_PATH]"";
    public static final String MESSAGE_WELCOME = ""Welcome to your Address Book!"";
    public static final String MESSAGE_USING_STORAGE_FILE = ""Using storage file : %1$s"";
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows details of the person identified using the last displayed index.
 * Private contact details are not shown.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = ""view"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextHidePrivate()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;


/**
 * Deletes a person identified using it's last displayed index from the address book.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = ""delete"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Deletes the person identified by the index number used in the last person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_DELETE_PERSON_SUCCESS = ""Deleted Person: %1$s"";


    public DeleteCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            addressBook.removePerson(target);
            return new CommandResult(String.format(MESSAGE_DELETE_PERSON_SUCCESS, target));

        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        } catch (PersonNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
        }
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import java.util.List;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = ""list"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Displays all persons in the address book as a list with index numbers.\n""
            + ""Example: "" + COMMAND_WORD;


    @Override
    public CommandResult execute() {
        List<ReadOnlyPerson> allPersons = addressBook.getAllPersons().immutableListView();
        return new CommandResult(getMessageForPersonListShownSummary(allPersons), allPersons);
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows all details of the person identified using the last displayed index.
 * Private contact details are shown.
 */
public class ViewAllCommand extends Command {

    public static final String COMMAND_WORD = ""viewall"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewAllCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextShowAll()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

/**
 * Clears the address book.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = ""clear"";
    public static final String MESSAGE_USAGE = ""Clears address book permanently.\n""
            + ""Example: "" + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = ""Address book has been cleared!"";

    @Override
    public CommandResult execute() {
        addressBook.clear();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import static seedu.addressbook.ui.TextUi.DISPLAYED_INDEX_OFFSET;

import java.util.List;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Represents an executable command.
 */
public class Command {
    protected AddressBook addressBook;
    protected List<? extends ReadOnlyPerson> relevantPersons;
    private int targetIndex = -1;

    /**
     * @param targetIndex last visible listing index of the target person
     */
    public Command(int targetIndex) {
        this.setTargetIndex(targetIndex);
    }

    protected Command() {
    }

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of persons.
     *
     * @param personsDisplayed used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForPersonListShownSummary(List<? extends ReadOnlyPerson> personsDisplayed) {
        return String.format(Messages.MESSAGE_PERSONS_LISTED_OVERVIEW, personsDisplayed.size());
    }

    /**
     * Executes the command and returns the result.
     */
    public CommandResult execute() {
        throw new UnsupportedOperationException(""This method is to be implemented by child classes"");
    };

    /**
     * Supplies the data the command will operate on.
     */
    public void setData(AddressBook addressBook, List<? extends ReadOnlyPerson> relevantPersons) {
        this.addressBook = addressBook;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Extracts the the target person in the last shown list from the given arguments.
     *
     * @throws IndexOutOfBoundsException if the target index is out of bounds of the last viewed listing
     */
    protected ReadOnlyPerson getTargetPerson() throws IndexOutOfBoundsException {
        return relevantPersons.get(getTargetIndex() - DISPLAYED_INDEX_OFFSET);
    }

    public int getTargetIndex() {
        return targetIndex;
    }

    public void setTargetIndex(int targetIndex) {
        this.targetIndex = targetIndex;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;

/**
 * Adds a person to the address book.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = ""add"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Adds a person to the address book. ""
            + ""Contact details can be marked private by prepending 'p' to the prefix.\n""
            + ""Parameters: NAME [p]p/PHONE [p]e/EMAIL [p]a/ADDRESS  [t/TAG]...\n""
            + ""Example: "" + COMMAND_WORD
            + "" John Doe p/98765432 e/johnd@gmail.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney"";

    public static final String MESSAGE_SUCCESS = ""New person added: %1$s"";
    public static final String MESSAGE_DUPLICATE_PERSON = ""This person already exists in the address book"";

    private final Person toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name,
                      String phone, boolean isPhonePrivate,
                      String email, boolean isEmailPrivate,
                      String address, boolean isAddressPrivate,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Person(
                new Name(name),
                new Phone(phone, isPhonePrivate),
                new Email(email, isEmailPrivate),
                new Address(address, isAddressPrivate),
                tagSet
        );
    }

    public AddCommand(Person toAdd) {
        this.toAdd = toAdd;
    }

    public ReadOnlyPerson getPerson() {
        return toAdd;
    }

    @Override
    public CommandResult execute() {
        try {
            addressBook.addPerson(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniquePersonList.DuplicatePersonException dpe) {
            return new CommandResult(MESSAGE_DUPLICATE_PERSON);
        }
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;


/**
 * Shows help instructions.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = ""help"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Shows program usage instructions.\n""
            + ""Example: "" + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        return new CommandResult(
                AddCommand.MESSAGE_USAGE
                + ""\n"" + DeleteCommand.MESSAGE_USAGE
                + ""\n"" + ClearCommand.MESSAGE_USAGE
                + ""\n"" + FindCommand.MESSAGE_USAGE
                + ""\n"" + ListCommand.MESSAGE_USAGE
                + ""\n"" + ViewCommand.MESSAGE_USAGE
                + ""\n"" + ViewAllCommand.MESSAGE_USAGE
                + ""\n"" + HelpCommand.MESSAGE_USAGE
                + ""\n"" + ExitCommand.MESSAGE_USAGE
        );
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;


/**
 * Represents an incorrect command. Upon execution, produces some feedback to the user.
 */
public class IncorrectCommand extends Command {

    public final String feedbackToUser;

    public IncorrectCommand(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
    }

    @Override
    public CommandResult execute() {
        return new CommandResult(feedbackToUser);
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Finds and lists all persons in address book whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = ""find"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Finds all persons whose names contain any of ""
            + ""the specified keywords (case-sensitive) and displays them as a list with index numbers.\n""
            + ""Parameters: KEYWORD [MORE_KEYWORDS]...\n""
            + ""Example: "" + COMMAND_WORD + "" alice bob charlie"";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    /**
     * Returns a copy of keywords in this command.
     */
    public Set<String> getKeywords() {
        return new HashSet<>(keywords);
    }

    @Override
    public CommandResult execute() {
        final List<ReadOnlyPerson> personsFound = getPersonsWithNameContainingAnyKeyword(keywords);
        return new CommandResult(getMessageForPersonListShownSummary(personsFound), personsFound);
    }

    /**
     * Retrieves all persons in the address book whose names contain some of the specified keywords.
     *
     * @param keywords for searching
     * @return list of persons found
     */
    private List<ReadOnlyPerson> getPersonsWithNameContainingAnyKeyword(Set<String> keywords) {
        final List<ReadOnlyPerson> matchedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : addressBook.getAllPersons()) {
            final Set<String> wordsInName = new HashSet<>(person.getName().getWordsInName());
            if (!Collections.disjoint(wordsInName, keywords)) {
                matchedPersons.add(person);
            }
        }
        return matchedPersons;
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = ""exit"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Exits the program.\n""
            + ""Example: "" + COMMAND_WORD;
    public static final String MESSAGE_EXIT_ACKNOWEDGEMENT = ""Exiting Address Book as requested ..."";

    @Override
    public CommandResult execute() {
        return new CommandResult(MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    public static boolean isExit(Command command) {
        return command instanceof ExitCommand; // instanceof returns false if it is null
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.commands;

import java.util.List;
import java.util.Optional;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Represents the result of a command execution.
 */
public class CommandResult {

    /** The feedback message to be shown to the user. Contains a description of the execution result */
    public final String feedbackToUser;

    /** The list of persons that was produced by the command */
    private final List<? extends ReadOnlyPerson> relevantPersons;

    public CommandResult(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
        relevantPersons = null;
    }

    public CommandResult(String feedbackToUser, List<? extends ReadOnlyPerson> relevantPersons) {
        this.feedbackToUser = feedbackToUser;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Returns a list of persons relevant to the command command result, if any.
     */
    public Optional<List<? extends ReadOnlyPerson>> getRelevantPersons() {
        return Optional.ofNullable(relevantPersons);
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data;

import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;

/**
 * Represents the entire address book. Contains the data of the address book.
 */
public class AddressBook {

    private final UniquePersonList allPersons;

    /**
     * Creates an empty address book.
     */
    public AddressBook() {
        allPersons = new UniquePersonList();
    }

    /**
     * Constructs an address book with the given data.
     *
     * @param persons external changes to this will not affect this address book
     */
    public AddressBook(UniquePersonList persons) {
        this.allPersons = new UniquePersonList(persons);
    }

    /**
     * Adds a person to the address book.
     *
     * @throws DuplicatePersonException if an equivalent person already exists.
     */
    public void addPerson(Person toAdd) throws DuplicatePersonException {
        allPersons.add(toAdd);
    }

    /**
     * Returns true if an equivalent person exists in the address book.
     */
    public boolean containsPerson(ReadOnlyPerson key) {
        return allPersons.contains(key);
    }

    /**
     * Removes the equivalent person from the address book.
     *
     * @throws PersonNotFoundException if no such Person could be found.
     */
    public void removePerson(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        allPersons.remove(toRemove);
    }

    /**
     * Clears all persons and tags from the address book.
     */
    public void clear() {
        allPersons.clear();
    }

    /**
     * Returns a new UniquePersonList of all persons in the address book at the time of the call.
     */
    public UniquePersonList getAllPersons() {
        return new UniquePersonList(allPersons);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddressBook // instanceof handles nulls
                        && this.allPersons.equals(((AddressBook) other).allPersons));
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's phone number in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidPhone(String)}
 */
public class Phone {

    public static final String EXAMPLE = ""123456789"";
    public static final String MESSAGE_PHONE_CONSTRAINTS = ""Person phone numbers should only contain numbers"";
    public static final String PHONE_VALIDATION_REGEX = ""\\d+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given phone number.
     *
     * @throws IllegalValueException if given phone string is invalid.
     */
    public Phone(String phone, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedPhone = phone.trim();
        if (!isValidPhone(trimmedPhone)) {
            throw new IllegalValueException(MESSAGE_PHONE_CONSTRAINTS);
        }
        this.value = trimmedPhone;
    }

    /**
     * Returns true if the given string is a valid person phone number.
     */
    public static boolean isValidPhone(String test) {
        return test.matches(PHONE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Phone // instanceof handles nulls
                && this.value.equals(((Phone) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's email in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidEmail(String)}
 */
public class Email {

    public static final String EXAMPLE = ""valid@e.mail"";
    public static final String MESSAGE_EMAIL_CONSTRAINTS =
            ""Person emails should be 2 alphanumeric/period strings separated by '@'"";
    public static final String EMAIL_VALIDATION_REGEX = ""[\\w\\.]+@[\\w\\.]+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given email.
     *
     * @throws IllegalValueException if given email address string is invalid.
     */
    public Email(String email, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedEmail = email.trim();
        if (!isValidEmail(trimmedEmail)) {
            throw new IllegalValueException(MESSAGE_EMAIL_CONSTRAINTS);
        }
        this.value = trimmedEmail;
    }

    /**
     * Returns true if the given string is a valid person email.
     */
    public static boolean isValidEmail(String test) {
        return test.matches(EMAIL_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Email // instanceof handles nulls
                && this.value.equals(((Email) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }


    public boolean isPrivate() {
        return isPrivate;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.person;

import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * A read-only immutable interface for a Person in the addressbook.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyPerson {

    Name getName();
    Phone getPhone();
    Email getEmail();
    Address getAddress();

    /**
     * Returns a new TagSet that is a deep copy of the internal TagSet,
     * changes on the returned set will not affect the person's internal tags.
     */
    Set<Tag> getTags();

    /**
     * Returns true if both persons have the same identity fields (name and telephone).
     */
    default boolean isSamePerson(ReadOnlyPerson other) {
        return (other == this)
                || (other != null
                    && other.getName().equals(this.getName())
                    && other.getPhone().equals(this.getPhone()));
    }

    /**
     * Returns true if all data in this object is the same as that in another
     * (Note: interfaces cannot override .equals)
     */
    default boolean hasSameData(ReadOnlyPerson other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) // state checks here onwards
                    && other.getPhone().equals(this.getPhone())
                    && other.getEmail().equals(this.getEmail())
                    && other.getAddress().equals(this.getAddress())
                    && other.getTags().equals(this.getTags()));
    }

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsTextShowAll() {
        final StringBuilder builder = new StringBuilder();
        final String detailIsPrivate = ""(private) "";
        builder.append(getName())
                .append("" Phone: "");
        if (getPhone().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getPhone())
                .append("" Email: "");
        if (getEmail().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getEmail())
                .append("" Address: "");
        if (getAddress().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getAddress())
                .append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }

    /**
     * Formats a person as text, showing only non-private contact details.
     */
    default String getAsTextHidePrivate() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (!getPhone().isPrivate()) {
            builder.append("" Phone: "").append(getPhone());
        }
        if (!getEmail().isPrivate()) {
            builder.append("" Email: "").append(getEmail());
        }
        if (!getAddress().isPrivate()) {
            builder.append("" Address: "").append(getAddress());
        }
        builder.append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.person;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.common.Utils;
import seedu.addressbook.data.exception.DuplicateDataException;



/**
 * A list of persons. Does not allow null elements or duplicates.
 *
 * @see Person#equals(Object)
 * @see Utils#elementsAreUnique(Collection)
 */
public class UniquePersonList implements Iterable<Person> {



    private final List<Person> internalList = new ArrayList<>();

    /**
     * Constructs empty person list.
     */
    public UniquePersonList() {}

    /**
     * Constructs a person list with the given persons.
     */
    public UniquePersonList(Person... persons) throws DuplicatePersonException {
        final List<Person> initialTags = Arrays.asList(persons);
        if (!Utils.elementsAreUnique(initialTags)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(initialTags);
    }

    /**
     * Constructs a list from the items in the given collection.
     * @param persons a collection of persons
     * @throws DuplicatePersonException if the {@code persons} contains duplicate persons
     */
    public UniquePersonList(Collection<Person> persons) throws DuplicatePersonException {
        if (!Utils.elementsAreUnique(persons)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(persons);
    }

    /**
     * Constructs a shallow copy of the list.
     */
    public UniquePersonList(UniquePersonList source) {
        internalList.addAll(source.internalList);
    }

    /**
     * Returns an unmodifiable java List view with elements cast as immutable {@link ReadOnlyPerson}s.
     * For use with other methods/libraries.
     * Any changes to the internal list/elements are immediately visible in the returned list.
     */
    public List<ReadOnlyPerson> immutableListView() {
        return Collections.unmodifiableList(internalList);
    }


    /**
     * Checks if the list contains an equivalent person as the given argument.
     * The {@link ReadOnlyPerson#isSamePerson} method is used for this comparison, which
     * defines a weaker notion of equality.
     */
    public boolean contains(ReadOnlyPerson toCheck) {
        for (Person p : internalList) {
            if (p.isSamePerson(toCheck)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a person to the list.
     *
     * @throws DuplicatePersonException if the person to add is a duplicate of an existing person in the list.
     *    The @link{ReadOnlyPerson#isSamePerson} method is used for this comparison,
     *    which defines a weaker notion of equality.
     */
    public void add(Person toAdd) throws DuplicatePersonException {
        if (contains(toAdd)) {
            throw new DuplicatePersonException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent person from the list.
     *
     * @throws PersonNotFoundException if no such person could be found in the list.
     */
    public void remove(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        final boolean personFoundAndDeleted = internalList.remove(toRemove);
        if (!personFoundAndDeleted) {
            throw new PersonNotFoundException();
        }
    }

    /**
     * Clears all persons in list.
     */
    public void clear() {
        internalList.clear();
    }

    @Override
    public Iterator<Person> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniquePersonList // instanceof handles nulls
                        && this.internalList.equals(((UniquePersonList) other).internalList));
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicatePersonException extends DuplicateDataException {
        protected DuplicatePersonException() {
            super(""Operation would result in duplicate persons"");
        }
    }

    /**
     * Signals that an operation targeting a specified person in the list would fail because
     * there is no such matching person in the list.
     */
    public static class PersonNotFoundException extends Exception {}
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's address in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidAddress(String)}
 */
public class Address {

    public static final String EXAMPLE = ""123, some street"";
    public static final String MESSAGE_ADDRESS_CONSTRAINTS = ""Person addresses can be in any format"";
    public static final String ADDRESS_VALIDATION_REGEX = "".+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given address.
     *
     * @throws IllegalValueException if given address string is invalid.
     */
    public Address(String address, boolean isPrivate) throws IllegalValueException {
        String trimmedAddress = address.trim();
        this.isPrivate = isPrivate;
        if (!isValidAddress(trimmedAddress)) {
            throw new IllegalValueException(MESSAGE_ADDRESS_CONSTRAINTS);
        }
        this.value = trimmedAddress;
    }

    /**
     * Returns true if a given string is a valid person address.
     */
    public static boolean isValidAddress(String test) {
        return test.matches(ADDRESS_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Address // instanceof handles nulls
                && this.value.equals(((Address) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.person;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * Represents a Person in the address book.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Person implements ReadOnlyPerson {

    private Name name;
    private Phone phone;
    private Email email;
    private Address address;

    private final Set<Tag> tags = new HashSet<>();

    /**
     * Assumption: Every field must be present and not null.
     */
    public Person(Name name, Phone phone, Email email, Address address, Set<Tag> tags) {
        this.name = name;
        this.phone = phone;
        this.email = email;
        this.address = address;
        this.tags.addAll(tags);
    }

    /**
     * Copy constructor.
     */
    public Person(ReadOnlyPerson source) {
        this(source.getName(), source.getPhone(), source.getEmail(), source.getAddress(), source.getTags());
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public Phone getPhone() {
        return phone;
    }

    @Override
    public Email getEmail() {
        return email;
    }

    @Override
    public Address getAddress() {
        return address;
    }

    @Override
    public Set<Tag> getTags() {
        return new HashSet<>(tags);
    }

    /**
     * Replaces this person's tags with the tags in the argument tag set.
     */
    public void setTags(Set<Tag> replacement) {
        tags.clear();
        tags.addAll(replacement);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyPerson // instanceof handles nulls
                && this.hasSameData((ReadOnlyPerson) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, phone, email, address, tags);
    }

    @Override
    public String toString() {
        return getAsTextShowAll();
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.person;

import java.util.Arrays;
import java.util.List;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's name in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String EXAMPLE = ""John Doe"";
    public static final String MESSAGE_NAME_CONSTRAINTS = ""Person names should be spaces or alphabetic characters"";
    public static final String NAME_VALIDATION_REGEX = ""[\\p{Alpha} ]+"";
    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = trimmedName;
    }

    /**
     * Returns true if the given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }

    /**
     * Retrieves a listing of every word in the name, in order.
     */
    public List<String> getWordsInName() {
        return Arrays.asList(fullName.split(""\\s+""));
    }

    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.exception;

/**
 * Signals an error caused by duplicate data where there should be none.
 */
public abstract class DuplicateDataException extends IllegalValueException {
    public DuplicateDataException(String message) {
        super(message);
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.exception;

/**
 * Signals that some given data does not fulfill some constraints.
 */
public class IllegalValueException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public IllegalValueException(String message) {
        super(message);
    }
}
",1.66,2.24
sc1_v2,157fcf1,"package seedu.addressbook.data.tag;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Tag in the address book.
 * Guarantees: immutable; name is valid as declared in {@link #isValidTagName(String)}
 */
public class Tag {

    public static final String MESSAGE_TAG_CONSTRAINTS = ""Tags names should be alphanumeric"";
    public static final String TAG_VALIDATION_REGEX = ""\\p{Alnum}+"";

    public final String tagName;

    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid tag name.
     */
    public static boolean isValidTagName(String test) {
        return test.matches(TAG_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    @Override
    public String toString() {
        return '[' + tagName + ']';
    }

}
",1.66,2.24
sc1_v3,a66bc84,"package seedu.addressbook.util;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;

/**
 * Utility methods for testing.
 */
public class TestUtil {
    /**
     * Creates an address book containing the given persons.
     */
    public static AddressBook createAddressBook(Person... persons) {
        AddressBook addressBook = new AddressBook();

        for (Person person : persons) {
            try {
                addressBook.addPerson(person);
            } catch (DuplicatePersonException e) {
                throw new AssertionError(e);
            }
        }

        return addressBook;
    }

    /**
     * Creates a list of persons.
     */
    public static List<ReadOnlyPerson> createList(Person...persons) {
        List<ReadOnlyPerson> list = new ArrayList<ReadOnlyPerson>();

        for (Person person : persons) {
            list.add(person);
        }

        return list;
    }

    /**
     * Creates a copy of the original address book with the same entries
     * of Persons and Tags. The Persons and Tags are not cloned.
     */
    public static AddressBook clone(AddressBook addressBook) {
        return new AddressBook(addressBook.getAllPersons());
    }

    /**
     * Returns true if every pair of corresponding elements two iterables are (deeply) identical.
     * In other words, the two containers must have the same elements, in the same order.
     */
    public static <T> boolean isIdentical(Iterable<T> firstIterable, Iterable<T> secondIterable) {
        Iterator<T> currentPtr0 = firstIterable.iterator();
        Iterator<T> currentPtr1 = secondIterable.iterator();

        while (currentPtr0.hasNext() && currentPtr1.hasNext()) {
            T val0 = currentPtr0.next();
            T val1 = currentPtr1.next();

            if (!val0.equals(val1)) {
                return false;
            }
        }

        // If any of the two iterables still have elements, then they have different sizes.
        return !(currentPtr0.hasNext() || currentPtr1.hasNext());
    }

    /**
     * Returns true if the underlying container behind an iterable is empty.
     */
    public static <T> boolean isEmpty(Iterable<T> it) {
        return !it.iterator().hasNext();
    }

    /**
     * Returns the number of elements in the container behind an iterable.
     */
    public static <T> int getSize(Iterable<T> it) {
        int numberOfElementsSeen = 0;

        for (T elem : it) {
            numberOfElementsSeen++;
        }

        return numberOfElementsSeen;
    }

    /**
     * Generates an instance of a {@code Person} from valid test data.
     * @return an instance of a {@code Person}.
     */
    public static Person generateTestPerson() {
        try {
            return new Person(new Name(Name.EXAMPLE), new Phone(Phone.EXAMPLE, false),
                    new Email(Email.EXAMPLE, true), new Address(Address.EXAMPLE, false), Collections.emptySet());
        } catch (IllegalValueException e) {
            fail(""test person data should be valid by definition"");
            return null;
        }
    }

    /**
     * Asserts whether the text in the two given files are the same. Ignores any
     * differences in line endings
     */
    public static void assertTextFilesEqual(Path path1, Path path2) throws IOException {
        List<String> list1 = Files.readAllLines(path1, Charset.defaultCharset());
        List<String> list2 = Files.readAllLines(path2, Charset.defaultCharset());
        assertEquals(String.join(""\n"", list1), String.join(""\n"", list2));
    }

    /**
     * Asserts that the file given does not exist on the filesystem.
     */
    public static void assertFileDoesNotExist(String filePath) {
        assertTrue(Files.notExists(Paths.get(filePath)));
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.util;

import java.util.Collections;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;

/**
 * Class to generate typical test persons
 */
public class TypicalPersons {

    private Person amy;
    private Person bill;
    private Person candy;
    private Person dan;

    public TypicalPersons() {
        try {
            amy = new Person(new Name(""Amy Buck""), new Phone(""91119111"", false), new Email(""ab@gmail.com"", false),
                    new Address(""1 Clementi Road"", false), Collections.emptySet());
            bill = new Person(new Name(""Bill Clint""), new Phone(""92229222"", false), new Email(""bc@gmail.com"", false),
                    new Address(""2 Clementi Road"", true), Collections.emptySet());
            candy = new Person(new Name(""Candy Destiny""), new Phone(""93339333"", true),
                    new Email(""cd@gmail.com"", false), new Address(""3 Clementi Road"", true), Collections.emptySet());
            dan = new Person(new Name(""Dan Smith""), new Phone(""1234556"", true), new Email(""ss@tt.com"", true),
                    new Address(""NUS"", true), Collections.singleton(new Tag(""test"")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : ""not possible"";
        }
    }

    /**
     * Inserts predefined {@code Person} objects into a given instance of {@code AddressBook}
     * @param ab AddressBook in which {@code Person} objects will be added.
     */
    private void loadAddressBookWithSampleData(AddressBook ab) {
        try {
            for (Person p : this.getTypicalPersons()) {
                ab.addPerson(new Person(p));
            }
        } catch (IllegalValueException e) {
            assert false : ""not possible"";
        }
    }

    public Person[] getTypicalPersons() {
        return new Person[]{amy, bill, candy, dan};
    }

    public AddressBook getTypicalAddressBook() {
        AddressBook ab = new AddressBook();
        loadAddressBookWithSampleData(ab);
        return ab;
    }

    public Person getAmy() {
        return amy;
    }

    public Person getBill() {
        return bill;
    }

    public Person getCandy() {
        return candy;
    }

    public Person getDan() {
        return dan;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.parser;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.tag.Tag;

public class ParserTest {

    private Parser parser;

    @BeforeEach
    public void setUp() {
        parser = new Parser();
    }

    /*
     * Note how the names of the test methods does not follow the normal naming convention.
     * That is because our coding standard allows a different naming convention for test methods.
     */

    @Test
    public void parse_emptyInput_returnsIncorrect() {
        final String[] emptyInputs = { """", ""  "", ""\n  \n"" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, emptyInputs);
    }

    @Test
    public void parse_unknownCommandWord_returnsHelp() {
        final String input = ""unknowncommandword arguments arguments"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    /*
     * Tests for 0-argument commands =======================================================================
     */

    @Test
    public void parse_helpCommand_parsedCorrectly() {
        final String input = ""help"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    @Test
    public void parse_clearCommand_parsedCorrectly() {
        final String input = ""clear"";
        parseAndAssertCommandType(input, ClearCommand.class);
    }

    @Test
    public void parse_listCommand_parsedCorrectly() {
        final String input = ""list"";
        parseAndAssertCommandType(input, ListCommand.class);
    }

    @Test
    public void parse_exitCommand_parsedCorrectly() {
        final String input = ""exit"";
        parseAndAssertCommandType(input, ExitCommand.class);
    }

    /*
     * Tests for single index argument commands ===============================================================
     */

    @Test
    public void parse_deleteCommandNoArgs_errorMessage() {
        final String[] inputs = { ""delete"", ""delete "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""delete notAnumber "", ""delete 8*wh12"", ""delete 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 1;
        final String input = ""delete "" + testIndex;
        final DeleteCommand result = parseAndAssertCommandType(input, DeleteCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void viewCommandNoArgs_errorMessage() {
        final String[] inputs = { ""view"", ""view "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""view notAnumber "", ""view 8*wh12"", ""view 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 2;
        final String input = ""view "" + testIndex;
        final ViewCommand result = parseAndAssertCommandType(input, ViewCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void parse_viewAllCommandNoArgs_errorMessage() {
        final String[] inputs = { ""viewall"", ""viewall "" };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewAllCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""viewall notAnumber "", ""viewall 8*wh12"", ""viewall 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 3;
        final String input = ""viewall "" + testIndex;
        final ViewAllCommand result = parseAndAssertCommandType(input, ViewAllCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    /*
     * Tests for find persons by keyword in name command ===================================================
     */

    @Test
    public void parse_findCommandInvalidArgs_errorMessage() {
        // no keywords
        final String[] inputs = {
            ""find"",
            ""find ""
        };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_findCommandValidArgs_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        final String input = ""find "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    @Test
    public void parse_findCommandDuplicateKeys_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        // duplicate every keyword
        final String input = ""find "" + String.join("" "", keySet) + "" "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    /*
     * Tests for add person command ==============================================================================
     */

    @Test
    public void parse_addCommandInvalidArgs_errorMessage() {
        final String[] inputs = {
            ""add"",
            ""add "",
            ""add wrong args format"",
            // no phone prefix
            String.format(""add %s %s e/%s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no email prefix
            String.format(""add %s p/%s %s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no address prefix
            String.format(""add %s p/%s e/%s %s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE)
        };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_addCommandInvalidPersonDataInArgs_errorMessge() {
        final String invalidName = ""[]\\[;]"";
        final String validName = Name.EXAMPLE;
        final String invalidPhoneArg = ""p/not__numbers"";
        final String validPhoneArg = ""p/"" + Phone.EXAMPLE;
        final String invalidEmailArg = ""e/notAnEmail123"";
        final String validEmailArg = ""e/"" + Email.EXAMPLE;
        final String invalidTagArg = ""t/invalid_-[.tag"";

        // address can be any string, so no invalid address
        final String addCommandFormatString = ""add %s %s %s a/"" + Address.EXAMPLE;

        // test each incorrect person data field argument individually
        final String[] inputs = {
                // invalid name
                String.format(addCommandFormatString, invalidName, validPhoneArg, validEmailArg),
                // invalid phone
                String.format(addCommandFormatString, validName, invalidPhoneArg, validEmailArg),
                // invalid email
                String.format(addCommandFormatString, validName, validPhoneArg, invalidEmailArg),
                // invalid tag
                String.format(addCommandFormatString, validName, validPhoneArg, validEmailArg) + "" "" + invalidTagArg
        };
        for (String input : inputs) {
            parseAndAssertCommandType(input, IncorrectCommand.class);
        }
    }

    @Test
    public void parse_addCommandValidPersonData_parsedCorrectly() {
        final Person testPerson = generateTestPerson();
        final String input = convertPersonToAddCommandString(testPerson);
        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    @Test
    public void parse_addCommandDuplicateTags_merged() {
        final Person testPerson = generateTestPerson();
        String input = convertPersonToAddCommandString(testPerson);
        for (Tag tag : testPerson.getTags()) {
            // create duplicates by doubling each tag
            input += "" t/"" + tag.tagName;
        }

        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    /**
     * Generates an instance of a {@code Person} from valid test data.
     * @return an instance of a {@code Person}.
     */
    private static Person generateTestPerson() {
        try {
            return new Person(
                new Name(Name.EXAMPLE),
                new Phone(Phone.EXAMPLE, true),
                new Email(Email.EXAMPLE, false),
                new Address(Address.EXAMPLE, true),
                new HashSet<>(Arrays.asList(new Tag(""tag1""), new Tag (""tag2""), new Tag(""tag3"")))
            );
        } catch (IllegalValueException ive) {
            throw new RuntimeException(""test person data should be valid by definition"");
        }
    }

    /**
     * Generates an add command from a {@code ReadOnlyPerson}.
     * @param person whose data will be filled into the string.
     * @return a string describing an {@code AddCommand}.
     */
    private static String convertPersonToAddCommandString(ReadOnlyPerson person) {
        String addCommand = ""add ""
                + person.getName().fullName
                + (person.getPhone().isPrivate() ? "" pp/"" : "" p/"") + person.getPhone().value
                + (person.getEmail().isPrivate() ? "" pe/"" : "" e/"") + person.getEmail().value
                + (person.getAddress().isPrivate() ? "" pa/"" : "" a/"") + person.getAddress().value;
        for (Tag tag : person.getTags()) {
            addCommand += "" t/"" + tag.tagName;
        }
        return addCommand;
    }

    /*
     * Utility methods ====================================================================================
     */

    /**
     * Asserts that parsing the given inputs will return IncorrectCommand with the given feedback message.
     */
    private void parseAndAssertIncorrectWithMessage(String feedbackMessage, String... inputs) {
        for (String input : inputs) {
            final IncorrectCommand result = parseAndAssertCommandType(input, IncorrectCommand.class);
            assertEquals(result.feedbackToUser, feedbackMessage);
        }
    }

    /**
     * Parses input and asserts the class/type of the returned command object.
     *
     * @param input to be parsed
     * @param expectedCommandClass expected class of returned command
     * @return the parsed command object
     */
    private <T extends Command> T parseAndAssertCommandType(String input, Class<T> expectedCommandClass) {
        final Command result = parser.parseCommand(input);
        assertTrue(result.getClass().isAssignableFrom(expectedCommandClass));
        return (T) result;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.storage;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static seedu.addressbook.util.TestUtil.assertFileDoesNotExist;
import static seedu.addressbook.util.TestUtil.assertTextFilesEqual;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

public class StorageFileTest {
    @TempDir
    public static Path testFolder;

    private static final String TEST_DATA_FOLDER = ""test/data/StorageFileTest"";
    private static final String NON_EXISTANT_FILE_NAME = ""ThisFileDoesNotExist.txt"";

    @Test
    public void constructor_nullFilePath_exceptionThrown() throws Exception {
        assertThrows(NullPointerException.class, () -> new StorageFile(null));
    }

    @Test
    public void constructor_noTxtExtension_exceptionThrown() throws Exception {
        assertThrows(IllegalValueException.class, () ->
                new StorageFile(TEST_DATA_FOLDER + ""/"" + ""InvalidfileName""));
    }

    @Test
    public void load_invalidFormat_exceptionThrown() throws Exception {
        // The file contains valid txt data, but does not match the Person format
        StorageFile storage = getStorage(""InvalidData.txt"");
        assertThrows(StorageOperationException.class, () -> storage.load());
    }

    @Test
    public void load_validFormat() throws Exception {
        AddressBook actualAb = getStorage(""ValidData.txt"").load();
        AddressBook expectedAb = getTestAddressBook();

        // ensure loaded AddressBook is properly constructed with test data
        // TODO: overwrite equals method in AddressBook class and replace with equals method below
        assertEquals(actualAb.getAllPersons(), expectedAb.getAllPersons());
    }

    @Test
    public void load_nonExistantFile_returnsEmptyAddressBook() throws Exception {
        AddressBook actualAb = getStorage(NON_EXISTANT_FILE_NAME).load();
        AddressBook expectedAb = new AddressBook();

        assertEquals(actualAb, expectedAb);

        // verify that loading does not result in the file being created
        assertFileDoesNotExist(TEST_DATA_FOLDER + ""/"" + NON_EXISTANT_FILE_NAME);
    }

    @Test
    public void save_nullAddressBook_exceptionThrown() throws Exception {
        StorageFile storage = getTempStorage();
        assertThrows(NullPointerException.class, () -> storage.save(null));
    }

    @Test
    public void save_validAddressBook() throws Exception {
        AddressBook ab = getTestAddressBook();
        StorageFile storage = getTempStorage();
        storage.save(ab);

        assertStorageFilesEqual(storage, getStorage(""ValidData.txt""));
    }

    // getPath() method in StorageFile class is trivial so it is not tested

    /**
     * Asserts that the contents of two storage files are the same.
     */
    private void assertStorageFilesEqual(StorageFile sf1, StorageFile sf2) throws Exception {
        assertTextFilesEqual(Paths.get(sf1.getPath()), Paths.get(sf2.getPath()));
    }

    private StorageFile getStorage(String fileName) throws Exception {
        return new StorageFile(TEST_DATA_FOLDER + ""/"" + fileName);
    }

    private StorageFile getTempStorage() throws Exception {
        return new StorageFile(testFolder.resolve(""temp.txt"").toString());
    }

    private AddressBook getTestAddressBook() throws Exception {
        AddressBook ab = new AddressBook();
        ab.addPerson(new Person(new Name(""John Doe""),
                                new Phone(""98765432"", false),
                                new Email(""johnd@gmail.com"", false),
                                new Address(""John street, block 123, #01-01"", false),
                                Collections.emptySet()));
        ab.addPerson(new Person(new Name(""Betsy Crowe""),
                                new Phone(""1234567"", true),
                                new Email(""betsycrowe@gmail.com"", false),
                                new Address(""Newgate Prison"", true),
                                new HashSet<>(Arrays.asList(new Tag(""friend""), new Tag(""criminal"")))));
        return ab;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.common;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.Arrays;

import org.junit.jupiter.api.Test;

public class UtilsTest {


    @Test
    public void elementsAreUnique() throws Exception {
        // empty list
        assertAreUnique();

        // only one object
        assertAreUnique((Object) null);
        assertAreUnique(1);
        assertAreUnique("""");
        assertAreUnique(""abc"");

        // all objects unique
        assertAreUnique(""abc"", ""ab"", ""a"");
        assertAreUnique(1, 2);

        // some identical objects
        assertNotUnique(""abc"", ""abc"");
        assertNotUnique(""abc"", """", ""abc"", ""ABC"");
        assertNotUnique("""", ""abc"", ""a"", ""abc"");
        assertNotUnique(1, Integer.valueOf(1));
        assertNotUnique(null, 1, Integer.valueOf(1));
        assertNotUnique(null, null);
        assertNotUnique(null, ""a"", ""b"", null);
    }

    @Test
    public void isAnyNull() {
        // no items
        assertFalse(Utils.isAnyNull());

        // varargs array that is null (i.e. no array)
        assertFalse(Utils.isAnyNull((Object[]) null));

        // one item which is null (i.e. an array with one null item)
        assertTrue(Utils.isAnyNull((Object) null));

        // at least one item, none of which are null
        assertFalse(Utils.isAnyNull(""A""));
        assertFalse(Utils.isAnyNull(""A"", """"));
        assertFalse(Utils.isAnyNull(1, 2, ""C""));

        // at least one item, some of which are null
        assertTrue(Utils.isAnyNull(null, 1));
        assertTrue(Utils.isAnyNull(""A"", null, ""C""));
    }

    private void assertAreUnique(Object... objects) {
        assertTrue(Utils.elementsAreUnique(Arrays.asList(objects)));
    }

    private void assertNotUnique(Object... objects) {
        assertFalse(Utils.elementsAreUnique(Arrays.asList(objects)));
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.ui.TextUi;
import seedu.addressbook.util.TestUtil;

public class DeleteCommandTest {

    private AddressBook emptyAddressBook;
    private AddressBook addressBook;

    private List<ReadOnlyPerson> emptyDisplayList;
    private List<ReadOnlyPerson> listWithEveryone;
    private List<ReadOnlyPerson> listWithSurnameDoe;

    @BeforeEach
    public void setUp() throws Exception {
        Person johnDoe = new Person(new Name(""John Doe""), new Phone(""61234567"", false),
                new Email(""john@doe.com"", false), new Address(""395C Ben Road"", false), Collections.emptySet());
        Person janeDoe = new Person(new Name(""Jane Doe""), new Phone(""91234567"", false),
                new Email(""jane@doe.com"", false), new Address(""33G Ohm Road"", false), Collections.emptySet());
        Person samDoe = new Person(new Name(""Sam Doe""), new Phone(""63345566"", false),
                new Email(""sam@doe.com"", false), new Address(""55G Abc Road"", false), Collections.emptySet());
        Person davidGrant = new Person(new Name(""David Grant""), new Phone(""61121122"", false),
                new Email(""david@grant.com"", false), new Address(""44H Define Road"", false),
                Collections.emptySet());

        emptyAddressBook = TestUtil.createAddressBook();
        addressBook = TestUtil.createAddressBook(johnDoe, janeDoe, davidGrant, samDoe);

        emptyDisplayList = TestUtil.createList();

        listWithEveryone = TestUtil.createList(johnDoe, janeDoe, davidGrant, samDoe);
        listWithSurnameDoe = TestUtil.createList(johnDoe, janeDoe, samDoe);
    }

    @Test
    public void execute_emptyAddressBook_returnsPersonNotFoundMessage() {
        assertDeletionFailsDueToNoSuchPerson(1, emptyAddressBook, listWithEveryone);
    }

    @Test
    public void execute_noPersonDisplayed_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(1, addressBook, emptyDisplayList);
    }

    @Test
    public void execute_targetPersonNotInAddressBook_returnsPersonNotFoundMessage()
            throws IllegalValueException {
        Person notInAddressBookPerson = new Person(new Name(""Not In Book""), new Phone(""63331444"", false),
                new Email(""notin@book.com"", false), new Address(""156D Grant Road"", false), Collections.emptySet());
        List<ReadOnlyPerson> listWithPersonNotInAddressBook = TestUtil.createList(notInAddressBookPerson);

        assertDeletionFailsDueToNoSuchPerson(1, addressBook, listWithPersonNotInAddressBook);
    }

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(0, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(-1, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(listWithEveryone.size() + 1, addressBook, listWithEveryone);
    }

    @Test
    public void execute_validIndex_personIsDeleted() throws PersonNotFoundException {
        assertDeletionSuccessful(1, addressBook, listWithSurnameDoe);
        assertDeletionSuccessful(listWithSurnameDoe.size(), addressBook, listWithSurnameDoe);

        int middleIndex = (listWithSurnameDoe.size() / 2) + 1;
        assertDeletionSuccessful(middleIndex, addressBook, listWithSurnameDoe);
    }

    /**
     * Creates a new delete command.
     *
     * @param targetVisibleIndex of the person that we want to delete
     */
    private DeleteCommand createDeleteCommand(int targetVisibleIndex, AddressBook addressBook,
                                                                      List<ReadOnlyPerson> displayList) {

        DeleteCommand command = new DeleteCommand(targetVisibleIndex);
        command.setData(addressBook, displayList);

        return command;
    }

    /**
     * Executes the command, and checks that the execution was what we had expected.
     */
    private void assertCommandBehaviour(DeleteCommand deleteCommand, String expectedMessage,
                                        AddressBook expectedAddressBook, AddressBook actualAddressBook) {

        CommandResult result = deleteCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedAddressBook.getAllPersons(), actualAddressBook.getAllPersons());
    }

    /**
     * Asserts that the index is not valid for the given display list.
     */
    private void assertDeletionFailsDueToInvalidIndex(int invalidVisibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

        DeleteCommand command = createDeleteCommand(invalidVisibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index cannot be deleted, because that person
     * is not in the address book.
     */
    private void assertDeletionFailsDueToNoSuchPerson(int visibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK;

        DeleteCommand command = createDeleteCommand(visibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index can be successfully deleted.
     *
     * The addressBook passed in will not be modified (no side effects).
     *
     * @throws PersonNotFoundException if the selected person is not in the address book
     */
    private void assertDeletionSuccessful(int targetVisibleIndex, AddressBook addressBook,
                                          List<ReadOnlyPerson> displayList) throws PersonNotFoundException {

        ReadOnlyPerson targetPerson = displayList.get(targetVisibleIndex - TextUi.DISPLAYED_INDEX_OFFSET);

        AddressBook expectedAddressBook = TestUtil.clone(addressBook);
        expectedAddressBook.removePerson(targetPerson);
        String expectedMessage = String.format(DeleteCommand.MESSAGE_DELETE_PERSON_SUCCESS, targetPerson);

        AddressBook actualAddressBook = TestUtil.clone(addressBook);

        DeleteCommand command = createDeleteCommand(targetVisibleIndex, actualAddressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, expectedAddressBook, actualAddressBook);
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

public class ViewAllCommandTest {
    // ViewAllCommand is tested together with ViewCommand in ViewCommandTest.
    // This is because they function similarly but ViewCommand hides private information.
    // They are tested with same test data input.
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TestUtil;
import seedu.addressbook.util.TypicalPersons;

public class ViewCommandTest {
    private TypicalPersons td = new TypicalPersons();

    private AddressBook typicalAddressBook = td.getTypicalAddressBook();
    private AddressBook emptyAddressBook = TestUtil.createAddressBook();
    private List<ReadOnlyPerson> emptyPersonList = Collections.emptyList();
    private List<ReadOnlyPerson> listWithAllTypicalPersons = Arrays.asList(td.getTypicalPersons());
    private List<ReadOnlyPerson> listWithSomeTypicalPersons = Arrays.asList(td.getAmy(), td.getCandy(), td.getDan());

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        // empty addressbook
        assertViewErrorInvalidIndex(emptyAddressBook, emptyPersonList, 1);

        // non-empty addressbook
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, -1);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, 0);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons,
                                              listWithAllTypicalPersons.size() + 1);
    }

    @Test
    public void execute_personNotInAddressBook_returnsPersonNotInAddressBookMessage() throws Exception {
        // generate list with person not in addressbook, add to list
        ReadOnlyPerson stranger = new Person(new Name(""me""),
                                             new Phone(""123"", true),
                                             new Email(""some@hey.go"", true),
                                             new Address(""nus"", false),
                                             Collections.emptySet());
        List<ReadOnlyPerson> listWithExtraPerson = new ArrayList<ReadOnlyPerson>(listWithAllTypicalPersons);
        listWithExtraPerson.add(stranger);

        // empty addressbook
        assertViewErrorPersonNotInAddressBook(emptyAddressBook, listWithExtraPerson, 1);

        // non-empty addressbook
        assertViewErrorPersonNotInAddressBook(typicalAddressBook, listWithExtraPerson,
                                                            listWithExtraPerson.size());
    }

    @Test
    public void execute_validIndex_returnsPersonDetails() {
        // person with no private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 1);

        // person with some private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 2);

        // person with all private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 4);

        // Addressbook has more people than the list.
        // This can happen when a command causes the list to show only a sub-set of persons(e.g. FindCommand).
        assertViewSuccess(typicalAddressBook, listWithSomeTypicalPersons, 1);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * invalid index.
     */
    private void assertViewErrorInvalidIndex(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                     int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                          Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * person not existing in the addressbook.
     */
    private void assertViewErrorPersonNotInAddressBook(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                               int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                               Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
    }

    /**
     * Asserts that both a ViewCommand and a ViewAllCommand can retrieve from
     * the {@code addressBook} details of the person at the given {@code targetVisibleIndex}
     * in the given {@code relevantPersons} list.
     *
     * @param targetVisibleIndex one-indexed position of the target person in the list
     */
    private void assertViewSuccess(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                           int targetVisibleIndex) {
        // get person to be viewed (targetVisibleIndex - 1 because index is one-indexed)
        ReadOnlyPerson personToBeViewed = relevantPersons.get(targetVisibleIndex - 1);

        String expectedMessage = String.format(ViewCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextHidePrivate());
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);

        expectedMessage = String.format(ViewAllCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextShowAll());
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Asserts that the Viewcommand and ViewAllcommand reports the given error for the given input.
     */
    private static void assertViewError(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                        int targetVisibleIndex, String expectedMessage) {
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Executes the test command for the given addressbook data.
     * Checks that ViewCommand and ViewAllCommand exhibits the correct command behavior, namely:
     * 1. The feedback message of the CommandResult it returns matches expectedMessage.
     * 2. The CommandResult it returns has no relevant persons.
     * 3. The original addressbook data is not modified after executing ViewCommand and ViewAllCommand.
     */
    private static void assertViewBehavior(Command viewCommand, AddressBook addressBook,
                                           List<ReadOnlyPerson> relevantPersons, String expectedMessage) {
        AddressBook expectedAddressBook = TestUtil.clone(addressBook);

        viewCommand.setData(addressBook, relevantPersons);
        CommandResult result = viewCommand.execute();

        // feedback message is as expected and there are no relevant persons returned.
        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(Optional.empty(), result.getRelevantPersons());

        // addressbook was not modified.
        assertEquals(expectedAddressBook.getAllPersons(), addressBook.getAllPersons());
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TypicalPersons;

public class FindCommandTest {

    private final AddressBook addressBook = new TypicalPersons().getTypicalAddressBook();
    private final TypicalPersons td = new TypicalPersons();

    @Test
    public void execute() throws IllegalValueException {
        //same word, same case: matched
        assertFindCommandBehavior(new String[]{""Amy""}, Arrays.asList(td.getAmy()));

        //same word, different case: not matched
        assertFindCommandBehavior(new String[]{""aMy""}, Collections.emptyList());

        //partial word: not matched
        assertFindCommandBehavior(new String[]{""my""}, Collections.emptyList());

        //multiple words: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Bill"", ""Candy"", ""Destiny""},
                Arrays.asList(td.getAmy(), td.getBill(), td.getCandy()));

        //repeated keywords: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Amy""}, Arrays.asList(td.getAmy()));

        //Keyword matching a word in address: not matched
        assertFindCommandBehavior(new String[]{""Clementi""}, Collections.emptyList());
    }

    /**
     * Executes the find command for the given keywords and verifies
     * the result matches the persons in the expectedPersonList exactly.
     */
    private void assertFindCommandBehavior(String[] keywords, List<ReadOnlyPerson> expectedPersonList) {
        FindCommand command = createFindCommand(keywords);
        CommandResult result = command.execute();

        assertEquals(Command.getMessageForPersonListShownSummary(expectedPersonList), result.feedbackToUser);
    }

    /**
     * Factory method that creates and returns a {@code FindCommand}.
     * @param keywords list of keywords to search for.
     * @return an instance of {@FindCommand} that searches the test AddressBook.
     */
    private FindCommand createFindCommand(String[] keywords) {
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        FindCommand command = new FindCommand(keywordSet);
        command.setData(addressBook, Collections.emptyList());
        return command;
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.util.TestUtil;

public class AddCommandTest {
    private static final List<ReadOnlyPerson> EMPTY_PERSON_LIST = Collections.emptyList();
    private static final Set<String> EMPTY_STRING_SET = Collections.emptySet();

    @Test
    public void addCommand_invalidName_throwsException() {
        final String[] invalidNames = { """", "" "", ""[]\\[;]"" };
        for (String name : invalidNames) {
            assertConstructingInvalidAddCmdThrowsException(name, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                    Address.EXAMPLE, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidPhone_throwsException() {
        final String[] invalidNumbers = { """", "" "", ""1234-5678"", ""[]\\[;]"", ""abc"", ""a123"", ""+651234"" };
        for (String number : invalidNumbers) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, number, false, Email.EXAMPLE, true,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidEmail_throwsException() {
        final String[] invalidEmails = { """", "" "", ""def.com"", ""@"", ""@def"", ""@def.com"", ""abc@"",
                                         ""@invalid@email"", ""invalid@email!"", ""!invalid@email"" };
        for (String email : invalidEmails) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, false, email, false,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidAddress_throwsException() {
        final String[] invalidAddresses = { """", "" "" };
        for (String address : invalidAddresses) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, address, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidTags_throwsException() {
        final String[][] invalidTags = { { """" }, { "" "" }, { ""'"" }, { ""[]\\[;]"" }, { ""validTag"", """" },
                                         { """", "" "" } };
        for (String[] tags : invalidTags) {
            Set<String> tagsToAdd = new HashSet<>(Arrays.asList(tags));
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, Address.EXAMPLE, false, tagsToAdd);
        }
    }

    /**
     * Asserts that attempting to construct an add command with the supplied
     * invalid data throws an IllegalValueException
     */
    private void assertConstructingInvalidAddCmdThrowsException(String name, String phone,
            boolean isPhonePrivate, String email, boolean isEmailPrivate, String address,
            boolean isAddressPrivate, Set<String> tags) {
        try {
            new AddCommand(name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate,
                    tags);
        } catch (IllegalValueException e) {
            return;
        }
        String error = String.format(
                ""An add command was successfully constructed with invalid input: %s %s %s %s %s %s %s %s"",
                name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate, tags);
        fail(error);
    }

    @Test
    public void addCommand_validData_correctlyConstructed() throws Exception {
        AddCommand command = new AddCommand(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                Address.EXAMPLE, true, EMPTY_STRING_SET);
        ReadOnlyPerson p = command.getPerson();

        // TODO: add comparison of tags to person.equals and equality methods to
        // individual fields that compare privacy to simplify this
        assertEquals(Name.EXAMPLE, p.getName().fullName);
        assertEquals(Phone.EXAMPLE, p.getPhone().value);
        assertTrue(p.getPhone().isPrivate());
        assertEquals(Email.EXAMPLE, p.getEmail().value);
        assertFalse(p.getEmail().isPrivate());
        assertEquals(Address.EXAMPLE, p.getAddress().value);
        assertTrue(p.getAddress().isPrivate());
        boolean isTagListEmpty = !p.getTags().iterator().hasNext();
        assertTrue(isTagListEmpty);
    }

    @Test
    public void addCommand_emptyAddressBook_addressBookContainsPerson() {
        Person p = TestUtil.generateTestPerson();
        AddCommand command = new AddCommand(p);
        AddressBook book = new AddressBook();
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();
        UniquePersonList people = book.getAllPersons();

        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS, p), result.feedbackToUser);
    }

    @Test
    public void addCommand_addressBookAlreadyContainsPerson_addressBookUnmodified() throws Exception {
        Person p = TestUtil.generateTestPerson();
        AddressBook book = new AddressBook();
        book.addPerson(p);
        AddCommand command = new AddCommand(p);
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();

        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(AddCommand.MESSAGE_DUPLICATE_PERSON, result.feedbackToUser);
        UniquePersonList people = book.getAllPersons();
        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static seedu.addressbook.util.TestUtil.getSize;
import static seedu.addressbook.util.TestUtil.isEmpty;
import static seedu.addressbook.util.TestUtil.isIdentical;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.data.tag.Tag;

public class AddressBookTest {

    private Tag tagPrizeWinner;
    private Tag tagScientist;
    private Tag tagMathematician;
    private Tag tagEconomist;

    private Person aliceBetsy;
    private Person bobChaplin;
    private Person charlieDouglas;
    private Person davidElliot;

    private AddressBook defaultAddressBook;
    private AddressBook emptyAddressBook;


    @BeforeEach
    public void setUp() throws Exception {
        tagPrizeWinner = new Tag(""prizewinner"");
        tagScientist = new Tag(""scientist"");
        tagMathematician = new Tag(""mathematician"");
        tagEconomist = new Tag(""economist"");

        aliceBetsy = new Person(new Name(""Alice Betsy""),
                                new Phone(""91235468"", false),
                                new Email(""alice@nushackers.org"", false),
                                new Address(""8 Computing Drive, Singapore"", false),
                                Collections.singleton(tagMathematician));

        bobChaplin = new Person(new Name(""Bob Chaplin""),
                                new Phone(""94321500"", false),
                                new Email(""bob@nusgreyhats.org"", false),
                                new Address(""9 Computing Drive"", false),
                                Collections.singleton(tagMathematician));

        charlieDouglas = new Person(new Name(""Charlie Douglas""),
                                    new Phone(""98751365"", false),
                                    new Email(""charlie@nusgdg.org"", false),
                                    new Address(""10 Science Drive"", false),
                                    Collections.singleton(tagScientist));

        davidElliot = new Person(new Name(""David Elliot""),
                                 new Phone(""84512575"", false),
                                 new Email(""douglas@nuscomputing.com"", false),
                                 new Address(""11 Arts Link"", false),
                                 new HashSet<>(Arrays.asList(tagEconomist, tagPrizeWinner)));

        emptyAddressBook = new AddressBook();
        defaultAddressBook = new AddressBook(new UniquePersonList(aliceBetsy, bobChaplin));
    }

    @Test
    public void addPerson_personAlreadyInList_throwsDuplicatePersonException() {
        assertThrows(DuplicatePersonException.class, () -> defaultAddressBook.addPerson(aliceBetsy));
    }

    @Test
    public void containsPerson() throws Exception {
        UniquePersonList personsWhoShouldBeIn = new UniquePersonList(aliceBetsy, bobChaplin);
        UniquePersonList personsWhoShouldNotBeIn = new UniquePersonList(charlieDouglas, davidElliot);

        for (Person personWhoShouldBeIn : personsWhoShouldBeIn) {
            assertTrue(defaultAddressBook.containsPerson(personWhoShouldBeIn));
        }
        for (Person personWhoShouldNotBeIn : personsWhoShouldNotBeIn) {
            assertFalse(defaultAddressBook.containsPerson(personWhoShouldNotBeIn));
        }

        UniquePersonList allPersons = new UniquePersonList(aliceBetsy, bobChaplin, charlieDouglas, davidElliot);

        for (Person person : allPersons) {
            assertFalse(emptyAddressBook.containsPerson(person));
        }
    }

    @Test
    public void removePerson_personExists_removesNormally() throws Exception {
        int numberOfPersonsBeforeRemoval = getSize(defaultAddressBook.getAllPersons());
        defaultAddressBook.removePerson(aliceBetsy);

        assertFalse(defaultAddressBook.containsPerson(aliceBetsy));

        int numberOfPersonsAfterRemoval = getSize(defaultAddressBook.getAllPersons());
        assertTrue(numberOfPersonsAfterRemoval == numberOfPersonsBeforeRemoval - 1);

    }

    @Test
    public void removePerson_personNotExists_throwsPersonNotFoundException() {
        assertThrows(PersonNotFoundException.class, () -> defaultAddressBook.removePerson(charlieDouglas));
    }

    @Test
    public void clear() {
        defaultAddressBook.clear();

        assertTrue(isEmpty(defaultAddressBook.getAllPersons()));
    }

    @Test
    public void getAllPersons() throws Exception {
        UniquePersonList allPersons = defaultAddressBook.getAllPersons();
        UniquePersonList personsToCheck = new UniquePersonList(aliceBetsy, bobChaplin);

        assertTrue(isIdentical(allPersons, personsToCheck));
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.parser.Parser;
import seedu.addressbook.storage.StorageFile;
import seedu.addressbook.storage.StorageFile.InvalidStorageFilePathException;
import seedu.addressbook.storage.StorageFile.StorageOperationException;
import seedu.addressbook.ui.TextUi;


/**
 * Entry point of the Address Book application.
 * Initializes the application and starts the interaction with the user.
 */
public class Main {

    /** Version info of the program. */
    public static final String VERSION = ""AddressBook Level 2 - Version 1.0"";

    private TextUi ui;
    private StorageFile storage;
    private AddressBook addressBook;

    /** The list of person shown to the user most recently.  */
    private List<? extends ReadOnlyPerson> lastShownList = Collections.emptyList();


    public static void main(String... launchArgs) {
        new Main().run(launchArgs);
    }

    /** Runs the program until termination.  */
    public void run(String[] launchArgs) {
        start(launchArgs);
        runCommandLoopUntilExitCommand();
        exit();
    }

    /**
     * Sets up the required objects, loads up the data from the storage file, and prints the welcome message.
     *
     * @param launchArgs arguments supplied by the user at program launch
     *
     */
    private void start(String[] launchArgs) {
        try {
            this.ui = new TextUi();
            this.storage = initializeStorage(launchArgs);
            this.addressBook = storage.load();
            ui.showWelcomeMessage(VERSION, storage.getPath());

        } catch (InvalidStorageFilePathException | StorageOperationException e) {
            ui.showInitFailedMessage();
            /*
             * ==============NOTE TO STUDENTS=========================================================================
             * We are throwing a RuntimeException which is an 'unchecked' exception. Unchecked exceptions do not need
             * to be declared in the method signature.
             * The reason we are using an unchecked exception here is because the caller cannot reasonably be expected
             * to recover from an exception.
             * Cf https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html
             * =======================================================================================================
             */
            throw new RuntimeException(e);
        }
    }

    /** Prints the Goodbye message and exits. */
    private void exit() {
        ui.showGoodbyeMessage();
        System.exit(0);
    }

    /** Reads the user command and executes it, until the user issues the exit command.  */
    private void runCommandLoopUntilExitCommand() {
        Command command;
        do {
            String userCommandText = ui.getUserCommand();
            command = new Parser().parseCommand(userCommandText);
            CommandResult result = executeCommand(command);
            recordResult(result);
            ui.showResultToUser(result);

        } while (!ExitCommand.isExit(command));
    }

    /** Updates the {@link #lastShownList} if the result contains a list of Persons. */
    private void recordResult(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> personList = result.getRelevantPersons();
        if (personList.isPresent()) {
            lastShownList = personList.get();
        }
    }

    /**
     * Executes the command and returns the result.
     *
     * @param command user command
     * @return result of the command
     */
    private CommandResult executeCommand(Command command) {
        try {
            command.setData(addressBook, lastShownList);
            CommandResult result = command.execute();
            storage.save(addressBook);
            return result;
        } catch (Exception e) {
            ui.showToUser(e.getMessage());
            throw new RuntimeException(e);
        }
    }

    /**
     * Creates the StorageFile object based on the user specified path (if any) or the default storage path.
     * @param launchArgs arguments supplied by the user at program launch
     * @throws InvalidStorageFilePathException if the target file path is incorrect.
     */
    private StorageFile initializeStorage(String[] launchArgs) throws InvalidStorageFilePathException {
        boolean isStorageFileSpecifiedByUser = launchArgs.length > 0;
        return isStorageFileSpecifiedByUser ? new StorageFile(launchArgs[0]) : new StorageFile();
    }


}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.ui;

import static seedu.addressbook.common.Messages.MESSAGE_GOODBYE;
import static seedu.addressbook.common.Messages.MESSAGE_INIT_FAILED;
import static seedu.addressbook.common.Messages.MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE;
import static seedu.addressbook.common.Messages.MESSAGE_USING_STORAGE_FILE;
import static seedu.addressbook.common.Messages.MESSAGE_WELCOME;

import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Scanner;

import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Text UI of the application.
 */
public class TextUi {

    /** Offset required to convert between 1-indexing and 0-indexing.  */
    public static final int DISPLAYED_INDEX_OFFSET = 1;

    /** A decorative prefix added to the beginning of lines printed by AddressBook */
    private static final String LINE_PREFIX = ""|| "";

    /** A platform independent line separator. */
    private static final String LS = System.lineSeparator();

    private static final String DIVIDER = ""==================================================="";

    /** Format of indexed list item */
    private static final String MESSAGE_INDEXED_LIST_ITEM = ""\t%1$d. %2$s"";

    /** Format of a comment input line. Comment lines are silently consumed when reading user input. */
    private static final String COMMENT_LINE_FORMAT_REGEX = ""#.*"";

    private final Scanner in;
    private final PrintStream out;

    public TextUi() {
        this(System.in, System.out);
    }

    public TextUi(InputStream in, PrintStream out) {
        this.in = new Scanner(in);
        this.out = out;
    }

    /**
     * Returns true if the user input line should be ignored.
     * Input should be ignored if it is parsed as a comment, is only whitespace, or is empty.
     *
     * @param rawInputLine full raw user input line.
     * @return true if the entire user input line should be ignored.
     */
    private boolean shouldIgnore(String rawInputLine) {
        return rawInputLine.trim().isEmpty() || isCommentLine(rawInputLine);
    }

    /**
     * Returns true if the user input line is a comment line.
     *
     * @param rawInputLine full raw user input line.
     * @return true if input line is a comment.
     */
    private boolean isCommentLine(String rawInputLine) {
        return rawInputLine.trim().matches(COMMENT_LINE_FORMAT_REGEX);
    }

    /**
     * Prompts for the command and reads the text entered by the user.
     * Ignores empty, pure whitespace, and comment lines.
     * Echos the command back to the user.
     * @return command (full line) entered by the user
     */
    public String getUserCommand() {
        out.print(LINE_PREFIX + ""Enter command: "");
        String fullInputLine = in.nextLine();

        // silently consume all ignored lines
        while (shouldIgnore(fullInputLine)) {
            fullInputLine = in.nextLine();
        }

        showToUser(""[Command entered:"" + fullInputLine + ""]"");
        return fullInputLine;
    }

    /**
     * Generates and prints the welcome message upon the start of the application.
     * @param version current version of the application.
     * @param storageFilePath path to the storage file being used.
     */
    public void showWelcomeMessage(String version, String storageFilePath) {
        String storageFileInfo = String.format(MESSAGE_USING_STORAGE_FILE, storageFilePath);
        showToUser(
                DIVIDER,
                DIVIDER,
                MESSAGE_WELCOME,
                version,
                MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE,
                storageFileInfo,
                DIVIDER);
    }

    public void showGoodbyeMessage() {
        showToUser(MESSAGE_GOODBYE, DIVIDER, DIVIDER);
    }


    public void showInitFailedMessage() {
        showToUser(MESSAGE_INIT_FAILED, DIVIDER, DIVIDER);
    }

    /** Shows message(s) to the user */
    public void showToUser(String... message) {
        for (String m : message) {
            out.println(LINE_PREFIX + m.replace(""\n"", LS + LINE_PREFIX));
        }
    }

    /**
     * Shows the result of a command execution to the user. Includes additional formatting to demarcate different
     * command execution segments.
     */
    public void showResultToUser(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> resultPersons = result.getRelevantPersons();
        if (resultPersons.isPresent()) {
            showPersonListView(resultPersons.get());
        }
        showToUser(result.feedbackToUser, DIVIDER);
    }

    /**
     * Shows a list of persons to the user, formatted as an indexed list.
     * Private contact details are hidden.
     */
    private void showPersonListView(List<? extends ReadOnlyPerson> persons) {
        final List<String> formattedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : persons) {
            formattedPersons.add(person.getAsTextHidePrivate());
        }
        showToUserAsIndexedList(formattedPersons);
    }

    /** Shows a list of strings to the user, formatted as an indexed list. */
    private void showToUserAsIndexedList(List<String> list) {
        showToUser(getIndexedListForViewing(list));
    }

    /** Formats a list of strings as a viewable indexed list. */
    private static String getIndexedListForViewing(List<String> listItems) {
        final StringBuilder formatted = new StringBuilder();
        int displayIndex = 0 + DISPLAYED_INDEX_OFFSET;
        for (String listItem : listItems) {
            formatted.append(getIndexedListItem(displayIndex, listItem)).append(""\n"");
            displayIndex++;
        }
        return formatted.toString();
    }

    /**
     * Formats a string as a viewable indexed list item.
     *
     * @param visibleIndex visible index for this listing
     */
    private static String getIndexedListItem(int visibleIndex, String listItem) {
        return String.format(MESSAGE_INDEXED_LIST_ITEM, visibleIndex, listItem);
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.parser;

import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Parses user input.
 */
public class Parser {

    public static final Pattern PERSON_INDEX_ARGS_FORMAT = Pattern.compile(""(?<targetIndex>.+)"");

    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile(""(?<keywords>\\S+(?:\\s+\\S+)*)""); // one or more keywords separated by whitespace

    public static final Pattern PERSON_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile(""(?<name>[^/]+)""
                    + "" (?<isPhonePrivate>p?)p/(?<phone>[^/]+)""
                    + "" (?<isEmailPrivate>p?)e/(?<email>[^/]+)""
                    + "" (?<isAddressPrivate>p?)a/(?<address>[^/]+)""
                    + ""(?<tagArguments>(?: t/[^/]+)*)""); // variable number of tags


    /**
     * Used for initial separation of command word and args.
     */
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile(""(?<commandWord>\\S+)(?<arguments>.*)"");

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group(""commandWord"");
        final String arguments = matcher.group(""arguments"");

        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return prepareFind(arguments);

        case ListCommand.COMMAND_WORD:
            return new ListCommand();

        case ViewCommand.COMMAND_WORD:
            return prepareView(arguments);

        case ViewAllCommand.COMMAND_WORD:
            return prepareViewAll(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD: // Fallthrough
        default:
            return new HelpCommand();
        }
    }

    /**
     * Parses arguments in the context of the add person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return new AddCommand(
                    matcher.group(""name""),

                    matcher.group(""phone""),
                    isPrivatePrefixPresent(matcher.group(""isPhonePrivate"")),

                    matcher.group(""email""),
                    isPrivatePrefixPresent(matcher.group(""isEmailPrivate"")),

                    matcher.group(""address""),
                    isPrivatePrefixPresent(matcher.group(""isAddressPrivate"")),

                    getTagsFromArgs(matcher.group(""tagArguments""))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Returns true if the private prefix is present for a contact detail in the add command's arguments string.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return matchedPrefix.equals(""p"");
    }

    /**
     * Extracts the new person's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst("" t/"", """").split("" t/""));
        return new HashSet<>(tagStrings);
    }


    /**
     * Parses arguments in the context of the delete person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new DeleteCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view all command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareViewAll(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewAllCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewAllCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses the given arguments string as a single index number.
     *
     * @param args arguments string to parse as index number
     * @return the parsed index number
     * @throws ParseException if no region of the args string could be found for the index
     * @throws NumberFormatException the args string region is not a valid number
     */
    private int parseArgsAsDisplayedIndex(String args) throws ParseException, NumberFormatException {
        final Matcher matcher = PERSON_INDEX_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            throw new ParseException(""Could not find index number to parse"");
        }
        return Integer.parseInt(matcher.group(""targetIndex""));
    }


    /**
     * Parses arguments in the context of the find person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group(""keywords"").split(""\\s+"");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    /**
     * Signals that the user input could not be parsed.
     */
    public static class ParseException extends Exception {
        ParseException(String message) {
            super(message);
        }
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.storage;

import static seedu.addressbook.parser.Parser.PERSON_DATA_ARGS_FORMAT;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

/**
 * Decodes the storage data file into an {@code AddressBook} object.
 */
public class AddressBookDecoder {

    /**
     * Decodes {@code encodedAddressBook} into an {@code AddressBook} containing the decoded persons.
     *
     * @throws IllegalValueException if any of the fields in any encoded person string is invalid.
     * @throws StorageOperationException if the {@code encodedAddressBook} is in an invalid format.
     */
    public static AddressBook decodeAddressBook(List<String> encodedAddressBook)
            throws IllegalValueException, StorageOperationException {
        final List<Person> decodedPersons = new ArrayList<>();
        for (String encodedPerson : encodedAddressBook) {
            decodedPersons.add(decodePersonFromString(encodedPerson));
        }
        return new AddressBook(new UniquePersonList(decodedPersons));
    }

    /**
     * Decodes {@code encodedPerson} into a {@code Person}.
     *
     * @throws IllegalValueException if any field in the {@code encodedPerson} is invalid.
     * @throws StorageOperationException if {@code encodedPerson} is in an invalid format.
     */
    private static Person decodePersonFromString(String encodedPerson)
            throws IllegalValueException, StorageOperationException {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(encodedPerson);
        if (!matcher.matches()) {
            throw new StorageOperationException(""Encoded person in invalid format. Unable to decode."");
        }

        return new Person(
                new Name(matcher.group(""name"")),
                new Phone(matcher.group(""phone""), isPrivatePrefixPresent(matcher.group(""isPhonePrivate""))),
                new Email(matcher.group(""email""), isPrivatePrefixPresent(matcher.group(""isEmailPrivate""))),
                new Address(matcher.group(""address""), isPrivatePrefixPresent(matcher.group(""isAddressPrivate""))),
                getTagsFromEncodedPerson(matcher.group(""tagArguments""))
        );
    }

    /**
     * Returns true if {@code matchedPrefix} is equal to the private prefix for contact details.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return ""p"".equals(matchedPrefix);
    }

    /**
     * Extracts the {@code Tag}s from the {@code tagArguments} string.
     * Merges duplicate tag strings.
     */
    private static Set<Tag> getTagsFromEncodedPerson(String tagArguments) throws IllegalValueException {
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }

        // replace first delimiter prefix, then split
        final String[] tagStrings = tagArguments.replaceFirst("" t/"", """").split("" t/"");
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tagStrings) {
            tagSet.add(new Tag(tagName));
        }

        return tagSet;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.storage;

import java.util.ArrayList;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Person;

/**
 * Encodes the {@code AddressBook} object into a data file for storage.
 */
public class AddressBookEncoder {

    /**
     * Encodes all the {@code Person} in the {@code toSave} into a list of decodable and readable string presentation
     * for storage.
     */
    public static List<String> encodeAddressBook(AddressBook toSave) {
        final List<String> encodedPersons = new ArrayList<>();
        toSave.getAllPersons().forEach(person -> encodedPersons.add(encodePersonToString(person)));
        return encodedPersons;
    }

    /**
     * Encodes the {@code person} into a decodable and readable string representation.
     */
    private static String encodePersonToString(Person person) {
        final StringBuilder encodedPersonBuilder = new StringBuilder();

        encodedPersonBuilder.append(person.getName());

        encodedPersonBuilder.append(person.getPhone().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""p/"").append(person.getPhone().value);

        encodedPersonBuilder.append(person.getEmail().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""e/"").append(person.getEmail().value);

        encodedPersonBuilder.append(person.getAddress().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""a/"").append(person.getAddress().value);

        person.getTags().forEach(tag -> encodedPersonBuilder.append("" t/"").append(tag.tagName));

        return encodedPersonBuilder.toString();
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.storage;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents the file used to store address book data.
 */
public class StorageFile {

    /** Default file path used if the user doesn't provide the file name. */
    public static final String DEFAULT_STORAGE_FILEPATH = ""addressbook.txt"";


    public final Path path;

    /**
     * @throws InvalidStorageFilePathException if the default path is invalid
     */
    public StorageFile() throws InvalidStorageFilePathException {
        this(DEFAULT_STORAGE_FILEPATH);
    }

    /**
     * @throws InvalidStorageFilePathException if the given file path is invalid
     */
    public StorageFile(String filePath) throws InvalidStorageFilePathException {
        path = Paths.get(filePath);
        if (!isValidPath(path)) {
            throw new InvalidStorageFilePathException(""Storage file should end with '.txt'"");
        }
    }

    /**
     * Returns true if the given path is acceptable as a storage file.
     * The file path is considered acceptable if it ends with '.txt'
     */
    private static boolean isValidPath(Path filePath) {
        return filePath.toString().endsWith("".txt"");
    }

    /**
     * Saves the {@code addressBook} data to the storage file.
     *
     * @throws StorageOperationException if there were errors converting and/or storing data to file.
     */
    public void save(AddressBook addressBook) throws StorageOperationException {
        try {
            List<String> encodedAddressBook = AddressBookEncoder.encodeAddressBook(addressBook);
            Files.write(path, encodedAddressBook);
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        }
    }

    /**
     * Loads the {@code AddressBook} data from this storage file, and then returns it.
     * Returns an empty {@code AddressBook} if the file does not exist, or is not a regular file.
     *
     * @throws StorageOperationException if there were errors reading and/or converting data from file.
     */
    public AddressBook load() throws StorageOperationException {

        if (!Files.exists(path) || !Files.isRegularFile(path)) {
            return new AddressBook();
        }

        try {
            return AddressBookDecoder.decodeAddressBook(Files.readAllLines(path));
        } catch (FileNotFoundException fnfe) {
            throw new AssertionError(""A non-existent file scenario is already handled earlier."");
        // other errors
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        } catch (IllegalValueException ive) {
            throw new StorageOperationException(""File contains illegal data values; data type constraints not met"");
        }
    }

    public String getPath() {
        return path.toString();
    }

    /* Note: Note the use of nested classes below.
     * More info https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
     */

    /**
     * Signals that the given file path does not fulfill the storage filepath constraints.
     */
    public static class InvalidStorageFilePathException extends IllegalValueException {
        public InvalidStorageFilePathException(String message) {
            super(message);
        }
    }

    /**
     * Signals that some error has occured while trying to convert and read/write data between the application
     * and the storage file.
     */
    public static class StorageOperationException extends Exception {
        public StorageOperationException(String message) {
            super(message);
        }
    }


}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.common;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * Utility methods
 */
public class Utils {

    /**
     * Returns true if any of the given items are null.
     */
    public static boolean isAnyNull(Object... items) {
        if (items == null) {
            return false;
        }
        for (Object item : items) {
            if (item == null) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if every element the given collection are unique by {@link Object#equals(Object)}.
     */
    public static boolean elementsAreUnique(Collection<?> items) {
        final Set<Object> testSet = new HashSet<>();
        for (Object item : items) {
            final boolean itemAlreadyExists = !testSet.add(item); // see Set documentation
            if (itemAlreadyExists) {
                return false;
            }
        }
        return true;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.common;

/**
 * Container for user visible messages.
 */
public class Messages {

    public static final String MESSAGE_GOODBYE = ""Good bye!"";
    public static final String MESSAGE_INIT_FAILED = ""Failed to initialise address book application. Exiting..."";
    public static final String MESSAGE_INVALID_COMMAND_FORMAT = ""Invalid command format! \n%1$s"";
    public static final String MESSAGE_INVALID_PERSON_DISPLAYED_INDEX = ""The person index provided is invalid"";
    public static final String MESSAGE_PERSON_NOT_IN_ADDRESSBOOK = ""Person could not be found in address book"";
    public static final String MESSAGE_PERSONS_LISTED_OVERVIEW = ""%1$d persons listed!"";
    public static final String MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE = ""Launch command format: ""
            + ""java seedu.addressbook.Main [STORAGE_FILE_PATH]"";
    public static final String MESSAGE_WELCOME = ""Welcome to your Address Book!"";
    public static final String MESSAGE_USING_STORAGE_FILE = ""Using storage file : %1$s"";
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows details of the person identified using the last displayed index.
 * Private contact details are not shown.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = ""view"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextHidePrivate()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;


/**
 * Deletes a person identified using it's last displayed index from the address book.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = ""delete"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Deletes the person identified by the index number used in the last person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_DELETE_PERSON_SUCCESS = ""Deleted Person: %1$s"";


    public DeleteCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            addressBook.removePerson(target);
            return new CommandResult(String.format(MESSAGE_DELETE_PERSON_SUCCESS, target));

        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        } catch (PersonNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
        }
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import java.util.List;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = ""list"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Displays all persons in the address book as a list with index numbers.\n""
            + ""Example: "" + COMMAND_WORD;


    @Override
    public CommandResult execute() {
        List<ReadOnlyPerson> allPersons = addressBook.getAllPersons().immutableListView();
        return new CommandResult(getMessageForPersonListShownSummary(allPersons), allPersons);
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows all details of the person identified using the last displayed index.
 * Private contact details are shown.
 */
public class ViewAllCommand extends Command {

    public static final String COMMAND_WORD = ""viewall"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewAllCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextShowAll()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

/**
 * Clears the address book.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = ""clear"";
    public static final String MESSAGE_USAGE = ""Clears address book permanently.\n""
            + ""Example: "" + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = ""Address book has been cleared!"";

    @Override
    public CommandResult execute() {
        addressBook.clear();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import static seedu.addressbook.ui.TextUi.DISPLAYED_INDEX_OFFSET;

import java.util.List;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Represents an executable command.
 */
public class Command {
    protected AddressBook addressBook;
    protected List<? extends ReadOnlyPerson> relevantPersons;
    private int targetIndex = -1;

    /**
     * @param targetIndex last visible listing index of the target person
     */
    public Command(int targetIndex) {
        this.setTargetIndex(targetIndex);
    }

    protected Command() {
    }

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of persons.
     *
     * @param personsDisplayed used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForPersonListShownSummary(List<? extends ReadOnlyPerson> personsDisplayed) {
        return String.format(Messages.MESSAGE_PERSONS_LISTED_OVERVIEW, personsDisplayed.size());
    }

    /**
     * Executes the command and returns the result.
     */
    public CommandResult execute() {
        throw new UnsupportedOperationException(""This method is to be implemented by child classes"");
    };

    /**
     * Supplies the data the command will operate on.
     */
    public void setData(AddressBook addressBook, List<? extends ReadOnlyPerson> relevantPersons) {
        this.addressBook = addressBook;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Extracts the the target person in the last shown list from the given arguments.
     *
     * @throws IndexOutOfBoundsException if the target index is out of bounds of the last viewed listing
     */
    protected ReadOnlyPerson getTargetPerson() throws IndexOutOfBoundsException {
        return relevantPersons.get(getTargetIndex() - DISPLAYED_INDEX_OFFSET);
    }

    public int getTargetIndex() {
        return targetIndex;
    }

    public void setTargetIndex(int targetIndex) {
        this.targetIndex = targetIndex;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;

/**
 * Adds a person to the address book.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = ""add"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Adds a person to the address book. ""
            + ""Contact details can be marked private by prepending 'p' to the prefix.\n""
            + ""Parameters: NAME [p]p/PHONE [p]e/EMAIL [p]a/ADDRESS  [t/TAG]...\n""
            + ""Example: "" + COMMAND_WORD
            + "" John Doe p/98765432 e/johnd@gmail.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney"";

    public static final String MESSAGE_SUCCESS = ""New person added: %1$s"";
    public static final String MESSAGE_DUPLICATE_PERSON = ""This person already exists in the address book"";

    private final Person toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name,
                      String phone, boolean isPhonePrivate,
                      String email, boolean isEmailPrivate,
                      String address, boolean isAddressPrivate,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Person(
                new Name(name),
                new Phone(phone, isPhonePrivate),
                new Email(email, isEmailPrivate),
                new Address(address, isAddressPrivate),
                tagSet
        );
    }

    public AddCommand(Person toAdd) {
        this.toAdd = toAdd;
    }

    public ReadOnlyPerson getPerson() {
        return toAdd;
    }

    @Override
    public CommandResult execute() {
        try {
            addressBook.addPerson(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniquePersonList.DuplicatePersonException dpe) {
            return new CommandResult(MESSAGE_DUPLICATE_PERSON);
        }
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;


/**
 * Shows help instructions.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = ""help"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Shows program usage instructions.\n""
            + ""Example: "" + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        return new CommandResult(
                AddCommand.MESSAGE_USAGE
                + ""\n"" + DeleteCommand.MESSAGE_USAGE
                + ""\n"" + ClearCommand.MESSAGE_USAGE
                + ""\n"" + FindCommand.MESSAGE_USAGE
                + ""\n"" + ListCommand.MESSAGE_USAGE
                + ""\n"" + ViewCommand.MESSAGE_USAGE
                + ""\n"" + ViewAllCommand.MESSAGE_USAGE
                + ""\n"" + HelpCommand.MESSAGE_USAGE
                + ""\n"" + ExitCommand.MESSAGE_USAGE
        );
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;


/**
 * Represents an incorrect command. Upon execution, produces some feedback to the user.
 */
public class IncorrectCommand extends Command {

    public final String feedbackToUser;

    public IncorrectCommand(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
    }

    @Override
    public CommandResult execute() {
        return new CommandResult(feedbackToUser);
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Finds and lists all persons in address book whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = ""find"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Finds all persons whose names contain any of ""
            + ""the specified keywords (case-sensitive) and displays them as a list with index numbers.\n""
            + ""Parameters: KEYWORD [MORE_KEYWORDS]...\n""
            + ""Example: "" + COMMAND_WORD + "" alice bob charlie"";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    /**
     * Returns a copy of keywords in this command.
     */
    public Set<String> getKeywords() {
        return new HashSet<>(keywords);
    }

    @Override
    public CommandResult execute() {
        final List<ReadOnlyPerson> personsFound = getPersonsWithNameContainingAnyKeyword(keywords);
        return new CommandResult(getMessageForPersonListShownSummary(personsFound), personsFound);
    }

    /**
     * Retrieves all persons in the address book whose names contain some of the specified keywords.
     *
     * @param keywords for searching
     * @return list of persons found
     */
    private List<ReadOnlyPerson> getPersonsWithNameContainingAnyKeyword(Set<String> keywords) {
        final List<ReadOnlyPerson> matchedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : addressBook.getAllPersons()) {
            final Set<String> wordsInName = new HashSet<>(person.getName().getWordsInName());
            if (!Collections.disjoint(wordsInName, keywords)) {
                matchedPersons.add(person);
            }
        }
        return matchedPersons;
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = ""exit"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Exits the program.\n""
            + ""Example: "" + COMMAND_WORD;
    public static final String MESSAGE_EXIT_ACKNOWEDGEMENT = ""Exiting Address Book as requested ..."";

    @Override
    public CommandResult execute() {
        return new CommandResult(MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    public static boolean isExit(Command command) {
        return command instanceof ExitCommand; // instanceof returns false if it is null
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.commands;

import java.util.List;
import java.util.Optional;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Represents the result of a command execution.
 */
public class CommandResult {

    /** The feedback message to be shown to the user. Contains a description of the execution result */
    public final String feedbackToUser;

    /** The list of persons that was produced by the command */
    private final List<? extends ReadOnlyPerson> relevantPersons;

    public CommandResult(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
        relevantPersons = null;
    }

    public CommandResult(String feedbackToUser, List<? extends ReadOnlyPerson> relevantPersons) {
        this.feedbackToUser = feedbackToUser;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Returns a list of persons relevant to the command command result, if any.
     */
    public Optional<List<? extends ReadOnlyPerson>> getRelevantPersons() {
        return Optional.ofNullable(relevantPersons);
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data;

import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;

/**
 * Represents the entire address book. Contains the data of the address book.
 */
public class AddressBook {

    private final UniquePersonList allPersons;

    /**
     * Creates an empty address book.
     */
    public AddressBook() {
        allPersons = new UniquePersonList();
    }

    /**
     * Constructs an address book with the given data.
     *
     * @param persons external changes to this will not affect this address book
     */
    public AddressBook(UniquePersonList persons) {
        this.allPersons = new UniquePersonList(persons);
    }

    /**
     * Adds a person to the address book.
     *
     * @throws DuplicatePersonException if an equivalent person already exists.
     */
    public void addPerson(Person toAdd) throws DuplicatePersonException {
        allPersons.add(toAdd);
    }

    /**
     * Returns true if an equivalent person exists in the address book.
     */
    public boolean containsPerson(ReadOnlyPerson key) {
        return allPersons.contains(key);
    }

    /**
     * Removes the equivalent person from the address book.
     *
     * @throws PersonNotFoundException if no such Person could be found.
     */
    public void removePerson(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        allPersons.remove(toRemove);
    }

    /**
     * Clears all persons and tags from the address book.
     */
    public void clear() {
        allPersons.clear();
    }

    /**
     * Returns a new UniquePersonList of all persons in the address book at the time of the call.
     */
    public UniquePersonList getAllPersons() {
        return new UniquePersonList(allPersons);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddressBook // instanceof handles nulls
                        && this.allPersons.equals(((AddressBook) other).allPersons));
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's phone number in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidPhone(String)}
 */
public class Phone {

    public static final String EXAMPLE = ""123456789"";
    public static final String MESSAGE_PHONE_CONSTRAINTS = ""Person phone numbers should only contain numbers"";
    public static final String PHONE_VALIDATION_REGEX = ""\\d+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given phone number.
     *
     * @throws IllegalValueException if given phone string is invalid.
     */
    public Phone(String phone, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedPhone = phone.trim();
        if (!isValidPhone(trimmedPhone)) {
            throw new IllegalValueException(MESSAGE_PHONE_CONSTRAINTS);
        }
        this.value = trimmedPhone;
    }

    /**
     * Returns true if the given string is a valid person phone number.
     */
    public static boolean isValidPhone(String test) {
        return test.matches(PHONE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Phone // instanceof handles nulls
                && this.value.equals(((Phone) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's email in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidEmail(String)}
 */
public class Email {

    public static final String EXAMPLE = ""valid@e.mail"";
    public static final String MESSAGE_EMAIL_CONSTRAINTS =
            ""Person emails should be 2 alphanumeric/period strings separated by '@'"";
    public static final String EMAIL_VALIDATION_REGEX = ""[\\w\\.]+@[\\w\\.]+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given email.
     *
     * @throws IllegalValueException if given email address string is invalid.
     */
    public Email(String email, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedEmail = email.trim();
        if (!isValidEmail(trimmedEmail)) {
            throw new IllegalValueException(MESSAGE_EMAIL_CONSTRAINTS);
        }
        this.value = trimmedEmail;
    }

    /**
     * Returns true if the given string is a valid person email.
     */
    public static boolean isValidEmail(String test) {
        return test.matches(EMAIL_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Email // instanceof handles nulls
                && this.value.equals(((Email) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }


    public boolean isPrivate() {
        return isPrivate;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.person;

import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * A read-only immutable interface for a Person in the addressbook.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyPerson {

    Name getName();
    Phone getPhone();
    Email getEmail();
    Address getAddress();

    /**
     * Returns a new TagSet that is a deep copy of the internal TagSet,
     * changes on the returned set will not affect the person's internal tags.
     */
    Set<Tag> getTags();

    /**
     * Returns true if both persons have the same identity fields (name and telephone).
     */
    default boolean isSamePerson(ReadOnlyPerson other) {
        return (other == this)
                || (other != null
                    && other.getName().equals(this.getName())
                    && other.getPhone().equals(this.getPhone()));
    }

    /**
     * Returns true if all data in this object is the same as that in another
     * (Note: interfaces cannot override .equals)
     */
    default boolean hasSameData(ReadOnlyPerson other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) // state checks here onwards
                    && other.getPhone().equals(this.getPhone())
                    && other.getEmail().equals(this.getEmail())
                    && other.getAddress().equals(this.getAddress())
                    && other.getTags().equals(this.getTags()));
    }

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsTextShowAll() {
        final StringBuilder builder = new StringBuilder();
        final String detailIsPrivate = ""(private) "";
        builder.append(getName())
                .append("" Phone: "");
        if (getPhone().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getPhone())
                .append("" Email: "");
        if (getEmail().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getEmail())
                .append("" Address: "");
        if (getAddress().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getAddress())
                .append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }

    /**
     * Formats a person as text, showing only non-private contact details.
     */
    default String getAsTextHidePrivate() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (!getPhone().isPrivate()) {
            builder.append("" Phone: "").append(getPhone());
        }
        if (!getEmail().isPrivate()) {
            builder.append("" Email: "").append(getEmail());
        }
        if (!getAddress().isPrivate()) {
            builder.append("" Address: "").append(getAddress());
        }
        builder.append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.person;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.common.Utils;
import seedu.addressbook.data.exception.DuplicateDataException;



/**
 * A list of persons. Does not allow null elements or duplicates.
 *
 * @see Person#equals(Object)
 * @see Utils#elementsAreUnique(Collection)
 */
public class UniquePersonList implements Iterable<Person> {



    private final List<Person> internalList = new ArrayList<>();

    /**
     * Constructs empty person list.
     */
    public UniquePersonList() {}

    /**
     * Constructs a person list with the given persons.
     */
    public UniquePersonList(Person... persons) throws DuplicatePersonException {
        final List<Person> initialTags = Arrays.asList(persons);
        if (!Utils.elementsAreUnique(initialTags)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(initialTags);
    }

    /**
     * Constructs a list from the items in the given collection.
     * @param persons a collection of persons
     * @throws DuplicatePersonException if the {@code persons} contains duplicate persons
     */
    public UniquePersonList(Collection<Person> persons) throws DuplicatePersonException {
        if (!Utils.elementsAreUnique(persons)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(persons);
    }

    /**
     * Constructs a shallow copy of the list.
     */
    public UniquePersonList(UniquePersonList source) {
        internalList.addAll(source.internalList);
    }

    /**
     * Returns an unmodifiable java List view with elements cast as immutable {@link ReadOnlyPerson}s.
     * For use with other methods/libraries.
     * Any changes to the internal list/elements are immediately visible in the returned list.
     */
    public List<ReadOnlyPerson> immutableListView() {
        return Collections.unmodifiableList(internalList);
    }


    /**
     * Checks if the list contains an equivalent person as the given argument.
     * The {@link ReadOnlyPerson#isSamePerson} method is used for this comparison, which
     * defines a weaker notion of equality.
     */
    public boolean contains(ReadOnlyPerson toCheck) {
        for (Person p : internalList) {
            if (p.isSamePerson(toCheck)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a person to the list.
     *
     * @throws DuplicatePersonException if the person to add is a duplicate of an existing person in the list.
     *    The @link{ReadOnlyPerson#isSamePerson} method is used for this comparison,
     *    which defines a weaker notion of equality.
     */
    public void add(Person toAdd) throws DuplicatePersonException {
        if (contains(toAdd)) {
            throw new DuplicatePersonException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent person from the list.
     *
     * @throws PersonNotFoundException if no such person could be found in the list.
     */
    public void remove(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        final boolean personFoundAndDeleted = internalList.remove(toRemove);
        if (!personFoundAndDeleted) {
            throw new PersonNotFoundException();
        }
    }

    /**
     * Clears all persons in list.
     */
    public void clear() {
        internalList.clear();
    }

    @Override
    public Iterator<Person> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniquePersonList // instanceof handles nulls
                        && this.internalList.equals(((UniquePersonList) other).internalList));
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicatePersonException extends DuplicateDataException {
        protected DuplicatePersonException() {
            super(""Operation would result in duplicate persons"");
        }
    }

    /**
     * Signals that an operation targeting a specified person in the list would fail because
     * there is no such matching person in the list.
     */
    public static class PersonNotFoundException extends Exception {}
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's address in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidAddress(String)}
 */
public class Address {

    public static final String EXAMPLE = ""123, some street"";
    public static final String MESSAGE_ADDRESS_CONSTRAINTS = ""Person addresses can be in any format"";
    public static final String ADDRESS_VALIDATION_REGEX = "".+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given address.
     *
     * @throws IllegalValueException if given address string is invalid.
     */
    public Address(String address, boolean isPrivate) throws IllegalValueException {
        String trimmedAddress = address.trim();
        this.isPrivate = isPrivate;
        if (!isValidAddress(trimmedAddress)) {
            throw new IllegalValueException(MESSAGE_ADDRESS_CONSTRAINTS);
        }
        this.value = trimmedAddress;
    }

    /**
     * Returns true if a given string is a valid person address.
     */
    public static boolean isValidAddress(String test) {
        return test.matches(ADDRESS_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Address // instanceof handles nulls
                && this.value.equals(((Address) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.person;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * Represents a Person in the address book.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Person implements ReadOnlyPerson {

    private Name name;
    private Phone phone;
    private Email email;
    private Address address;

    private final Set<Tag> tags = new HashSet<>();

    /**
     * Assumption: Every field must be present and not null.
     */
    public Person(Name name, Phone phone, Email email, Address address, Set<Tag> tags) {
        this.name = name;
        this.phone = phone;
        this.email = email;
        this.address = address;
        this.tags.addAll(tags);
    }

    /**
     * Copy constructor.
     */
    public Person(ReadOnlyPerson source) {
        this(source.getName(), source.getPhone(), source.getEmail(), source.getAddress(), source.getTags());
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public Phone getPhone() {
        return phone;
    }

    @Override
    public Email getEmail() {
        return email;
    }

    @Override
    public Address getAddress() {
        return address;
    }

    @Override
    public Set<Tag> getTags() {
        return new HashSet<>(tags);
    }

    /**
     * Replaces this person's tags with the tags in the argument tag set.
     */
    public void setTags(Set<Tag> replacement) {
        tags.clear();
        tags.addAll(replacement);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyPerson // instanceof handles nulls
                && this.hasSameData((ReadOnlyPerson) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, phone, email, address, tags);
    }

    @Override
    public String toString() {
        return getAsTextShowAll();
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.person;

import java.util.Arrays;
import java.util.List;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's name in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String EXAMPLE = ""John Doe"";
    public static final String MESSAGE_NAME_CONSTRAINTS = ""Person names should be spaces or alphabetic characters"";
    public static final String NAME_VALIDATION_REGEX = ""[\\p{Alpha} ]+"";
    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = trimmedName;
    }

    /**
     * Returns true if the given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }

    /**
     * Retrieves a listing of every word in the name, in order.
     */
    public List<String> getWordsInName() {
        return Arrays.asList(fullName.split(""\\s+""));
    }

    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.exception;

/**
 * Signals an error caused by duplicate data where there should be none.
 */
public abstract class DuplicateDataException extends IllegalValueException {
    public DuplicateDataException(String message) {
        super(message);
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.exception;

/**
 * Signals that some given data does not fulfill some constraints.
 */
public class IllegalValueException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public IllegalValueException(String message) {
        super(message);
    }
}
",1.11,2.22
sc1_v3,a66bc84,"package seedu.addressbook.data.tag;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Tag in the address book.
 * Guarantees: immutable; name is valid as declared in {@link #isValidTagName(String)}
 */
public class Tag {

    public static final String MESSAGE_TAG_CONSTRAINTS = ""Tags names should be alphanumeric"";
    public static final String TAG_VALIDATION_REGEX = ""\\p{Alnum}+"";

    public final String tagName;

    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid tag name.
     */
    public static boolean isValidTagName(String test) {
        return test.matches(TAG_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    @Override
    public String toString() {
        return '[' + tagName + ']';
    }

}
",1.11,2.22
sc1_v4,deafd87,"package seedu.addressbook.util;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;

public class TestUtil {
    /**
     * Creates an address book containing the given persons.
     */
    public static AddressBook createAddressBook(Person... persons) {
        AddressBook addressBook = new AddressBook();

        for (Person person : persons) {
            try {
                addressBook.addPerson(person);
            } catch (DuplicatePersonException e) {
                throw new AssertionError(e);
            }
        }

        return addressBook;
    }

    /**
     * Creates a list of persons.
     */
    public static List<ReadOnlyPerson> createList(Person...persons) {
        List<ReadOnlyPerson> list = new ArrayList<ReadOnlyPerson>();

        for (Person person : persons) {
            list.add(person);
        }

        return list;
    }

    /**
     * Creates a copy of the original address book with the same entries
     * of Persons and Tags. The Persons and Tags are not cloned.
     */
    public static AddressBook clone(AddressBook addressBook) {
        return new AddressBook(addressBook.getAllPersons());
    }

    /**
     * Returns true if every pair of corresponding elements two iterables are (deeply) identical.
     * In other words, the two containers must have the same elements, in the same order.
     */
    public static <T> boolean isIdentical(Iterable<T> firstIterable, Iterable<T> secondIterable) {
        Iterator<T> currentPtr0 = firstIterable.iterator();
        Iterator<T> currentPtr1 = secondIterable.iterator();

        while (currentPtr0.hasNext() && currentPtr1.hasNext()) {
            T val0 = currentPtr0.next();
            T val1 = currentPtr1.next();

            if (!val0.equals(val1)) {
                return false;
            }
        }

        // If any of the two iterables still have elements, then they have different sizes.
        return !(currentPtr0.hasNext() || currentPtr1.hasNext());
    }

    /**
     * Returns true if the underlying container behind an iterable is empty.
     */
    public static <T> boolean isEmpty(Iterable<T> it) {
        return !it.iterator().hasNext();
    }

    /**
     * Returns the number of elements in the container behind an iterable.
     */
    public static <T> int getSize(Iterable<T> it) {
        int numberOfElementsSeen = 0;

        for (T elem : it) {
            numberOfElementsSeen++;
        }

        return numberOfElementsSeen;
    }

    public static Person generateTestPerson() {
        try {
            return new Person(new Name(Name.EXAMPLE), new Phone(Phone.EXAMPLE, false),
                    new Email(Email.EXAMPLE, true), new Address(Address.EXAMPLE, false), Collections.emptySet());
        } catch (IllegalValueException e) {
            fail(""test person data should be valid by definition"");
            return null;
        }
    }

    /**
     * Asserts whether the text in the two given files are the same. Ignores any
     * differences in line endings
     */
    public static void assertTextFilesEqual(Path path1, Path path2) throws IOException {
        List<String> list1 = Files.readAllLines(path1, Charset.defaultCharset());
        List<String> list2 = Files.readAllLines(path2, Charset.defaultCharset());
        assertEquals(String.join(""\n"", list1), String.join(""\n"", list2));
    }

    /**
     * Asserts that the file given does not exist on the filesystem.
     */
    public static void assertFileDoesNotExist(String filePath) {
        assertTrue(Files.notExists(Paths.get(filePath)));
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.util;

import java.util.Collections;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;

/**
 * Class to generate typical test persons
 */
public class TypicalPersons {

    public Person amy, bill, candy, dan;

    public TypicalPersons() {
        try {
            amy = new Person(new Name(""Amy Buck""), new Phone(""91119111"", false), new Email(""ab@gmail.com"", false),
                    new Address(""1 Clementi Road"", false), Collections.emptySet());
            bill = new Person(new Name(""Bill Clint""), new Phone(""92229222"", false), new Email(""bc@gmail.com"", false),
                    new Address(""2 Clementi Road"", true), Collections.emptySet());
            candy = new Person(new Name(""Candy Destiny""), new Phone(""93339333"", true),
                    new Email(""cd@gmail.com"", false), new Address(""3 Clementi Road"", true), Collections.emptySet());
            dan = new Person(new Name(""Dan Smith""), new Phone(""1234556"", true), new Email(""ss@tt.com"", true),
                    new Address(""NUS"", true), Collections.singleton(new Tag(""test"")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : ""not possible"";
        }
    }

    private void loadAddressBookWithSampleData(AddressBook ab) {
        try {
            for (Person p : this.getTypicalPersons()) {
                ab.addPerson(new Person(p));
            }
        } catch (IllegalValueException e) {
            assert false : ""not possible"";
        }
    }

    public Person[] getTypicalPersons() {
        return new Person[]{amy, bill, candy, dan};
    }

    public AddressBook getTypicalAddressBook() {
        AddressBook ab = new AddressBook();
        loadAddressBookWithSampleData(ab);
        return ab;
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.parser;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.tag.Tag;

public class ParserTest {

    private Parser parser;

    @BeforeEach
    public void setUp() {
        parser = new Parser();
    }

    /*
     * Note how the names of the test methods does not follow the normal naming convention.
     * That is because our coding standard allows a different naming convention for test methods.
     */

    @Test
    public void parse_emptyInput_returnsIncorrect() {
        final String[] emptyInputs = { """", ""  "", ""\n  \n"" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, emptyInputs);
    }

    @Test
    public void parse_unknownCommandWord_returnsHelp() {
        final String input = ""unknowncommandword arguments arguments"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    /*
     * Tests for 0-argument commands =======================================================================
     */

    @Test
    public void parse_helpCommand_parsedCorrectly() {
        final String input = ""help"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    @Test
    public void parse_clearCommand_parsedCorrectly() {
        final String input = ""clear"";
        parseAndAssertCommandType(input, ClearCommand.class);
    }

    @Test
    public void parse_listCommand_parsedCorrectly() {
        final String input = ""list"";
        parseAndAssertCommandType(input, ListCommand.class);
    }

    @Test
    public void parse_exitCommand_parsedCorrectly() {
        final String input = ""exit"";
        parseAndAssertCommandType(input, ExitCommand.class);
    }

    /*
     * Tests for single index argument commands ===============================================================
     */

    @Test
    public void parse_deleteCommandNoArgs_errorMessage() {
        final String[] inputs = { ""delete"", ""delete "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""delete notAnumber "", ""delete 8*wh12"", ""delete 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 1;
        final String input = ""delete "" + testIndex;
        final DeleteCommand result = parseAndAssertCommandType(input, DeleteCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void viewCommandNoArgs_errorMessage() {
        final String[] inputs = { ""view"", ""view "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""view notAnumber "", ""view 8*wh12"", ""view 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 2;
        final String input = ""view "" + testIndex;
        final ViewCommand result = parseAndAssertCommandType(input, ViewCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void parse_viewAllCommandNoArgs_errorMessage() {
        final String[] inputs = { ""viewall"", ""viewall "" };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewAllCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""viewall notAnumber "", ""viewall 8*wh12"", ""viewall 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 3;
        final String input = ""viewall "" + testIndex;
        final ViewAllCommand result = parseAndAssertCommandType(input, ViewAllCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    /*
     * Tests for find persons by keyword in name command ===================================================
     */

    @Test
    public void parse_findCommandInvalidArgs_errorMessage() {
        // no keywords
        final String[] inputs = {
            ""find"",
            ""find ""
        };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_findCommandValidArgs_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        final String input = ""find "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    @Test
    public void parse_findCommandDuplicateKeys_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        // duplicate every keyword
        final String input = ""find "" + String.join("" "", keySet) + "" "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    /*
     * Tests for add person command ==============================================================================
     */

    @Test
    public void parse_addCommandInvalidArgs_errorMessage() {
        final String[] inputs = {
            ""add"",
            ""add "",
            ""add wrong args format"",
            // no phone prefix
            String.format(""add %s %s e/%s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no email prefix
            String.format(""add %s p/%s %s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no address prefix
            String.format(""add %s p/%s e/%s %s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE)
        };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_addCommandInvalidPersonDataInArgs_errorMessge() {
        final String invalidName = ""[]\\[;]"";
        final String validName = Name.EXAMPLE;
        final String invalidPhoneArg = ""p/not__numbers"";
        final String validPhoneArg = ""p/"" + Phone.EXAMPLE;
        final String invalidEmailArg = ""e/notAnEmail123"";
        final String validEmailArg = ""e/"" + Email.EXAMPLE;
        final String invalidTagArg = ""t/invalid_-[.tag"";

        // address can be any string, so no invalid address
        final String addCommandFormatString = ""add %s %s %s a/"" + Address.EXAMPLE;

        // test each incorrect person data field argument individually
        final String[] inputs = {
                // invalid name
                String.format(addCommandFormatString, invalidName, validPhoneArg, validEmailArg),
                // invalid phone
                String.format(addCommandFormatString, validName, invalidPhoneArg, validEmailArg),
                // invalid email
                String.format(addCommandFormatString, validName, validPhoneArg, invalidEmailArg),
                // invalid tag
                String.format(addCommandFormatString, validName, validPhoneArg, validEmailArg) + "" "" + invalidTagArg
        };
        for (String input : inputs) {
            parseAndAssertCommandType(input, IncorrectCommand.class);
        }
    }

    @Test
    public void parse_addCommandValidPersonData_parsedCorrectly() {
        final Person testPerson = generateTestPerson();
        final String input = convertPersonToAddCommandString(testPerson);
        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    @Test
    public void parse_addCommandDuplicateTags_merged() throws IllegalValueException {
        final Person testPerson = generateTestPerson();
        String input = convertPersonToAddCommandString(testPerson);
        for (Tag tag : testPerson.getTags()) {
            // create duplicates by doubling each tag
            input += "" t/"" + tag.tagName;
        }

        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    private static Person generateTestPerson() {
        try {
            return new Person(
                new Name(Name.EXAMPLE),
                new Phone(Phone.EXAMPLE, true),
                new Email(Email.EXAMPLE, false),
                new Address(Address.EXAMPLE, true),
                new HashSet<>(Arrays.asList(new Tag(""tag1""), new Tag (""tag2""), new Tag(""tag3"")))
            );
        } catch (IllegalValueException ive) {
            throw new RuntimeException(""test person data should be valid by definition"");
        }
    }

    private static String convertPersonToAddCommandString(ReadOnlyPerson person) {
        String addCommand = ""add ""
                + person.getName().fullName
                + (person.getPhone().isPrivate() ? "" pp/"" : "" p/"") + person.getPhone().value
                + (person.getEmail().isPrivate() ? "" pe/"" : "" e/"") + person.getEmail().value
                + (person.getAddress().isPrivate() ? "" pa/"" : "" a/"") + person.getAddress().value;
        for (Tag tag : person.getTags()) {
            addCommand += "" t/"" + tag.tagName;
        }
        return addCommand;
    }

    /*
     * Utility methods ====================================================================================
     */

    /**
     * Asserts that parsing the given inputs will return IncorrectCommand with the given feedback message.
     */
    private void parseAndAssertIncorrectWithMessage(String feedbackMessage, String... inputs) {
        for (String input : inputs) {
            final IncorrectCommand result = parseAndAssertCommandType(input, IncorrectCommand.class);
            assertEquals(result.feedbackToUser, feedbackMessage);
        }
    }

    /**
     * Parses input and asserts the class/type of the returned command object.
     *
     * @param input to be parsed
     * @param expectedCommandClass expected class of returned command
     * @return the parsed command object
     */
    private <T extends Command> T parseAndAssertCommandType(String input, Class<T> expectedCommandClass) {
        final Command result = parser.parseCommand(input);
        assertTrue(result.getClass().isAssignableFrom(expectedCommandClass));
        return (T) result;
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.storage;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static seedu.addressbook.util.TestUtil.assertTextFilesEqual;
import static seedu.addressbook.util.TestUtil.assertFileDoesNotExist;

public class StorageFileTest {
    private static final String TEST_DATA_FOLDER = ""test/data/StorageFileTest"";
    private static final String NON_EXISTANT_FILE_NAME = ""ThisFileDoesNotExist.txt"";

    @TempDir
    public static Path testFolder;

    @Test
    public void constructor_nullFilePath_exceptionThrown() throws Exception {
        assertThrows(NullPointerException.class, () -> new StorageFile(null));
    }

    @Test
    public void constructor_noTxtExtension_exceptionThrown() throws Exception {
        assertThrows(IllegalValueException.class, () ->
                new StorageFile(TEST_DATA_FOLDER + ""/"" + ""InvalidfileName""));
    }

    @Test
    public void load_invalidFormat_exceptionThrown() throws Exception {
        // The file contains valid txt data, but does not match the Person format
        StorageFile storage = getStorage(""InvalidData.txt"");
        assertThrows(StorageOperationException.class, () -> storage.load());
    }

    @Test
    public void load_validFormat() throws Exception {
        AddressBook actualAB = getStorage(""ValidData.txt"").load();
        AddressBook expectedAB = getTestAddressBook();

        // ensure loaded AddressBook is properly constructed with test data
        // TODO: overwrite equals method in AddressBook class and replace with equals method below
        assertEquals(actualAB.getAllPersons(), expectedAB.getAllPersons());
    }

    @Test
    public void load_nonExistantFile_returnsEmptyAddressBook() throws Exception {
        AddressBook actualAB = getStorage(NON_EXISTANT_FILE_NAME).load();
        AddressBook expectedAB = new AddressBook();

        assertEquals(actualAB, expectedAB);

        // verify that loading does not result in the file being created
        assertFileDoesNotExist(TEST_DATA_FOLDER + ""/"" + NON_EXISTANT_FILE_NAME);
    }

    @Test
    public void save_nullAddressBook_exceptionThrown() throws Exception {
        StorageFile storage = getTempStorage();
        assertThrows(NullPointerException.class, () -> storage.save(null));
    }

    @Test
    public void save_validAddressBook() throws Exception {
        AddressBook ab = getTestAddressBook();
        StorageFile storage = getTempStorage();
        storage.save(ab);

        assertStorageFilesEqual(storage, getStorage(""ValidData.txt""));
    }

    // getPath() method in StorageFile class is trivial so it is not tested

    /**
     * Asserts that the contents of two storage files are the same.
     */
    private void assertStorageFilesEqual(StorageFile sf1, StorageFile sf2) throws Exception {
        assertTextFilesEqual(Paths.get(sf1.getPath()), Paths.get(sf2.getPath()));
    }

    private StorageFile getStorage(String fileName) throws Exception {
        return new StorageFile(TEST_DATA_FOLDER + ""/"" + fileName);
    }

    private StorageFile getTempStorage() throws Exception {
        return new StorageFile(testFolder.resolve(""temp.txt"").toString());
    }

    private AddressBook getTestAddressBook() throws Exception {
        AddressBook ab = new AddressBook();
        ab.addPerson(new Person(new Name(""John Doe""),
                                new Phone(""98765432"", false),
                                new Email(""johnd@gmail.com"", false),
                                new Address(""John street, block 123, #01-01"", false),
                                Collections.emptySet()));
        ab.addPerson(new Person(new Name(""Betsy Crowe""),
                                new Phone(""1234567"", true),
                                new Email(""betsycrowe@gmail.com"", false),
                                new Address(""Newgate Prison"", true),
                                new HashSet<>(Arrays.asList(new Tag(""friend""), new Tag(""criminal"")))));
        return ab;
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.common;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.Arrays;
import java.util.List;

import org.junit.jupiter.api.Test;

public class UtilsTest {


    @Test
    public void elementsAreUnique() throws Exception {
        // empty list
        assertAreUnique();

        // only one object
        assertAreUnique((Object) null);
        assertAreUnique(1);
        assertAreUnique("""");
        assertAreUnique(""abc"");

        // all objects unique
        assertAreUnique(""abc"", ""ab"", ""a"");
        assertAreUnique(1, 2);

        // some identical objects
        assertNotUnique(""abc"", ""abc"");
        assertNotUnique(""abc"", """", ""abc"", ""ABC"");
        assertNotUnique("""", ""abc"", ""a"", ""abc"");
        assertNotUnique(1, Integer.valueOf(1));
        assertNotUnique(null, 1, Integer.valueOf(1));
        assertNotUnique(null, null);
        assertNotUnique(null, ""a"", ""b"", null);
    }

    @Test
    public void isAnyNull() {
        // no items
        assertFalse(Utils.isAnyNull());

        // varargs array that is null (i.e. no array)
        assertFalse(Utils.isAnyNull((Object[]) null));

        // one item which is null (i.e. an array with one null item)
        assertTrue(Utils.isAnyNull((Object) null));

        // at least one item, none of which are null
        assertFalse(Utils.isAnyNull(""A""));
        assertFalse(Utils.isAnyNull(""A"", """"));
        assertFalse(Utils.isAnyNull(1, 2, ""C""));

        // at least one item, some of which are null
        assertTrue(Utils.isAnyNull(null, 1));
        assertTrue(Utils.isAnyNull(""A"", null, ""C""));
    }

    private void assertAreUnique(Object... objects) {
        assertTrue(Utils.elementsAreUnique(Arrays.asList(objects)));
    }

    private void assertNotUnique(Object... objects) {
        assertFalse(Utils.elementsAreUnique(Arrays.asList(objects)));
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.ui.TextUi;
import seedu.addressbook.util.TestUtil;

public class DeleteCommandTest {

    private AddressBook emptyAddressBook;
    private AddressBook addressBook;

    private List<ReadOnlyPerson> emptyDisplayList;
    private List<ReadOnlyPerson> listWithEveryone;
    private List<ReadOnlyPerson> listWithSurnameDoe;

    @BeforeEach
    public void setUp() throws Exception {
        Person johnDoe = new Person(new Name(""John Doe""), new Phone(""61234567"", false),
                new Email(""john@doe.com"", false), new Address(""395C Ben Road"", false), Collections.emptySet());
        Person janeDoe = new Person(new Name(""Jane Doe""), new Phone(""91234567"", false),
                new Email(""jane@doe.com"", false), new Address(""33G Ohm Road"", false), Collections.emptySet());
        Person samDoe = new Person(new Name(""Sam Doe""), new Phone(""63345566"", false),
                new Email(""sam@doe.com"", false), new Address(""55G Abc Road"", false), Collections.emptySet());
        Person davidGrant = new Person(new Name(""David Grant""), new Phone(""61121122"", false),
                new Email(""david@grant.com"", false), new Address(""44H Define Road"", false),
                Collections.emptySet());

        emptyAddressBook = TestUtil.createAddressBook();
        addressBook = TestUtil.createAddressBook(johnDoe, janeDoe, davidGrant, samDoe);

        emptyDisplayList = TestUtil.createList();

        listWithEveryone = TestUtil.createList(johnDoe, janeDoe, davidGrant, samDoe);
        listWithSurnameDoe = TestUtil.createList(johnDoe, janeDoe, samDoe);
    }

    @Test
    public void execute_emptyAddressBook_returnsPersonNotFoundMessage() {
        assertDeletionFailsDueToNoSuchPerson(1, emptyAddressBook, listWithEveryone);
    }

    @Test
    public void execute_noPersonDisplayed_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(1, addressBook, emptyDisplayList);
    }

    @Test
    public void execute_targetPersonNotInAddressBook_returnsPersonNotFoundMessage()
            throws IllegalValueException {
        Person notInAddressBookPerson = new Person(new Name(""Not In Book""), new Phone(""63331444"", false),
                new Email(""notin@book.com"", false), new Address(""156D Grant Road"", false), Collections.emptySet());
        List<ReadOnlyPerson> listWithPersonNotInAddressBook = TestUtil.createList(notInAddressBookPerson);

        assertDeletionFailsDueToNoSuchPerson(1, addressBook, listWithPersonNotInAddressBook);
    }

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(0, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(-1, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(listWithEveryone.size() + 1, addressBook, listWithEveryone);
    }

    @Test
    public void execute_validIndex_personIsDeleted() throws PersonNotFoundException {
        assertDeletionSuccessful(1, addressBook, listWithSurnameDoe);
        assertDeletionSuccessful(listWithSurnameDoe.size(), addressBook, listWithSurnameDoe);

        int middleIndex = (listWithSurnameDoe.size() / 2) + 1;
        assertDeletionSuccessful(middleIndex, addressBook, listWithSurnameDoe);
    }

    /**
     * Creates a new delete command.
     *
     * @param targetVisibleIndex of the person that we want to delete
     */
    private DeleteCommand createDeleteCommand(int targetVisibleIndex, AddressBook addressBook,
                                                                      List<ReadOnlyPerson> displayList) {

        DeleteCommand command = new DeleteCommand(targetVisibleIndex);
        command.setData(addressBook, displayList);

        return command;
    }

    /**
     * Executes the command, and checks that the execution was what we had expected.
     */
    private void assertCommandBehaviour(DeleteCommand deleteCommand, String expectedMessage,
                                        AddressBook expectedAddressBook, AddressBook actualAddressBook) {

        CommandResult result = deleteCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedAddressBook.getAllPersons(), actualAddressBook.getAllPersons());
    }

    /**
     * Asserts that the index is not valid for the given display list.
     */
    private void assertDeletionFailsDueToInvalidIndex(int invalidVisibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

        DeleteCommand command = createDeleteCommand(invalidVisibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index cannot be deleted, because that person
     * is not in the address book.
     */
    private void assertDeletionFailsDueToNoSuchPerson(int visibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK;

        DeleteCommand command = createDeleteCommand(visibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index can be successfully deleted.
     *
     * The addressBook passed in will not be modified (no side effects).
     *
     * @throws PersonNotFoundException if the selected person is not in the address book
     */
    private void assertDeletionSuccessful(int targetVisibleIndex, AddressBook addressBook,
                                          List<ReadOnlyPerson> displayList) throws PersonNotFoundException {

        ReadOnlyPerson targetPerson = displayList.get(targetVisibleIndex - TextUi.DISPLAYED_INDEX_OFFSET);

        AddressBook expectedAddressBook = TestUtil.clone(addressBook);
        expectedAddressBook.removePerson(targetPerson);
        String expectedMessage = String.format(DeleteCommand.MESSAGE_DELETE_PERSON_SUCCESS, targetPerson);

        AddressBook actualAddressBook = TestUtil.clone(addressBook);

        DeleteCommand command = createDeleteCommand(targetVisibleIndex, actualAddressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, expectedAddressBook, actualAddressBook);
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

public class ViewAllCommandTest {
    // ViewAllCommand is tested together with ViewCommand in ViewCommandTest.
    // This is because they function similarly but ViewCommand hides private information.
    // They are tested with same test data input.
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TestUtil;
import seedu.addressbook.util.TypicalPersons;

public class ViewCommandTest {
    private TypicalPersons td = new TypicalPersons();

    private AddressBook typicalAddressBook = td.getTypicalAddressBook();
    private AddressBook emptyAddressBook = TestUtil.createAddressBook();
    private List<ReadOnlyPerson> emptyPersonList = Collections.emptyList();
    private List<ReadOnlyPerson> listWithAllTypicalPersons = Arrays.asList(td.getTypicalPersons());
    private List<ReadOnlyPerson> listWithSomeTypicalPersons = Arrays.asList(td.amy, td.candy, td.dan);

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        // empty addressbook
        assertViewErrorInvalidIndex(emptyAddressBook, emptyPersonList, 1);

        // non-empty addressbook
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, -1);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, 0);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons,
                                              listWithAllTypicalPersons.size() + 1);
    }

    @Test
    public void execute_personNotInAddressBook_returnsPersonNotInAddressBookMessage() throws Exception {
        // generate list with person not in addressbook, add to list
        ReadOnlyPerson stranger = new Person(new Name(""me""),
                                             new Phone(""123"", true),
                                             new Email(""some@hey.go"", true),
                                             new Address(""nus"", false),
                                             Collections.emptySet());
        List<ReadOnlyPerson> listWithExtraPerson
                = new ArrayList<ReadOnlyPerson>(listWithAllTypicalPersons);
        listWithExtraPerson.add(stranger);

        // empty addressbook
        assertViewErrorPersonNotInAddressBook(emptyAddressBook, listWithExtraPerson, 1);

        // non-empty addressbook
        assertViewErrorPersonNotInAddressBook(typicalAddressBook, listWithExtraPerson,
                                                            listWithExtraPerson.size());
    }

    @Test
    public void execute_validIndex_returnsPersonDetails() {
        // person with no private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 1);

        // person with some private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 2);

        // person with all private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 4);

        // Addressbook has more people than the list.
        // This can happen when a command causes the list to show only a sub-set of persons(e.g. FindCommand).
        assertViewSuccess(typicalAddressBook, listWithSomeTypicalPersons, 1);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * invalid index.
     */
    private void assertViewErrorInvalidIndex(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                     int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                          Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * person not existing in the addressbook.
     */
    private void assertViewErrorPersonNotInAddressBook(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                               int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                               Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
    }

    /**
     * Asserts that both a ViewCommand and a ViewAllCommand can retrieve from
     * the {@code addressBook} details of the person at the given {@code targetVisibleIndex}
     * in the given {@code relevantPersons} list.
     *
     * @param targetVisibleIndex one-indexed position of the target person in the list
     */
    private void assertViewSuccess(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                           int targetVisibleIndex) {
        // get person to be viewed (targetVisibleIndex - 1 because index is one-indexed)
        ReadOnlyPerson personToBeViewed = relevantPersons.get(targetVisibleIndex - 1);

        String expectedMessage = String.format(ViewCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextHidePrivate());
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);

        expectedMessage = String.format(ViewAllCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextShowAll());
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Asserts that the Viewcommand and ViewAllcommand reports the given error for the given input.
     */
    private static void assertViewError(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                        int targetVisibleIndex, String expectedMessage) {
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Executes the test command for the given addressbook data.
     * Checks that ViewCommand and ViewAllCommand exhibits the correct command behavior, namely:
     * 1. The feedback message of the CommandResult it returns matches expectedMessage.
     * 2. The CommandResult it returns has no relevant persons.
     * 3. The original addressbook data is not modified after executing ViewCommand and ViewAllCommand.
     */
    private static void assertViewBehavior(Command viewCommand, AddressBook addressBook,
                                           List<ReadOnlyPerson> relevantPersons, String expectedMessage) {
        AddressBook expectedAddressBook = TestUtil.clone(addressBook);

        viewCommand.setData(addressBook, relevantPersons);
        CommandResult result = viewCommand.execute();

        // feedback message is as expected and there are no relevant persons returned.
        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(Optional.empty(), result.getRelevantPersons());

        // addressbook was not modified.
        assertEquals(expectedAddressBook.getAllPersons(), addressBook.getAllPersons());
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TypicalPersons;

public class FindCommandTest {

    private final AddressBook addressBook = new TypicalPersons().getTypicalAddressBook();
    private final TypicalPersons td = new TypicalPersons();

    @Test
    public void execute() throws IllegalValueException {
        //same word, same case: matched
        assertFindCommandBehavior(new String[]{""Amy""}, Arrays.asList(td.amy));

        //same word, different case: not matched
        assertFindCommandBehavior(new String[]{""aMy""}, Collections.emptyList());

        //partial word: not matched
        assertFindCommandBehavior(new String[]{""my""}, Collections.emptyList());

        //multiple words: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Bill"", ""Candy"", ""Destiny""},
                Arrays.asList(td.amy, td.bill, td.candy));

        //repeated keywords: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Amy""}, Arrays.asList(td.amy));

        //Keyword matching a word in address: not matched
        assertFindCommandBehavior(new String[]{""Clementi""}, Collections.emptyList());
    }

    /**
     * Executes the find command for the given keywords and verifies
     * the result matches the persons in the expectedPersonList exactly.
     */
    private void assertFindCommandBehavior(String[] keywords, List<ReadOnlyPerson> expectedPersonList) {
        FindCommand command = createFindCommand(keywords);
        CommandResult result = command.execute();

        assertEquals(Command.getMessageForPersonListShownSummary(expectedPersonList), result.feedbackToUser);
    }

    private FindCommand createFindCommand(String[] keywords) {
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        FindCommand command = new FindCommand(keywordSet);
        command.setData(addressBook, Collections.emptyList());
        return command;
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.jupiter.api.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.util.TestUtil;

public class AddCommandTest {
    private static final List<ReadOnlyPerson> EMPTY_PERSON_LIST = Collections.emptyList();
    private static final Set<String> EMPTY_STRING_SET = Collections.emptySet();

    @Test
    public void addCommand_invalidName_throwsException() {
        final String[] invalidNames = { """", "" "", ""[]\\[;]"" };
        for (String name : invalidNames) {
            assertConstructingInvalidAddCmdThrowsException(name, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                    Address.EXAMPLE, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidPhone_throwsException() {
        final String[] invalidNumbers = { """", "" "", ""1234-5678"", ""[]\\[;]"", ""abc"", ""a123"", ""+651234"" };
        for (String number : invalidNumbers) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, number, false, Email.EXAMPLE, true,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidEmail_throwsException() {
        final String[] invalidEmails = { """", "" "", ""def.com"", ""@"", ""@def"", ""@def.com"", ""abc@"",
                                         ""@invalid@email"", ""invalid@email!"", ""!invalid@email"" };
        for (String email : invalidEmails) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, false, email, false,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidAddress_throwsException() {
        final String[] invalidAddresses = { """", "" "" };
        for (String address : invalidAddresses) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, address, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidTags_throwsException() {
        final String[][] invalidTags = { { """" }, { "" "" }, { ""'"" }, { ""[]\\[;]"" }, { ""validTag"", """" },
                                         { """", "" "" } };
        for (String[] tags : invalidTags) {
            Set<String> tagsToAdd = new HashSet<>(Arrays.asList(tags));
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, Address.EXAMPLE, false, tagsToAdd);
        }
    }

    /**
     * Asserts that attempting to construct an add command with the supplied
     * invalid data throws an IllegalValueException
     */
    private void assertConstructingInvalidAddCmdThrowsException(String name, String phone,
            boolean isPhonePrivate, String email, boolean isEmailPrivate, String address,
            boolean isAddressPrivate, Set<String> tags) {
        try {
            new AddCommand(name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate,
                    tags);
        } catch (IllegalValueException e) {
            return;
        }
        String error = String.format(
                ""An add command was successfully constructed with invalid input: %s %s %s %s %s %s %s %s"",
                name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate, tags);
        fail(error);
    }

    @Test
    public void addCommand_validData_correctlyConstructed() throws Exception {
        AddCommand command = new AddCommand(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                Address.EXAMPLE, true, EMPTY_STRING_SET);
        ReadOnlyPerson p = command.getPerson();

        // TODO: add comparison of tags to person.equals and equality methods to
        // individual fields that compare privacy to simplify this
        assertEquals(Name.EXAMPLE, p.getName().fullName);
        assertEquals(Phone.EXAMPLE, p.getPhone().value);
        assertTrue(p.getPhone().isPrivate());
        assertEquals(Email.EXAMPLE, p.getEmail().value);
        assertFalse(p.getEmail().isPrivate());
        assertEquals(Address.EXAMPLE, p.getAddress().value);
        assertTrue(p.getAddress().isPrivate());
        boolean isTagListEmpty = !p.getTags().iterator().hasNext();
        assertTrue(isTagListEmpty);
    }

    @Test
    public void addCommand_emptyAddressBook_addressBookContainsPerson() {
        Person p = TestUtil.generateTestPerson();
        AddCommand command = new AddCommand(p);
        AddressBook book = new AddressBook();
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();
        UniquePersonList people = book.getAllPersons();

        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS, p), result.feedbackToUser);
    }

    @Test
    public void addCommand_addressBookAlreadyContainsPerson_addressBookUnmodified() throws Exception {
        Person p = TestUtil.generateTestPerson();
        AddressBook book = new AddressBook();
        book.addPerson(p);
        AddCommand command = new AddCommand(p);
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();

        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(AddCommand.MESSAGE_DUPLICATE_PERSON, result.feedbackToUser);
        UniquePersonList people = book.getAllPersons();
        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static seedu.addressbook.util.TestUtil.getSize;
import static seedu.addressbook.util.TestUtil.isEmpty;
import static seedu.addressbook.util.TestUtil.isIdentical;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.data.tag.Tag;

public class AddressBookTest {
    private Tag tagPrizeWinner;
    private Tag tagScientist;
    private Tag tagMathematician;
    private Tag tagEconomist;

    private Person aliceBetsy;
    private Person bobChaplin;
    private Person charlieDouglas;
    private Person davidElliot;

    private AddressBook defaultAddressBook;
    private AddressBook emptyAddressBook;


    @BeforeEach
    public void setUp() throws Exception {
        tagPrizeWinner   = new Tag(""prizewinner"");
        tagScientist     = new Tag(""scientist"");
        tagMathematician = new Tag(""mathematician"");
        tagEconomist     = new Tag(""economist"");

        aliceBetsy     = new Person(new Name(""Alice Betsy""),
                                    new Phone(""91235468"", false),
                                    new Email(""alice@nushackers.org"", false),
                                    new Address(""8 Computing Drive, Singapore"", false),
                                    Collections.singleton(tagMathematician));

        bobChaplin     = new Person(new Name(""Bob Chaplin""),
                                    new Phone(""94321500"", false),
                                    new Email(""bob@nusgreyhats.org"", false),
                                    new Address(""9 Computing Drive"", false),
                                    Collections.singleton(tagMathematician));

        charlieDouglas = new Person(new Name(""Charlie Douglas""),
                                    new Phone(""98751365"", false),
                                    new Email(""charlie@nusgdg.org"", false),
                                    new Address(""10 Science Drive"", false),
                                    Collections.singleton(tagScientist));

        davidElliot    = new Person(new Name(""David Elliot""),
                                    new Phone(""84512575"", false),
                                    new Email(""douglas@nuscomputing.com"", false),
                                    new Address(""11 Arts Link"", false),
                                    new HashSet<>(Arrays.asList(tagEconomist, tagPrizeWinner)));

        emptyAddressBook = new AddressBook();
        defaultAddressBook = new AddressBook(new UniquePersonList(aliceBetsy, bobChaplin));
    }

    @Test
    public void addPerson_personAlreadyInList_throwsDuplicatePersonException() {
        assertThrows(DuplicatePersonException.class, () -> defaultAddressBook.addPerson(aliceBetsy));
    }

    @Test
    public void containsPerson() throws Exception {
        UniquePersonList personsWhoShouldBeIn = new UniquePersonList(aliceBetsy, bobChaplin);
        UniquePersonList personsWhoShouldNotBeIn = new UniquePersonList(charlieDouglas, davidElliot);

        for (Person personWhoShouldBeIn : personsWhoShouldBeIn) {
            assertTrue(defaultAddressBook.containsPerson(personWhoShouldBeIn));
        }
        for (Person personWhoShouldNotBeIn : personsWhoShouldNotBeIn) {
            assertFalse(defaultAddressBook.containsPerson(personWhoShouldNotBeIn));
        }

        UniquePersonList allPersons = new UniquePersonList(aliceBetsy, bobChaplin, charlieDouglas, davidElliot);

        for (Person person : allPersons) {
            assertFalse(emptyAddressBook.containsPerson(person));
        }
    }

    @Test
    public void removePerson_personExists_removesNormally() throws Exception {
        int numberOfPersonsBeforeRemoval = getSize(defaultAddressBook.getAllPersons());
        defaultAddressBook.removePerson(aliceBetsy);

        assertFalse(defaultAddressBook.containsPerson(aliceBetsy));

        int numberOfPersonsAfterRemoval = getSize(defaultAddressBook.getAllPersons());
        assertTrue(numberOfPersonsAfterRemoval == numberOfPersonsBeforeRemoval - 1);

    }

    @Test
    public void removePerson_personNotExists_throwsPersonNotFoundException() {
        assertThrows(PersonNotFoundException.class, () -> defaultAddressBook.removePerson(charlieDouglas));
    }

    @Test
    public void clear() {
        defaultAddressBook.clear();

        assertTrue(isEmpty(defaultAddressBook.getAllPersons()));
    }

    @Test
    public void getAllPersons() throws Exception {
        UniquePersonList allPersons = defaultAddressBook.getAllPersons();
        UniquePersonList personsToCheck = new UniquePersonList(aliceBetsy, bobChaplin);

        assertTrue(isIdentical(allPersons, personsToCheck));
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.parser.Parser;
import seedu.addressbook.storage.StorageFile;
import seedu.addressbook.storage.StorageFile.InvalidStorageFilePathException;
import seedu.addressbook.storage.StorageFile.StorageOperationException;
import seedu.addressbook.ui.TextUi;


/**
 * Entry point of the Address Book application.
 * Initializes the application and starts the interaction with the user.
 */
public class Main {

    /** Version info of the program. */
    public static final String VERSION = ""AddressBook Level 2 - Version 1.0"";

    private TextUi ui;
    private StorageFile storage;
    private AddressBook addressBook;

    /** The list of person shown to the user most recently.  */
    private List<? extends ReadOnlyPerson> lastShownList = Collections.emptyList();


    public static void main(String... launchArgs) {
        new Main().run(launchArgs);
    }

    /** Runs the program until termination.  */
    public void run(String[] launchArgs) {
        start(launchArgs);
        runCommandLoopUntilExitCommand();
        exit();
    }

    /**
     * Sets up the required objects, loads up the data from the storage file, and prints the welcome message.
     *
     * @param launchArgs arguments supplied by the user at program launch
     *
     */
    private void start(String[] launchArgs) {
        try {
            this.ui = new TextUi();
            this.storage = initializeStorage(launchArgs);
            this.addressBook = storage.load();
            ui.showWelcomeMessage(VERSION, storage.getPath());

        } catch (InvalidStorageFilePathException | StorageOperationException e) {
            ui.showInitFailedMessage();
            /*
             * ==============NOTE TO STUDENTS=========================================================================
             * We are throwing a RuntimeException which is an 'unchecked' exception. Unchecked exceptions do not need
             * to be declared in the method signature.
             * The reason we are using an unchecked exception here is because the caller cannot reasonably be expected
             * to recover from an exception.
             * Cf https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html
             * =======================================================================================================
             */
            throw new RuntimeException(e);
        }
    }

    /** Prints the Goodbye message and exits. */
    private void exit() {
        ui.showGoodbyeMessage();
        System.exit(0);
    }

    /** Reads the user command and executes it, until the user issues the exit command.  */
    private void runCommandLoopUntilExitCommand() {
        Command command;
        do {
            String userCommandText = ui.getUserCommand();
            command = new Parser().parseCommand(userCommandText);
            CommandResult result = executeCommand(command);
            recordResult(result);
            ui.showResultToUser(result);

        } while (!ExitCommand.isExit(command));
    }

    /** Updates the {@link #lastShownList} if the result contains a list of Persons. */
    private void recordResult(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> personList = result.getRelevantPersons();
        if (personList.isPresent()) {
            lastShownList = personList.get();
        }
    }

    /**
     * Executes the command and returns the result.
     *
     * @param command user command
     * @return result of the command
     */
    private CommandResult executeCommand(Command command)  {
        try {
            command.setData(addressBook, lastShownList);
            CommandResult result = command.execute();
            storage.save(addressBook);
            return result;
        } catch (Exception e) {
            ui.showToUser(e.getMessage());
            throw new RuntimeException(e);
        }
    }

    /**
     * Creates the StorageFile object based on the user specified path (if any) or the default storage path.
     * @param launchArgs arguments supplied by the user at program launch
     * @throws InvalidStorageFilePathException if the target file path is incorrect.
     */
    private StorageFile initializeStorage(String[] launchArgs) throws InvalidStorageFilePathException {
        boolean isStorageFileSpecifiedByUser = launchArgs.length > 0;
        return isStorageFileSpecifiedByUser ? new StorageFile(launchArgs[0]) : new StorageFile();
    }


}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.ui;

import static seedu.addressbook.common.Messages.MESSAGE_GOODBYE;
import static seedu.addressbook.common.Messages.MESSAGE_INIT_FAILED;
import static seedu.addressbook.common.Messages.MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE;
import static seedu.addressbook.common.Messages.MESSAGE_USING_STORAGE_FILE;
import static seedu.addressbook.common.Messages.MESSAGE_WELCOME;

import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Scanner;

import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Text UI of the application.
 */
public class TextUi {

    /** A decorative prefix added to the beginning of lines printed by AddressBook */
    private static final String LINE_PREFIX = ""|| "";

    /** A platform independent line separator. */
    private static final String LS = System.lineSeparator();

    private static final String DIVIDER = ""==================================================="";

    /** Format of indexed list item */
    private static final String MESSAGE_INDEXED_LIST_ITEM = ""\t%1$d. %2$s"";


    /** Offset required to convert between 1-indexing and 0-indexing.  */
    public static final int DISPLAYED_INDEX_OFFSET = 1;

    /** Format of a comment input line. Comment lines are silently consumed when reading user input. */
    private static final String COMMENT_LINE_FORMAT_REGEX = ""#.*"";

    private final Scanner in;
    private final PrintStream out;

    public TextUi() {
        this(System.in, System.out);
    }

    public TextUi(InputStream in, PrintStream out) {
        this.in = new Scanner(in);
        this.out = out;
    }

    /**
     * Returns true if the user input line should be ignored.
     * Input should be ignored if it is parsed as a comment, is only whitespace, or is empty.
     *
     * @param rawInputLine full raw user input line.
     * @return true if the entire user input line should be ignored.
     */
    private boolean shouldIgnore(String rawInputLine) {
        return rawInputLine.trim().isEmpty() || isCommentLine(rawInputLine);
    }

    /**
     * Returns true if the user input line is a comment line.
     *
     * @param rawInputLine full raw user input line.
     * @return true if input line is a comment.
     */
    private boolean isCommentLine(String rawInputLine) {
        return rawInputLine.trim().matches(COMMENT_LINE_FORMAT_REGEX);
    }

    /**
     * Prompts for the command and reads the text entered by the user.
     * Ignores empty, pure whitespace, and comment lines.
     * Echos the command back to the user.
     * @return command (full line) entered by the user
     */
    public String getUserCommand() {
        out.print(LINE_PREFIX + ""Enter command: "");
        String fullInputLine = in.nextLine();

        // silently consume all ignored lines
        while (shouldIgnore(fullInputLine)) {
            fullInputLine = in.nextLine();
        }

        showToUser(""[Command entered:"" + fullInputLine + ""]"");
        return fullInputLine;
    }


    public void showWelcomeMessage(String version, String storageFilePath) {
        String storageFileInfo = String.format(MESSAGE_USING_STORAGE_FILE, storageFilePath);
        showToUser(
                DIVIDER,
                DIVIDER,
                MESSAGE_WELCOME,
                version,
                MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE,
                storageFileInfo,
                DIVIDER);
    }

    public void showGoodbyeMessage() {
        showToUser(MESSAGE_GOODBYE, DIVIDER, DIVIDER);
    }


    public void showInitFailedMessage() {
        showToUser(MESSAGE_INIT_FAILED, DIVIDER, DIVIDER);
    }

    /** Shows message(s) to the user */
    public void showToUser(String... message) {
        for (String m : message) {
            out.println(LINE_PREFIX + m.replace(""\n"", LS + LINE_PREFIX));
        }
    }

    /**
     * Shows the result of a command execution to the user. Includes additional formatting to demarcate different
     * command execution segments.
     */
    public void showResultToUser(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> resultPersons = result.getRelevantPersons();
        if (resultPersons.isPresent()) {
            showPersonListView(resultPersons.get());
        }
        showToUser(result.feedbackToUser, DIVIDER);
    }

    /**
     * Shows a list of persons to the user, formatted as an indexed list.
     * Private contact details are hidden.
     */
    private void showPersonListView(List<? extends ReadOnlyPerson> persons) {
        final List<String> formattedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : persons) {
            formattedPersons.add(person.getAsTextHidePrivate());
        }
        showToUserAsIndexedList(formattedPersons);
    }

    /** Shows a list of strings to the user, formatted as an indexed list. */
    private void showToUserAsIndexedList(List<String> list) {
        showToUser(getIndexedListForViewing(list));
    }

    /** Formats a list of strings as a viewable indexed list. */
    private static String getIndexedListForViewing(List<String> listItems) {
        final StringBuilder formatted = new StringBuilder();
        int displayIndex = 0 + DISPLAYED_INDEX_OFFSET;
        for (String listItem : listItems) {
            formatted.append(getIndexedListItem(displayIndex, listItem)).append(""\n"");
            displayIndex++;
        }
        return formatted.toString();
    }

    /**
     * Formats a string as a viewable indexed list item.
     *
     * @param visibleIndex visible index for this listing
     */
    private static String getIndexedListItem(int visibleIndex, String listItem) {
        return String.format(MESSAGE_INDEXED_LIST_ITEM, visibleIndex, listItem);
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.parser;

import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Parses user input.
 */
public class Parser {

    public static final Pattern PERSON_INDEX_ARGS_FORMAT = Pattern.compile(""(?<targetIndex>.+)"");

    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile(""(?<keywords>\\S+(?:\\s+\\S+)*)""); // one or more keywords separated by whitespace

    public static final Pattern PERSON_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile(""(?<name>[^/]+)""
                    + "" (?<isPhonePrivate>p?)p/(?<phone>[^/]+)""
                    + "" (?<isEmailPrivate>p?)e/(?<email>[^/]+)""
                    + "" (?<isAddressPrivate>p?)a/(?<address>[^/]+)""
                    + ""(?<tagArguments>(?: t/[^/]+)*)""); // variable number of tags


    /**
     * Used for initial separation of command word and args.
     */
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile(""(?<commandWord>\\S+)(?<arguments>.*)"");

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group(""commandWord"");
        final String arguments = matcher.group(""arguments"");

        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return prepareFind(arguments);

        case ListCommand.COMMAND_WORD:
            return new ListCommand();

        case ViewCommand.COMMAND_WORD:
            return prepareView(arguments);

        case ViewAllCommand.COMMAND_WORD:
            return prepareViewAll(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD: // Fallthrough
        default:
            return new HelpCommand();
        }
    }

    /**
     * Parses arguments in the context of the add person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return new AddCommand(
                    matcher.group(""name""),

                    matcher.group(""phone""),
                    isPrivatePrefixPresent(matcher.group(""isPhonePrivate"")),

                    matcher.group(""email""),
                    isPrivatePrefixPresent(matcher.group(""isEmailPrivate"")),

                    matcher.group(""address""),
                    isPrivatePrefixPresent(matcher.group(""isAddressPrivate"")),

                    getTagsFromArgs(matcher.group(""tagArguments""))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Returns true if the private prefix is present for a contact detail in the add command's arguments string.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return matchedPrefix.equals(""p"");
    }

    /**
     * Extracts the new person's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst("" t/"", """").split("" t/""));
        return new HashSet<>(tagStrings);
    }


    /**
     * Parses arguments in the context of the delete person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new DeleteCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view all command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareViewAll(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewAllCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewAllCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses the given arguments string as a single index number.
     *
     * @param args arguments string to parse as index number
     * @return the parsed index number
     * @throws ParseException if no region of the args string could be found for the index
     * @throws NumberFormatException the args string region is not a valid number
     */
    private int parseArgsAsDisplayedIndex(String args) throws ParseException, NumberFormatException {
        final Matcher matcher = PERSON_INDEX_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            throw new ParseException(""Could not find index number to parse"");
        }
        return Integer.parseInt(matcher.group(""targetIndex""));
    }


    /**
     * Parses arguments in the context of the find person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group(""keywords"").split(""\\s+"");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    /**
     * Signals that the user input could not be parsed.
     */
    public static class ParseException extends Exception {
        ParseException(String message) {
            super(message);
        }
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.storage;

import static seedu.addressbook.parser.Parser.PERSON_DATA_ARGS_FORMAT;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

/**
 * Decodes the storage data file into an {@code AddressBook} object.
 */
public class AddressBookDecoder {

    /**
     * Decodes {@code encodedAddressBook} into an {@code AddressBook} containing the decoded persons.
     *
     * @throws IllegalValueException if any of the fields in any encoded person string is invalid.
     * @throws StorageOperationException if the {@code encodedAddressBook} is in an invalid format.
     */
    public static AddressBook decodeAddressBook(List<String> encodedAddressBook)
            throws IllegalValueException, StorageOperationException {
        final List<Person> decodedPersons = new ArrayList<>();
        for (String encodedPerson : encodedAddressBook) {
            decodedPersons.add(decodePersonFromString(encodedPerson));
        }
        return new AddressBook(new UniquePersonList(decodedPersons));
    }

    /**
     * Decodes {@code encodedPerson} into a {@code Person}.
     *
     * @throws IllegalValueException if any field in the {@code encodedPerson} is invalid.
     * @throws StorageOperationException if {@code encodedPerson} is in an invalid format.
     */
    private static Person decodePersonFromString(String encodedPerson)
            throws IllegalValueException, StorageOperationException {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(encodedPerson);
        if (!matcher.matches()) {
            throw new StorageOperationException(""Encoded person in invalid format. Unable to decode."");
        }

        return new Person(
                new Name(matcher.group(""name"")),
                new Phone(matcher.group(""phone""), isPrivatePrefixPresent(matcher.group(""isPhonePrivate""))),
                new Email(matcher.group(""email""), isPrivatePrefixPresent(matcher.group(""isEmailPrivate""))),
                new Address(matcher.group(""address""), isPrivatePrefixPresent(matcher.group(""isAddressPrivate""))),
                getTagsFromEncodedPerson(matcher.group(""tagArguments""))
        );
    }

    /**
     * Returns true if {@code matchedPrefix} is equal to the private prefix for contact details.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return ""p"".equals(matchedPrefix);
    }

    /**
     * Extracts the {@code Tag}s from the {@code tagArguments} string.
     * Merges duplicate tag strings.
     */
    private static Set<Tag> getTagsFromEncodedPerson(String tagArguments) throws IllegalValueException {
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }

        // replace first delimiter prefix, then split
        final String[] tagStrings = tagArguments.replaceFirst("" t/"", """").split("" t/"");
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tagStrings) {
            tagSet.add(new Tag(tagName));
        }

        return tagSet;
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.storage;

import java.util.ArrayList;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Person;

/**
 * Encodes the {@code AddressBook} object into a data file for storage.
 */
public class AddressBookEncoder {

    /**
     * Encodes all the {@code Person} in the {@code toSave} into a list of decodable and readable string presentation
     * for storage.
     */
    public static List<String> encodeAddressBook(AddressBook toSave) {
        final List<String> encodedPersons = new ArrayList<>();
        toSave.getAllPersons().forEach(person -> encodedPersons.add(encodePersonToString(person)));
        return encodedPersons;
    }

    /**
     * Encodes the {@code person} into a decodable and readable string representation.
     */
    private static String encodePersonToString(Person person) {
        final StringBuilder encodedPersonBuilder = new StringBuilder();

        encodedPersonBuilder.append(person.getName());

        encodedPersonBuilder.append(person.getPhone().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""p/"").append(person.getPhone().value);

        encodedPersonBuilder.append(person.getEmail().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""e/"").append(person.getEmail().value);

        encodedPersonBuilder.append(person.getAddress().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""a/"").append(person.getAddress().value);

        person.getTags().forEach(tag -> encodedPersonBuilder.append("" t/"").append(tag.tagName));

        return encodedPersonBuilder.toString();
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.storage;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents the file used to store address book data.
 */
public class StorageFile {

    /** Default file path used if the user doesn't provide the file name. */
    public static final String DEFAULT_STORAGE_FILEPATH = ""addressbook.txt"";


    public final Path path;

    /**
     * @throws InvalidStorageFilePathException if the default path is invalid
     */
    public StorageFile() throws InvalidStorageFilePathException {
        this(DEFAULT_STORAGE_FILEPATH);
    }

    /**
     * @throws InvalidStorageFilePathException if the given file path is invalid
     */
    public StorageFile(String filePath) throws InvalidStorageFilePathException {
        path = Paths.get(filePath);
        if (!isValidPath(path)) {
            throw new InvalidStorageFilePathException(""Storage file should end with '.txt'"");
        }
    }

    /**
     * Returns true if the given path is acceptable as a storage file.
     * The file path is considered acceptable if it ends with '.txt'
     */
    private static boolean isValidPath(Path filePath) {
        return filePath.toString().endsWith("".txt"");
    }

    /**
     * Saves the {@code addressBook} data to the storage file.
     *
     * @throws StorageOperationException if there were errors converting and/or storing data to file.
     */
    public void save(AddressBook addressBook) throws StorageOperationException {
        try {
            List<String> encodedAddressBook = AddressBookEncoder.encodeAddressBook(addressBook);
            Files.write(path, encodedAddressBook);
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        }
    }

    /**
     * Loads the {@code AddressBook} data from this storage file, and then returns it.
     * Returns an empty {@code AddressBook} if the file does not exist, or is not a regular file.
     *
     * @throws StorageOperationException if there were errors reading and/or converting data from file.
     */
    public AddressBook load() throws StorageOperationException {

        if (!Files.exists(path) || !Files.isRegularFile(path)) {
            return new AddressBook();
        }

        try {
            return AddressBookDecoder.decodeAddressBook(Files.readAllLines(path));
        } catch (FileNotFoundException fnfe) {
            throw new AssertionError(""A non-existent file scenario is already handled earlier."");
        // other errors
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        } catch (IllegalValueException ive) {
            throw new StorageOperationException(""File contains illegal data values; data type constraints not met"");
        }
    }

    public String getPath() {
        return path.toString();
    }

    /* Note: Note the use of nested classes below.
     * More info https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
     */

    /**
     * Signals that the given file path does not fulfill the storage filepath constraints.
     */
    public static class InvalidStorageFilePathException extends IllegalValueException {
        public InvalidStorageFilePathException(String message) {
            super(message);
        }
    }

    /**
     * Signals that some error has occured while trying to convert and read/write data between the application
     * and the storage file.
     */
    public static class StorageOperationException extends Exception {
        public StorageOperationException(String message) {
            super(message);
        }
    }


}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.common;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * Utility methods
 */
public class Utils {

    /**
     * Returns true if any of the given items are null.
     */
    public static boolean isAnyNull(Object... items) {
        if (items == null) {
            return false;
        }
        for (Object item : items) {
            if (item == null) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if every element the given collection are unique by {@link Object#equals(Object)}.
     */
    public static boolean elementsAreUnique(Collection<?> items) {
        final Set<Object> testSet = new HashSet<>();
        for (Object item : items) {
            final boolean itemAlreadyExists = !testSet.add(item); // see Set documentation
            if (itemAlreadyExists) {
                return false;
            }
        }
        return true;
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.common;

/**
 * Container for user visible messages.
 */
public class Messages {

    public static final String MESSAGE_GOODBYE = ""Good bye!"";
    public static final String MESSAGE_INIT_FAILED = ""Failed to initialise address book application. Exiting..."";
    public static final String MESSAGE_INVALID_COMMAND_FORMAT = ""Invalid command format! \n%1$s"";
    public static final String MESSAGE_INVALID_PERSON_DISPLAYED_INDEX = ""The person index provided is invalid"";
    public static final String MESSAGE_PERSON_NOT_IN_ADDRESSBOOK = ""Person could not be found in address book"";
    public static final String MESSAGE_PERSONS_LISTED_OVERVIEW = ""%1$d persons listed!"";
    public static final String MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE = ""Launch command format: "" +
            ""java seedu.addressbook.Main [STORAGE_FILE_PATH]"";
    public static final String MESSAGE_WELCOME = ""Welcome to your Address Book!"";
    public static final String MESSAGE_USING_STORAGE_FILE = ""Using storage file : %1$s"";
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows details of the person identified using the last displayed index.
 * Private contact details are not shown.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = ""view"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextHidePrivate()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;


/**
 * Deletes a person identified using it's last displayed index from the address book.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = ""delete"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Deletes the person identified by the index number used in the last person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_DELETE_PERSON_SUCCESS = ""Deleted Person: %1$s"";


    public DeleteCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            addressBook.removePerson(target);
            return new CommandResult(String.format(MESSAGE_DELETE_PERSON_SUCCESS, target));

        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        } catch (PersonNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
        }
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import seedu.addressbook.data.person.ReadOnlyPerson;

import java.util.List;


/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = ""list"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Displays all persons in the address book as a list with index numbers.\n""
            + ""Example: "" + COMMAND_WORD;


    @Override
    public CommandResult execute() {
        List<ReadOnlyPerson> allPersons = addressBook.getAllPersons().immutableListView();
        return new CommandResult(getMessageForPersonListShownSummary(allPersons), allPersons);
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows all details of the person identified using the last displayed index.
 * Private contact details are shown.
 */
public class ViewAllCommand extends Command {

    public static final String COMMAND_WORD = ""viewall"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewAllCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextShowAll()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

/**
 * Clears the address book.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = ""clear"";
    public static final String MESSAGE_USAGE = ""Clears address book permanently.\n""
            + ""Example: "" + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = ""Address book has been cleared!"";

    @Override
    public CommandResult execute() {
        addressBook.clear();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;

import java.util.List;

import static seedu.addressbook.ui.TextUi.DISPLAYED_INDEX_OFFSET;

/**
 * Represents an executable command.
 */
public class Command {
    protected AddressBook addressBook;
    protected List<? extends ReadOnlyPerson> relevantPersons;
    private int targetIndex = -1;

    /**
     * @param targetIndex last visible listing index of the target person
     */
    public Command(int targetIndex) {
        this.setTargetIndex(targetIndex);
    }

    protected Command() {
    }

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of persons.
     *
     * @param personsDisplayed used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForPersonListShownSummary(List<? extends ReadOnlyPerson> personsDisplayed) {
        return String.format(Messages.MESSAGE_PERSONS_LISTED_OVERVIEW, personsDisplayed.size());
    }

    /**
     * Executes the command and returns the result.
     */
    public CommandResult execute(){
        throw new UnsupportedOperationException(""This method is to be implemented by child classes"");
    };

    /**
     * Supplies the data the command will operate on.
     */
    public void setData(AddressBook addressBook, List<? extends ReadOnlyPerson> relevantPersons) {
        this.addressBook = addressBook;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Extracts the the target person in the last shown list from the given arguments.
     *
     * @throws IndexOutOfBoundsException if the target index is out of bounds of the last viewed listing
     */
    protected ReadOnlyPerson getTargetPerson() throws IndexOutOfBoundsException {
        return relevantPersons.get(getTargetIndex() - DISPLAYED_INDEX_OFFSET);
    }

    public int getTargetIndex() {
        return targetIndex;
    }

    public void setTargetIndex(int targetIndex) {
        this.targetIndex = targetIndex;
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;

/**
 * Adds a person to the address book.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = ""add"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Adds a person to the address book. ""
            + ""Contact details can be marked private by prepending 'p' to the prefix.\n""
            + ""Parameters: NAME [p]p/PHONE [p]e/EMAIL [p]a/ADDRESS  [t/TAG]...\n""
            + ""Example: "" + COMMAND_WORD
            + "" John Doe p/98765432 e/johnd@gmail.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney"";

    public static final String MESSAGE_SUCCESS = ""New person added: %1$s"";
    public static final String MESSAGE_DUPLICATE_PERSON = ""This person already exists in the address book"";

    private final Person toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name,
                      String phone, boolean isPhonePrivate,
                      String email, boolean isEmailPrivate,
                      String address, boolean isAddressPrivate,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Person(
                new Name(name),
                new Phone(phone, isPhonePrivate),
                new Email(email, isEmailPrivate),
                new Address(address, isAddressPrivate),
                tagSet
        );
    }

    public AddCommand(Person toAdd) {
        this.toAdd = toAdd;
    }

    public ReadOnlyPerson getPerson() {
        return toAdd;
    }

    @Override
    public CommandResult execute() {
        try {
            addressBook.addPerson(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniquePersonList.DuplicatePersonException dpe) {
            return new CommandResult(MESSAGE_DUPLICATE_PERSON);
        }
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;


/**
 * Shows help instructions.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = ""help"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Shows program usage instructions.\n""
            + ""Example: "" + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        return new CommandResult(
                AddCommand.MESSAGE_USAGE
                + ""\n"" + DeleteCommand.MESSAGE_USAGE
                + ""\n"" + ClearCommand.MESSAGE_USAGE
                + ""\n"" + FindCommand.MESSAGE_USAGE
                + ""\n"" + ListCommand.MESSAGE_USAGE
                + ""\n"" + ViewCommand.MESSAGE_USAGE
                + ""\n"" + ViewAllCommand.MESSAGE_USAGE
                + ""\n"" + HelpCommand.MESSAGE_USAGE
                + ""\n"" + ExitCommand.MESSAGE_USAGE
        );
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;


/**
 * Represents an incorrect command. Upon execution, produces some feedback to the user.
 */
public class IncorrectCommand extends Command {

    public final String feedbackToUser;

    public IncorrectCommand(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
    }

    @Override
    public CommandResult execute() {
        return new CommandResult(feedbackToUser);
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Finds and lists all persons in address book whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = ""find"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Finds all persons whose names contain any of ""
            + ""the specified keywords (case-sensitive) and displays them as a list with index numbers.\n""
            + ""Parameters: KEYWORD [MORE_KEYWORDS]...\n""
            + ""Example: "" + COMMAND_WORD + "" alice bob charlie"";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    /**
     * Returns a copy of keywords in this command.
     */
    public Set<String> getKeywords() {
        return new HashSet<>(keywords);
    }

    @Override
    public CommandResult execute() {
        final List<ReadOnlyPerson> personsFound = getPersonsWithNameContainingAnyKeyword(keywords);
        return new CommandResult(getMessageForPersonListShownSummary(personsFound), personsFound);
    }

    /**
     * Retrieves all persons in the address book whose names contain some of the specified keywords.
     *
     * @param keywords for searching
     * @return list of persons found
     */
    private List<ReadOnlyPerson> getPersonsWithNameContainingAnyKeyword(Set<String> keywords) {
        final List<ReadOnlyPerson> matchedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : addressBook.getAllPersons()) {
            final Set<String> wordsInName = new HashSet<>(person.getName().getWordsInName());
            if (!Collections.disjoint(wordsInName, keywords)) {
                matchedPersons.add(person);
            }
        }
        return matchedPersons;
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = ""exit"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Exits the program.\n""
            + ""Example: "" + COMMAND_WORD;
    public static final String MESSAGE_EXIT_ACKNOWEDGEMENT = ""Exiting Address Book as requested ..."";

    @Override
    public CommandResult execute() {
        return new CommandResult(MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    public static boolean isExit(Command command) {
        return command instanceof ExitCommand; // instanceof returns false if it is null
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.commands;

import seedu.addressbook.data.person.ReadOnlyPerson;

import java.util.List;
import java.util.Optional;

/**
 * Represents the result of a command execution.
 */
public class CommandResult {

    /** The feedback message to be shown to the user. Contains a description of the execution result */
    public final String feedbackToUser;

    /** The list of persons that was produced by the command */
    private final List<? extends ReadOnlyPerson> relevantPersons;

    public CommandResult(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
        relevantPersons = null;
    }

    public CommandResult(String feedbackToUser, List<? extends ReadOnlyPerson> relevantPersons) {
        this.feedbackToUser = feedbackToUser;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Returns a list of persons relevant to the command command result, if any.
     */
    public Optional<List<? extends ReadOnlyPerson>> getRelevantPersons() {
        return Optional.ofNullable(relevantPersons);
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data;

import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;

/**
 * Represents the entire address book. Contains the data of the address book.
 */
public class AddressBook {

    private final UniquePersonList allPersons;

    /**
     * Creates an empty address book.
     */
    public AddressBook() {
        allPersons = new UniquePersonList();
    }

    /**
     * Constructs an address book with the given data.
     *
     * @param persons external changes to this will not affect this address book
     */
    public AddressBook(UniquePersonList persons) {
        this.allPersons = new UniquePersonList(persons);
    }

    /**
     * Adds a person to the address book.
     *
     * @throws DuplicatePersonException if an equivalent person already exists.
     */
    public void addPerson(Person toAdd) throws DuplicatePersonException {
        allPersons.add(toAdd);
    }

    /**
     * Returns true if an equivalent person exists in the address book.
     */
    public boolean containsPerson(ReadOnlyPerson key) {
        return allPersons.contains(key);
    }

    /**
     * Removes the equivalent person from the address book.
     *
     * @throws PersonNotFoundException if no such Person could be found.
     */
    public void removePerson(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        allPersons.remove(toRemove);
    }

    /**
     * Clears all persons and tags from the address book.
     */
    public void clear() {
        allPersons.clear();
    }

    /**
     * Returns a new UniquePersonList of all persons in the address book at the time of the call.
     */
    public UniquePersonList getAllPersons() {
        return new UniquePersonList(allPersons);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddressBook // instanceof handles nulls
                        && this.allPersons.equals(((AddressBook) other).allPersons));
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's phone number in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidPhone(String)}
 */
public class Phone {

    public static final String EXAMPLE = ""123456789"";
    public static final String MESSAGE_PHONE_CONSTRAINTS = ""Person phone numbers should only contain numbers"";
    public static final String PHONE_VALIDATION_REGEX = ""\\d+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given phone number.
     *
     * @throws IllegalValueException if given phone string is invalid.
     */
    public Phone(String phone, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedPhone = phone.trim();
        if (!isValidPhone(trimmedPhone)) {
            throw new IllegalValueException(MESSAGE_PHONE_CONSTRAINTS);
        }
        this.value = trimmedPhone;
    }

    /**
     * Returns true if the given string is a valid person phone number.
     */
    public static boolean isValidPhone(String test) {
        return test.matches(PHONE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Phone // instanceof handles nulls
                && this.value.equals(((Phone) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's email in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidEmail(String)}
 */
public class Email {

    public static final String EXAMPLE = ""valid@e.mail"";
    public static final String MESSAGE_EMAIL_CONSTRAINTS =
            ""Person emails should be 2 alphanumeric/period strings separated by '@'"";
    public static final String EMAIL_VALIDATION_REGEX = ""[\\w\\.]+@[\\w\\.]+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given email.
     *
     * @throws IllegalValueException if given email address string is invalid.
     */
    public Email(String email, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedEmail = email.trim();
        if (!isValidEmail(trimmedEmail)) {
            throw new IllegalValueException(MESSAGE_EMAIL_CONSTRAINTS);
        }
        this.value = trimmedEmail;
    }

    /**
     * Returns true if the given string is a valid person email.
     */
    public static boolean isValidEmail(String test) {
        return test.matches(EMAIL_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Email // instanceof handles nulls
                && this.value.equals(((Email) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }


    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.person;

import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * A read-only immutable interface for a Person in the addressbook.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyPerson {

    Name getName();
    Phone getPhone();
    Email getEmail();
    Address getAddress();

    /**
     * Returns a new TagSet that is a deep copy of the internal TagSet,
     * changes on the returned set will not affect the person's internal tags.
     */
    Set<Tag> getTags();

    /**
     * Returns true if both persons have the same identity fields (name and telephone).
     */
    default boolean isSamePerson(ReadOnlyPerson other) {
        return (other == this)
                || (other != null
                    && other.getName().equals(this.getName())
                    && other.getPhone().equals(this.getPhone()));
    }

    /**
     * Returns true if all data in this object is the same as that in another
     * (Note: interfaces cannot override .equals)
     */
    default boolean hasSameData(ReadOnlyPerson other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) // state checks here onwards
                    && other.getPhone().equals(this.getPhone())
                    && other.getEmail().equals(this.getEmail())
                    && other.getAddress().equals(this.getAddress())
                    && other.getTags().equals(this.getTags()));
    }

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsTextShowAll() {
        final StringBuilder builder = new StringBuilder();
        final String detailIsPrivate = ""(private) "";
        builder.append(getName())
                .append("" Phone: "");
        if (getPhone().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getPhone())
                .append("" Email: "");
        if (getEmail().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getEmail())
                .append("" Address: "");
        if (getAddress().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getAddress())
                .append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }

    /**
     * Formats a person as text, showing only non-private contact details.
     */
    default String getAsTextHidePrivate() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (!getPhone().isPrivate()) {
            builder.append("" Phone: "").append(getPhone());
        }
        if (!getEmail().isPrivate()) {
            builder.append("" Email: "").append(getEmail());
        }
        if (!getAddress().isPrivate()) {
            builder.append("" Address: "").append(getAddress());
        }
        builder.append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.person;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.common.Utils;
import seedu.addressbook.data.exception.DuplicateDataException;



/**
 * A list of persons. Does not allow null elements or duplicates.
 *
 * @see Person#equals(Object)
 * @see Utils#elementsAreUnique(Collection)
 */
public class UniquePersonList implements Iterable<Person> {



    private final List<Person> internalList = new ArrayList<>();

    /**
     * Constructs empty person list.
     */
    public UniquePersonList() {}

    /**
     * Constructs a person list with the given persons.
     */
    public UniquePersonList(Person... persons) throws DuplicatePersonException {
        final List<Person> initialTags = Arrays.asList(persons);
        if (!Utils.elementsAreUnique(initialTags)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(initialTags);
    }

    /**
     * Constructs a list from the items in the given collection.
     * @param persons a collection of persons
     * @throws DuplicatePersonException if the {@code persons} contains duplicate persons
     */
    public UniquePersonList(Collection<Person> persons) throws DuplicatePersonException {
        if (!Utils.elementsAreUnique(persons)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(persons);
    }

    /**
     * Constructs a shallow copy of the list.
     */
    public UniquePersonList(UniquePersonList source) {
        internalList.addAll(source.internalList);
    }

    /**
     * Returns an unmodifiable java List view with elements cast as immutable {@link ReadOnlyPerson}s.
     * For use with other methods/libraries.
     * Any changes to the internal list/elements are immediately visible in the returned list.
     */
    public List<ReadOnlyPerson> immutableListView() {
        return Collections.unmodifiableList(internalList);
    }


    /**
     * Checks if the list contains an equivalent person as the given argument.
     * The {@link ReadOnlyPerson#isSamePerson} method is used for this comparison, which
     * defines a weaker notion of equality.
     */
    public boolean contains(ReadOnlyPerson toCheck) {
        for (Person p : internalList) {
            if (p.isSamePerson(toCheck)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a person to the list.
     *
     * @throws DuplicatePersonException if the person to add is a duplicate of an existing person in the list.
     *    The @link{ReadOnlyPerson#isSamePerson} method is used for this comparison,
     *    which defines a weaker notion of equality.
     */
    public void add(Person toAdd) throws DuplicatePersonException {
        if (contains(toAdd)) {
            throw new DuplicatePersonException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent person from the list.
     *
     * @throws PersonNotFoundException if no such person could be found in the list.
     */
    public void remove(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        final boolean personFoundAndDeleted = internalList.remove(toRemove);
        if (!personFoundAndDeleted) {
            throw new PersonNotFoundException();
        }
    }

    /**
     * Clears all persons in list.
     */
    public void clear() {
        internalList.clear();
    }

    @Override
    public Iterator<Person> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniquePersonList // instanceof handles nulls
                        && this.internalList.equals(((UniquePersonList) other).internalList));
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicatePersonException extends DuplicateDataException {
        protected DuplicatePersonException() {
            super(""Operation would result in duplicate persons"");
        }
    }

    /**
     * Signals that an operation targeting a specified person in the list would fail because
     * there is no such matching person in the list.
     */
    public static class PersonNotFoundException extends Exception {}
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's address in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidAddress(String)}
 */
public class Address {

    public static final String EXAMPLE = ""123, some street"";
    public static final String MESSAGE_ADDRESS_CONSTRAINTS = ""Person addresses can be in any format"";
    public static final String ADDRESS_VALIDATION_REGEX = "".+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given address.
     *
     * @throws IllegalValueException if given address string is invalid.
     */
    public Address(String address, boolean isPrivate) throws IllegalValueException {
        String trimmedAddress = address.trim();
        this.isPrivate = isPrivate;
        if (!isValidAddress(trimmedAddress)) {
            throw new IllegalValueException(MESSAGE_ADDRESS_CONSTRAINTS);
        }
        this.value = trimmedAddress;
    }

    /**
     * Returns true if a given string is a valid person address.
     */
    public static boolean isValidAddress(String test) {
        return test.matches(ADDRESS_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Address // instanceof handles nulls
                && this.value.equals(((Address) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.person;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * Represents a Person in the address book.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Person implements ReadOnlyPerson {

    private Name name;
    private Phone phone;
    private Email email;
    private Address address;

    private final Set<Tag> tags = new HashSet<>();

    /**
     * Assumption: Every field must be present and not null.
     */
    public Person(Name name, Phone phone, Email email, Address address, Set<Tag> tags) {
        this.name = name;
        this.phone = phone;
        this.email = email;
        this.address = address;
        this.tags.addAll(tags);
    }

    /**
     * Copy constructor.
     */
    public Person(ReadOnlyPerson source) {
        this(source.getName(), source.getPhone(), source.getEmail(), source.getAddress(), source.getTags());
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public Phone getPhone() {
        return phone;
    }

    @Override
    public Email getEmail() {
        return email;
    }

    @Override
    public Address getAddress() {
        return address;
    }

    @Override
    public Set<Tag> getTags() {
        return new HashSet<>(tags);
    }

    /**
     * Replaces this person's tags with the tags in the argument tag set.
     */
    public void setTags(Set<Tag> replacement) {
        tags.clear();
        tags.addAll(replacement);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyPerson // instanceof handles nulls
                && this.hasSameData((ReadOnlyPerson) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, phone, email, address, tags);
    }

    @Override
    public String toString() {
        return getAsTextShowAll();
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

import java.util.Arrays;
import java.util.List;

/**
 * Represents a Person's name in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String EXAMPLE = ""John Doe"";
    public static final String MESSAGE_NAME_CONSTRAINTS = ""Person names should be spaces or alphabetic characters"";
    public static final String NAME_VALIDATION_REGEX = ""[\\p{Alpha} ]+"";
    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = trimmedName;
    }

    /**
     * Returns true if the given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }

    /**
     * Retrieves a listing of every word in the name, in order.
     */
    public List<String> getWordsInName() {
        return Arrays.asList(fullName.split(""\\s+""));
    }

    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.exception;

/**
 * Signals an error caused by duplicate data where there should be none.
 */
public abstract class DuplicateDataException extends IllegalValueException {
    public DuplicateDataException(String message) {
        super(message);
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.exception;

/**
 * Signals that some given data does not fulfill some constraints.
 */
public class IllegalValueException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public IllegalValueException(String message) {
        super(message);
    }
}
",0.75,2.04
sc1_v4,deafd87,"package seedu.addressbook.data.tag;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Tag in the address book.
 * Guarantees: immutable; name is valid as declared in {@link #isValidTagName(String)}
 */
public class Tag {

    public static final String MESSAGE_TAG_CONSTRAINTS = ""Tags names should be alphanumeric"";
    public static final String TAG_VALIDATION_REGEX = ""\\p{Alnum}+"";

    public final String tagName;

    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid tag name.
     */
    public static boolean isValidTagName(String test) {
        return test.matches(TAG_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    @Override
    public String toString() {
        return '[' + tagName + ']';
    }

}
",0.75,2.04
sc1_v5,ffc79e3,"package seedu.addressbook.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;

public class TestUtil {
    /**
     * Creates an address book containing the given persons.
     */
    public static AddressBook createAddressBook(Person... persons) {
        AddressBook addressBook = new AddressBook();

        for (Person person : persons) {
            try {
                addressBook.addPerson(person);
            } catch (DuplicatePersonException e) {
                throw new AssertionError(e);
            }
        }

        return addressBook;
    }

    /**
     * Creates a list of persons.
     */
    public static List<ReadOnlyPerson> createList(Person...persons) {
        List<ReadOnlyPerson> list = new ArrayList<ReadOnlyPerson>();

        for (Person person : persons) {
            list.add(person);
        }

        return list;
    }

    /**
     * Creates a copy of the original address book with the same entries
     * of Persons and Tags. The Persons and Tags are not cloned.
     */
    public static AddressBook clone(AddressBook addressBook) {
        return new AddressBook(addressBook.getAllPersons());
    }

    /**
     * Returns true if every pair of corresponding elements two iterables are (deeply) identical.
     * In other words, the two containers must have the same elements, in the same order.
     */
    public static <T> boolean isIdentical(Iterable<T> firstIterable, Iterable<T> secondIterable) {
        Iterator<T> currentPtr0 = firstIterable.iterator();
        Iterator<T> currentPtr1 = secondIterable.iterator();

        while (currentPtr0.hasNext() && currentPtr1.hasNext()) {
            T val0 = currentPtr0.next();
            T val1 = currentPtr1.next();

            if (!val0.equals(val1)) {
                return false;
            }
        }

        // If any of the two iterables still have elements, then they have different sizes.
        return !(currentPtr0.hasNext() || currentPtr1.hasNext());
    }

    /**
     * Returns true if the underlying container behind an iterable is empty.
     */
    public static <T> boolean isEmpty(Iterable<T> it) {
        return !it.iterator().hasNext();
    }

    /**
     * Returns the number of elements in the container behind an iterable.
     */
    public static <T> int getSize(Iterable<T> it) {
        int numberOfElementsSeen = 0;

        for (T elem : it) {
            numberOfElementsSeen++;
        }

        return numberOfElementsSeen;
    }

    public static Person generateTestPerson() {
        try {
            return new Person(new Name(Name.EXAMPLE), new Phone(Phone.EXAMPLE, false),
                    new Email(Email.EXAMPLE, true), new Address(Address.EXAMPLE, false), Collections.emptySet());
        } catch (IllegalValueException e) {
            fail(""test person data should be valid by definition"");
            return null;
        }
    }

    /**
     * Asserts whether the text in the two given files are the same. Ignores any
     * differences in line endings
     */
    public static void assertTextFilesEqual(Path path1, Path path2) throws IOException {
        List<String> list1 = Files.readAllLines(path1, Charset.defaultCharset());
        List<String> list2 = Files.readAllLines(path2, Charset.defaultCharset());
        assertEquals(String.join(""\n"", list1), String.join(""\n"", list2));
    }

    /**
     * Asserts that the file given does not exist on the filesystem.
     */
    public static void assertFileDoesNotExist(String filePath) {
        assertTrue(Files.notExists(Paths.get(filePath)));
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.util;

import java.util.Collections;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;

/**
 * Class to generate typical test persons
 */
public class TypicalPersons {

    public Person amy, bill, candy, dan;

    public TypicalPersons() {
        try {
            amy = new Person(new Name(""Amy Buck""), new Phone(""91119111"", false), new Email(""ab@gmail.com"", false),
                    new Address(""1 Clementi Road"", false), Collections.emptySet());
            bill = new Person(new Name(""Bill Clint""), new Phone(""92229222"", false), new Email(""bc@gmail.com"", false),
                    new Address(""2 Clementi Road"", true), Collections.emptySet());
            candy = new Person(new Name(""Candy Destiny""), new Phone(""93339333"", true),
                    new Email(""cd@gmail.com"", false), new Address(""3 Clementi Road"", true), Collections.emptySet());
            dan = new Person(new Name(""Dan Smith""), new Phone(""1234556"", true), new Email(""ss@tt.com"", true),
                    new Address(""NUS"", true), Collections.singleton(new Tag(""test"")));
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : ""not possible"";
        }
    }

    private void loadAddressBookWithSampleData(AddressBook ab) {
        try {
            for (Person p : this.getTypicalPersons()) {
                ab.addPerson(new Person(p));
            }
        } catch (IllegalValueException e) {
            assert false : ""not possible"";
        }
    }

    public Person[] getTypicalPersons() {
        return new Person[]{amy, bill, candy, dan};
    }

    public AddressBook getTypicalAddressBook() {
        AddressBook ab = new AddressBook();
        loadAddressBookWithSampleData(ab);
        return ab;
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.parser;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.junit.Before;
import org.junit.Test;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.tag.Tag;

public class ParserTest {

    private Parser parser;

    @Before
    public void setUp() {
        parser = new Parser();
    }

    /*
     * Note how the names of the test methods does not follow the normal naming convention.
     * That is because our coding standard allows a different naming convention for test methods.
     */

    @Test
    public void parse_emptyInput_returnsIncorrect() {
        final String[] emptyInputs = { """", ""  "", ""\n  \n"" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, emptyInputs);
    }

    @Test
    public void parse_unknownCommandWord_returnsHelp() {
        final String input = ""unknowncommandword arguments arguments"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    /*
     * Tests for 0-argument commands =======================================================================
     */

    @Test
    public void parse_helpCommand_parsedCorrectly() {
        final String input = ""help"";
        parseAndAssertCommandType(input, HelpCommand.class);
    }

    @Test
    public void parse_clearCommand_parsedCorrectly() {
        final String input = ""clear"";
        parseAndAssertCommandType(input, ClearCommand.class);
    }

    @Test
    public void parse_listCommand_parsedCorrectly() {
        final String input = ""list"";
        parseAndAssertCommandType(input, ListCommand.class);
    }

    @Test
    public void parse_exitCommand_parsedCorrectly() {
        final String input = ""exit"";
        parseAndAssertCommandType(input, ExitCommand.class);
    }

    /*
     * Tests for single index argument commands ===============================================================
     */

    @Test
    public void parse_deleteCommandNoArgs_errorMessage() {
        final String[] inputs = { ""delete"", ""delete "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""delete notAnumber "", ""delete 8*wh12"", ""delete 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_deleteCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 1;
        final String input = ""delete "" + testIndex;
        final DeleteCommand result = parseAndAssertCommandType(input, DeleteCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void viewCommandNoArgs_errorMessage() {
        final String[] inputs = { ""view"", ""view "" };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""view notAnumber "", ""view 8*wh12"", ""view 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 2;
        final String input = ""view "" + testIndex;
        final ViewCommand result = parseAndAssertCommandType(input, ViewCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    @Test
    public void parse_viewAllCommandNoArgs_errorMessage() {
        final String[] inputs = { ""viewall"", ""viewall "" };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewAllCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandArgsIsNotSingleNumber_errorMessage() {
        final String[] inputs = { ""viewall notAnumber "", ""viewall 8*wh12"", ""viewall 1 2 3 4 5"" };
        final String resultMessage = MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_viewAllCommandNumericArg_indexParsedCorrectly() {
        final int testIndex = 3;
        final String input = ""viewall "" + testIndex;
        final ViewAllCommand result = parseAndAssertCommandType(input, ViewAllCommand.class);
        assertEquals(result.getTargetIndex(), testIndex);
    }

    /*
     * Tests for find persons by keyword in name command ===================================================
     */

    @Test
    public void parse_findCommandInvalidArgs_errorMessage() {
        // no keywords
        final String[] inputs = {
            ""find"",
            ""find ""
        };
        final String resultMessage =
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_findCommandValidArgs_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        final String input = ""find "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    @Test
    public void parse_findCommandDuplicateKeys_parsedCorrectly() {
        final String[] keywords = { ""key1"", ""key2"", ""key3"" };
        final Set<String> keySet = new HashSet<>(Arrays.asList(keywords));

        // duplicate every keyword
        final String input = ""find "" + String.join("" "", keySet) + "" "" + String.join("" "", keySet);
        final FindCommand result =
                parseAndAssertCommandType(input, FindCommand.class);
        assertEquals(keySet, result.getKeywords());
    }

    /*
     * Tests for add person command ==============================================================================
     */

    @Test
    public void parse_addCommandInvalidArgs_errorMessage() {
        final String[] inputs = {
            ""add"",
            ""add "",
            ""add wrong args format"",
            // no phone prefix
            String.format(""add %s %s e/%s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no email prefix
            String.format(""add %s p/%s %s a/%s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE),
            // no address prefix
            String.format(""add %s p/%s e/%s %s"", Name.EXAMPLE, Phone.EXAMPLE, Email.EXAMPLE, Address.EXAMPLE)
        };
        final String resultMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        parseAndAssertIncorrectWithMessage(resultMessage, inputs);
    }

    @Test
    public void parse_addCommandInvalidPersonDataInArgs_errorMessge() {
        final String invalidName = ""[]\\[;]"";
        final String validName = Name.EXAMPLE;
        final String invalidPhoneArg = ""p/not__numbers"";
        final String validPhoneArg = ""p/"" + Phone.EXAMPLE;
        final String invalidEmailArg = ""e/notAnEmail123"";
        final String validEmailArg = ""e/"" + Email.EXAMPLE;
        final String invalidTagArg = ""t/invalid_-[.tag"";

        // address can be any string, so no invalid address
        final String addCommandFormatString = ""add %s %s %s a/"" + Address.EXAMPLE;

        // test each incorrect person data field argument individually
        final String[] inputs = {
                // invalid name
                String.format(addCommandFormatString, invalidName, validPhoneArg, validEmailArg),
                // invalid phone
                String.format(addCommandFormatString, validName, invalidPhoneArg, validEmailArg),
                // invalid email
                String.format(addCommandFormatString, validName, validPhoneArg, invalidEmailArg),
                // invalid tag
                String.format(addCommandFormatString, validName, validPhoneArg, validEmailArg) + "" "" + invalidTagArg
        };
        for (String input : inputs) {
            parseAndAssertCommandType(input, IncorrectCommand.class);
        }
    }

    @Test
    public void parse_addCommandValidPersonData_parsedCorrectly() {
        final Person testPerson = generateTestPerson();
        final String input = convertPersonToAddCommandString(testPerson);
        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    @Test
    public void parse_addCommandDuplicateTags_merged() throws IllegalValueException {
        final Person testPerson = generateTestPerson();
        String input = convertPersonToAddCommandString(testPerson);
        for (Tag tag : testPerson.getTags()) {
            // create duplicates by doubling each tag
            input += "" t/"" + tag.tagName;
        }

        final AddCommand result = parseAndAssertCommandType(input, AddCommand.class);
        assertEquals(result.getPerson(), testPerson);
    }

    private static Person generateTestPerson() {
        try {
            return new Person(
                new Name(Name.EXAMPLE),
                new Phone(Phone.EXAMPLE, true),
                new Email(Email.EXAMPLE, false),
                new Address(Address.EXAMPLE, true),
                new HashSet<>(Arrays.asList(new Tag(""tag1""), new Tag (""tag2""), new Tag(""tag3"")))
            );
        } catch (IllegalValueException ive) {
            throw new RuntimeException(""test person data should be valid by definition"");
        }
    }

    private static String convertPersonToAddCommandString(ReadOnlyPerson person) {
        String addCommand = ""add ""
                + person.getName().fullName
                + (person.getPhone().isPrivate() ? "" pp/"" : "" p/"") + person.getPhone().value
                + (person.getEmail().isPrivate() ? "" pe/"" : "" e/"") + person.getEmail().value
                + (person.getAddress().isPrivate() ? "" pa/"" : "" a/"") + person.getAddress().value;
        for (Tag tag : person.getTags()) {
            addCommand += "" t/"" + tag.tagName;
        }
        return addCommand;
    }

    /*
     * Utility methods ====================================================================================
     */

    /**
     * Asserts that parsing the given inputs will return IncorrectCommand with the given feedback message.
     */
    private void parseAndAssertIncorrectWithMessage(String feedbackMessage, String... inputs) {
        for (String input : inputs) {
            final IncorrectCommand result = parseAndAssertCommandType(input, IncorrectCommand.class);
            assertEquals(result.feedbackToUser, feedbackMessage);
        }
    }

    /**
     * Parses input and asserts the class/type of the returned command object.
     *
     * @param input to be parsed
     * @param expectedCommandClass expected class of returned command
     * @return the parsed command object
     */
    private <T extends Command> T parseAndAssertCommandType(String input, Class<T> expectedCommandClass) {
        final Command result = parser.parseCommand(input);
        assertTrue(result.getClass().isAssignableFrom(expectedCommandClass));
        return (T) result;
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.storage;

import static org.junit.Assert.assertEquals;

import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.rules.TemporaryFolder;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;
import static seedu.addressbook.util.TestUtil.assertTextFilesEqual;
import static seedu.addressbook.util.TestUtil.assertFileDoesNotExist;

public class StorageFileTest {
    private static final String TEST_DATA_FOLDER = ""test/data/StorageFileTest"";
    private static final String NON_EXISTANT_FILE_NAME = ""ThisFileDoesNotExist.txt"";

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Rule
    public TemporaryFolder testFolder = new TemporaryFolder();

    @Test
    public void constructor_nullFilePath_exceptionThrown() throws Exception {
        thrown.expect(NullPointerException.class);
        new StorageFile(null);
    }

    @Test
    public void constructor_noTxtExtension_exceptionThrown() throws Exception {
        thrown.expect(IllegalValueException.class);
        new StorageFile(TEST_DATA_FOLDER + ""/"" + ""InvalidfileName"");
    }

    @Test
    public void load_invalidFormat_exceptionThrown() throws Exception {
        // The file contains valid txt data, but does not match the Person format
        StorageFile storage = getStorage(""InvalidData.txt"");
        thrown.expect(StorageOperationException.class);
        storage.load();
    }

    @Test
    public void load_validFormat() throws Exception {
        AddressBook actualAB = getStorage(""ValidData.txt"").load();
        AddressBook expectedAB = getTestAddressBook();

        // ensure loaded AddressBook is properly constructed with test data
        // TODO: overwrite equals method in AddressBook class and replace with equals method below
        assertEquals(actualAB.getAllPersons(), expectedAB.getAllPersons());
    }

    @Test
    public void load_nonExistantFile_returnsEmptyAddressBook() throws Exception {
        AddressBook actualAB = getStorage(NON_EXISTANT_FILE_NAME).load();
        AddressBook expectedAB = new AddressBook();

        assertEquals(actualAB, expectedAB);

        // verify that loading does not result in the file being created
        assertFileDoesNotExist(TEST_DATA_FOLDER + ""/"" + NON_EXISTANT_FILE_NAME);
    }

    @Test
    public void save_nullAddressBook_exceptionThrown() throws Exception {
        StorageFile storage = getTempStorage();
        thrown.expect(NullPointerException.class);
        storage.save(null);
    }

    @Test
    public void save_validAddressBook() throws Exception {
        AddressBook ab = getTestAddressBook();
        StorageFile storage = getTempStorage();
        storage.save(ab);

        assertStorageFilesEqual(storage, getStorage(""ValidData.txt""));
    }

    // getPath() method in StorageFile class is trivial so it is not tested

    /**
     * Asserts that the contents of two storage files are the same.
     */
    private void assertStorageFilesEqual(StorageFile sf1, StorageFile sf2) throws Exception {
        assertTextFilesEqual(Paths.get(sf1.getPath()), Paths.get(sf2.getPath()));
    }

    private StorageFile getStorage(String fileName) throws Exception {
        return new StorageFile(TEST_DATA_FOLDER + ""/"" + fileName);
    }

    private StorageFile getTempStorage() throws Exception {
        return new StorageFile(testFolder.getRoot().getPath() + ""/"" + ""temp.txt"");
    }

    private AddressBook getTestAddressBook() throws Exception {
        AddressBook ab = new AddressBook();
        ab.addPerson(new Person(new Name(""John Doe""),
                                new Phone(""98765432"", false),
                                new Email(""johnd@gmail.com"", false),
                                new Address(""John street, block 123, #01-01"", false),
                                Collections.emptySet()));
        ab.addPerson(new Person(new Name(""Betsy Crowe""),
                                new Phone(""1234567"", true),
                                new Email(""betsycrowe@gmail.com"", false),
                                new Address(""Newgate Prison"", true),
                                new HashSet<>(Arrays.asList(new Tag(""friend""), new Tag(""criminal"")))));
        return ab;
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.common;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class UtilsTest {


    @Test
    public void elementsAreUnique() throws Exception {
        // empty list
        assertAreUnique();

        // only one object
        assertAreUnique((Object) null);
        assertAreUnique(1);
        assertAreUnique("""");
        assertAreUnique(""abc"");

        // all objects unique
        assertAreUnique(""abc"", ""ab"", ""a"");
        assertAreUnique(1, 2);

        // some identical objects
        assertNotUnique(""abc"", ""abc"");
        assertNotUnique(""abc"", """", ""abc"", ""ABC"");
        assertNotUnique("""", ""abc"", ""a"", ""abc"");
        assertNotUnique(1, Integer.valueOf(1));
        assertNotUnique(null, 1, Integer.valueOf(1));
        assertNotUnique(null, null);
        assertNotUnique(null, ""a"", ""b"", null);
    }

    @Test
    public void isAnyNull() {
        // no items
        assertFalse(Utils.isAnyNull());

        // varargs array that is null (i.e. no array)
        assertFalse(Utils.isAnyNull((Object[]) null));

        // one item which is null (i.e. an array with one null item)
        assertTrue(Utils.isAnyNull((Object) null));

        // at least one item, none of which are null
        assertFalse(Utils.isAnyNull(""A""));
        assertFalse(Utils.isAnyNull(""A"", """"));
        assertFalse(Utils.isAnyNull(1, 2, ""C""));

        // at least one item, some of which are null
        assertTrue(Utils.isAnyNull(null, 1));
        assertTrue(Utils.isAnyNull(""A"", null, ""C""));
    }

    private void assertAreUnique(Object... objects) {
        assertTrue(Utils.elementsAreUnique(Arrays.asList(objects)));
    }

    private void assertNotUnique(Object... objects) {
        assertFalse(Utils.elementsAreUnique(Arrays.asList(objects)));
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import static org.junit.Assert.assertEquals;

import java.util.Collections;
import java.util.List;

import org.junit.Before;
import org.junit.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.ui.TextUi;
import seedu.addressbook.util.TestUtil;

public class DeleteCommandTest {

    private AddressBook emptyAddressBook;
    private AddressBook addressBook;

    private List<ReadOnlyPerson> emptyDisplayList;
    private List<ReadOnlyPerson> listWithEveryone;
    private List<ReadOnlyPerson> listWithSurnameDoe;

    @Before
    public void setUp() throws Exception {
        Person johnDoe = new Person(new Name(""John Doe""), new Phone(""61234567"", false),
                new Email(""john@doe.com"", false), new Address(""395C Ben Road"", false), Collections.emptySet());
        Person janeDoe = new Person(new Name(""Jane Doe""), new Phone(""91234567"", false),
                new Email(""jane@doe.com"", false), new Address(""33G Ohm Road"", false), Collections.emptySet());
        Person samDoe = new Person(new Name(""Sam Doe""), new Phone(""63345566"", false),
                new Email(""sam@doe.com"", false), new Address(""55G Abc Road"", false), Collections.emptySet());
        Person davidGrant = new Person(new Name(""David Grant""), new Phone(""61121122"", false),
                new Email(""david@grant.com"", false), new Address(""44H Define Road"", false),
                Collections.emptySet());

        emptyAddressBook = TestUtil.createAddressBook();
        addressBook = TestUtil.createAddressBook(johnDoe, janeDoe, davidGrant, samDoe);

        emptyDisplayList = TestUtil.createList();

        listWithEveryone = TestUtil.createList(johnDoe, janeDoe, davidGrant, samDoe);
        listWithSurnameDoe = TestUtil.createList(johnDoe, janeDoe, samDoe);
    }

    @Test
    public void execute_emptyAddressBook_returnsPersonNotFoundMessage() {
        assertDeletionFailsDueToNoSuchPerson(1, emptyAddressBook, listWithEveryone);
    }

    @Test
    public void execute_noPersonDisplayed_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(1, addressBook, emptyDisplayList);
    }

    @Test
    public void execute_targetPersonNotInAddressBook_returnsPersonNotFoundMessage()
            throws IllegalValueException {
        Person notInAddressBookPerson = new Person(new Name(""Not In Book""), new Phone(""63331444"", false),
                new Email(""notin@book.com"", false), new Address(""156D Grant Road"", false), Collections.emptySet());
        List<ReadOnlyPerson> listWithPersonNotInAddressBook = TestUtil.createList(notInAddressBookPerson);

        assertDeletionFailsDueToNoSuchPerson(1, addressBook, listWithPersonNotInAddressBook);
    }

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        assertDeletionFailsDueToInvalidIndex(0, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(-1, addressBook, listWithEveryone);
        assertDeletionFailsDueToInvalidIndex(listWithEveryone.size() + 1, addressBook, listWithEveryone);
    }

    @Test
    public void execute_validIndex_personIsDeleted() throws PersonNotFoundException {
        assertDeletionSuccessful(1, addressBook, listWithSurnameDoe);
        assertDeletionSuccessful(listWithSurnameDoe.size(), addressBook, listWithSurnameDoe);

        int middleIndex = (listWithSurnameDoe.size() / 2) + 1;
        assertDeletionSuccessful(middleIndex, addressBook, listWithSurnameDoe);
    }

    /**
     * Creates a new delete command.
     *
     * @param targetVisibleIndex of the person that we want to delete
     */
    private DeleteCommand createDeleteCommand(int targetVisibleIndex, AddressBook addressBook,
                                                                      List<ReadOnlyPerson> displayList) {

        DeleteCommand command = new DeleteCommand(targetVisibleIndex);
        command.setData(addressBook, displayList);

        return command;
    }

    /**
     * Executes the command, and checks that the execution was what we had expected.
     */
    private void assertCommandBehaviour(DeleteCommand deleteCommand, String expectedMessage,
                                        AddressBook expectedAddressBook, AddressBook actualAddressBook) {

        CommandResult result = deleteCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedAddressBook.getAllPersons(), actualAddressBook.getAllPersons());
    }

    /**
     * Asserts that the index is not valid for the given display list.
     */
    private void assertDeletionFailsDueToInvalidIndex(int invalidVisibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

        DeleteCommand command = createDeleteCommand(invalidVisibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index cannot be deleted, because that person
     * is not in the address book.
     */
    private void assertDeletionFailsDueToNoSuchPerson(int visibleIndex, AddressBook addressBook,
                                                                        List<ReadOnlyPerson> displayList) {

        String expectedMessage = Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK;

        DeleteCommand command = createDeleteCommand(visibleIndex, addressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, addressBook, addressBook);
    }

    /**
     * Asserts that the person at the specified index can be successfully deleted.
     *
     * The addressBook passed in will not be modified (no side effects).
     *
     * @throws PersonNotFoundException if the selected person is not in the address book
     */
    private void assertDeletionSuccessful(int targetVisibleIndex, AddressBook addressBook,
                                          List<ReadOnlyPerson> displayList) throws PersonNotFoundException {

        ReadOnlyPerson targetPerson = displayList.get(targetVisibleIndex - TextUi.DISPLAYED_INDEX_OFFSET);

        AddressBook expectedAddressBook = TestUtil.clone(addressBook);
        expectedAddressBook.removePerson(targetPerson);
        String expectedMessage = String.format(DeleteCommand.MESSAGE_DELETE_PERSON_SUCCESS, targetPerson);

        AddressBook actualAddressBook = TestUtil.clone(addressBook);

        DeleteCommand command = createDeleteCommand(targetVisibleIndex, actualAddressBook, displayList);
        assertCommandBehaviour(command, expectedMessage, expectedAddressBook, actualAddressBook);
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

public class ViewAllCommandTest {
    // ViewAllCommand is tested together with ViewCommand in ViewCommandTest.
    // This is because they function similarly but ViewCommand hides private information.
    // They are tested with same test data input.
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

import org.junit.Test;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TestUtil;
import seedu.addressbook.util.TypicalPersons;

public class ViewCommandTest {
    private TypicalPersons td = new TypicalPersons();

    private AddressBook typicalAddressBook = td.getTypicalAddressBook();
    private AddressBook emptyAddressBook = TestUtil.createAddressBook();
    private List<ReadOnlyPerson> emptyPersonList = Collections.emptyList();
    private List<ReadOnlyPerson> listWithAllTypicalPersons = Arrays.asList(td.getTypicalPersons());
    private List<ReadOnlyPerson> listWithSomeTypicalPersons = Arrays.asList(td.amy, td.candy, td.dan);

    @Test
    public void execute_invalidIndex_returnsInvalidIndexMessage() {
        // empty addressbook
        assertViewErrorInvalidIndex(emptyAddressBook, emptyPersonList, 1);

        // non-empty addressbook
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, -1);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons, 0);
        assertViewErrorInvalidIndex(typicalAddressBook, listWithAllTypicalPersons,
                                              listWithAllTypicalPersons.size() + 1);
    }

    @Test
    public void execute_personNotInAddressBook_returnsPersonNotInAddressBookMessage() throws Exception {
        // generate list with person not in addressbook, add to list
        ReadOnlyPerson stranger = new Person(new Name(""me""),
                                             new Phone(""123"", true),
                                             new Email(""some@hey.go"", true),
                                             new Address(""nus"", false),
                                             Collections.emptySet());
        List<ReadOnlyPerson> listWithExtraPerson
                = new ArrayList<ReadOnlyPerson>(listWithAllTypicalPersons);
        listWithExtraPerson.add(stranger);

        // empty addressbook
        assertViewErrorPersonNotInAddressBook(emptyAddressBook, listWithExtraPerson, 1);

        // non-empty addressbook
        assertViewErrorPersonNotInAddressBook(typicalAddressBook, listWithExtraPerson,
                                                            listWithExtraPerson.size());
    }

    @Test
    public void execute_validIndex_returnsPersonDetails() {
        // person with no private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 1);

        // person with some private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 2);

        // person with all private information
        assertViewSuccess(typicalAddressBook, listWithAllTypicalPersons, 4);

        // Addressbook has more people than the list.
        // This can happen when a command causes the list to show only a sub-set of persons(e.g. FindCommand).
        assertViewSuccess(typicalAddressBook, listWithSomeTypicalPersons, 1);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * invalid index.
     */
    private void assertViewErrorInvalidIndex(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                     int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                          Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
    }

    /**
     * Asserts that the details of person at specific index cannot be retrieved due to
     * person not existing in the addressbook.
     */
    private void assertViewErrorPersonNotInAddressBook(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                                               int targetVisibleIndex) {
        assertViewError(addressBook, relevantPersons, targetVisibleIndex,
                               Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
    }

    /**
     * Asserts that both a ViewCommand and a ViewAllCommand can retrieve from
     * the {@code addressBook} details of the person at the given {@code targetVisibleIndex}
     * in the given {@code relevantPersons} list.
     *
     * @param targetVisibleIndex one-indexed position of the target person in the list
     */
    private void assertViewSuccess(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                                           int targetVisibleIndex) {
        // get person to be viewed (targetVisibleIndex - 1 because index is one-indexed)
        ReadOnlyPerson personToBeViewed = relevantPersons.get(targetVisibleIndex - 1);

        String expectedMessage = String.format(ViewCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextHidePrivate());
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);

        expectedMessage = String.format(ViewAllCommand.MESSAGE_VIEW_PERSON_DETAILS,
                                                personToBeViewed.getAsTextShowAll());
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Asserts that the Viewcommand and ViewAllcommand reports the given error for the given input.
     */
    private static void assertViewError(AddressBook addressBook, List<ReadOnlyPerson> relevantPersons,
                                                        int targetVisibleIndex, String expectedMessage) {
        assertViewBehavior(new ViewCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
        assertViewBehavior(new ViewAllCommand(targetVisibleIndex), addressBook, relevantPersons, expectedMessage);
    }

    /**
     * Executes the test command for the given addressbook data.
     * Checks that ViewCommand and ViewAllCommand exhibits the correct command behavior, namely:
     * 1. The feedback message of the CommandResult it returns matches expectedMessage.
     * 2. The CommandResult it returns has no relevant persons.
     * 3. The original addressbook data is not modified after executing ViewCommand and ViewAllCommand.
     */
    private static void assertViewBehavior(Command viewCommand, AddressBook addressBook,
                                           List<ReadOnlyPerson> relevantPersons, String expectedMessage) {
        AddressBook expectedAddressBook = TestUtil.clone(addressBook);

        viewCommand.setData(addressBook, relevantPersons);
        CommandResult result = viewCommand.execute();

        // feedback message is as expected and there are no relevant persons returned.
        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(Optional.empty(), result.getRelevantPersons());

        // addressbook was not modified.
        assertEquals(expectedAddressBook.getAllPersons(), addressBook.getAllPersons());
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import static org.junit.Assert.assertEquals;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.util.TypicalPersons;

public class FindCommandTest {

    private final AddressBook addressBook = new TypicalPersons().getTypicalAddressBook();
    private final TypicalPersons td = new TypicalPersons();

    @Test
    public void execute() throws IllegalValueException {
        //same word, same case: matched
        assertFindCommandBehavior(new String[]{""Amy""}, Arrays.asList(td.amy));

        //same word, different case: not matched
        assertFindCommandBehavior(new String[]{""aMy""}, Collections.emptyList());

        //partial word: not matched
        assertFindCommandBehavior(new String[]{""my""}, Collections.emptyList());

        //multiple words: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Bill"", ""Candy"", ""Destiny""},
                Arrays.asList(td.amy, td.bill, td.candy));

        //repeated keywords: matched
        assertFindCommandBehavior(new String[]{""Amy"", ""Amy""}, Arrays.asList(td.amy));

        //Keyword matching a word in address: not matched
        assertFindCommandBehavior(new String[]{""Clementi""}, Collections.emptyList());
    }

    /**
     * Executes the find command for the given keywords and verifies
     * the result matches the persons in the expectedPersonList exactly.
     */
    private void assertFindCommandBehavior(String[] keywords, List<ReadOnlyPerson> expectedPersonList) {
        FindCommand command = createFindCommand(keywords);
        CommandResult result = command.execute();

        assertEquals(Command.getMessageForPersonListShownSummary(expectedPersonList), result.feedbackToUser);
    }

    private FindCommand createFindCommand(String[] keywords) {
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        FindCommand command = new FindCommand(keywordSet);
        command.setData(addressBook, Collections.emptyList());
        return command;
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.Test;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.util.TestUtil;

public class AddCommandTest {
    private static final List<ReadOnlyPerson> EMPTY_PERSON_LIST = Collections.emptyList();
    private static final Set<String> EMPTY_STRING_SET = Collections.emptySet();

    @Test
    public void addCommand_invalidName_throwsException() {
        final String[] invalidNames = { """", "" "", ""[]\\[;]"" };
        for (String name : invalidNames) {
            assertConstructingInvalidAddCmdThrowsException(name, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                    Address.EXAMPLE, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidPhone_throwsException() {
        final String[] invalidNumbers = { """", "" "", ""1234-5678"", ""[]\\[;]"", ""abc"", ""a123"", ""+651234"" };
        for (String number : invalidNumbers) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, number, false, Email.EXAMPLE, true,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidEmail_throwsException() {
        final String[] invalidEmails = { """", "" "", ""def.com"", ""@"", ""@def"", ""@def.com"", ""abc@"",
                                         ""@invalid@email"", ""invalid@email!"", ""!invalid@email"" };
        for (String email : invalidEmails) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, false, email, false,
                    Address.EXAMPLE, false, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidAddress_throwsException() {
        final String[] invalidAddresses = { """", "" "" };
        for (String address : invalidAddresses) {
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, address, true, EMPTY_STRING_SET);
        }
    }

    @Test
    public void addCommand_invalidTags_throwsException() {
        final String[][] invalidTags = { { """" }, { "" "" }, { ""'"" }, { ""[]\\[;]"" }, { ""validTag"", """" },
                                         { """", "" "" } };
        for (String[] tags : invalidTags) {
            Set<String> tagsToAdd = new HashSet<>(Arrays.asList(tags));
            assertConstructingInvalidAddCmdThrowsException(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE,
                    true, Address.EXAMPLE, false, tagsToAdd);
        }
    }

    /**
     * Asserts that attempting to construct an add command with the supplied
     * invalid data throws an IllegalValueException
     */
    private void assertConstructingInvalidAddCmdThrowsException(String name, String phone,
            boolean isPhonePrivate, String email, boolean isEmailPrivate, String address,
            boolean isAddressPrivate, Set<String> tags) {
        try {
            new AddCommand(name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate,
                    tags);
        } catch (IllegalValueException e) {
            return;
        }
        String error = String.format(
                ""An add command was successfully constructed with invalid input: %s %s %s %s %s %s %s %s"",
                name, phone, isPhonePrivate, email, isEmailPrivate, address, isAddressPrivate, tags);
        fail(error);
    }

    @Test
    public void addCommand_validData_correctlyConstructed() throws Exception {
        AddCommand command = new AddCommand(Name.EXAMPLE, Phone.EXAMPLE, true, Email.EXAMPLE, false,
                Address.EXAMPLE, true, EMPTY_STRING_SET);
        ReadOnlyPerson p = command.getPerson();

        // TODO: add comparison of tags to person.equals and equality methods to
        // individual fields that compare privacy to simplify this
        assertEquals(Name.EXAMPLE, p.getName().fullName);
        assertEquals(Phone.EXAMPLE, p.getPhone().value);
        assertTrue(p.getPhone().isPrivate());
        assertEquals(Email.EXAMPLE, p.getEmail().value);
        assertFalse(p.getEmail().isPrivate());
        assertEquals(Address.EXAMPLE, p.getAddress().value);
        assertTrue(p.getAddress().isPrivate());
        boolean isTagListEmpty = !p.getTags().iterator().hasNext();
        assertTrue(isTagListEmpty);
    }

    @Test
    public void addCommand_emptyAddressBook_addressBookContainsPerson() {
        Person p = TestUtil.generateTestPerson();
        AddCommand command = new AddCommand(p);
        AddressBook book = new AddressBook();
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();
        UniquePersonList people = book.getAllPersons();

        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(String.format(AddCommand.MESSAGE_SUCCESS, p), result.feedbackToUser);
    }

    @Test
    public void addCommand_addressBookAlreadyContainsPerson_addressBookUnmodified() throws Exception {
        Person p = TestUtil.generateTestPerson();
        AddressBook book = new AddressBook();
        book.addPerson(p);
        AddCommand command = new AddCommand(p);
        command.setData(book, EMPTY_PERSON_LIST);
        CommandResult result = command.execute();

        assertFalse(result.getRelevantPersons().isPresent());
        assertEquals(AddCommand.MESSAGE_DUPLICATE_PERSON, result.feedbackToUser);
        UniquePersonList people = book.getAllPersons();
        assertTrue(people.contains(p));
        assertEquals(1, people.immutableListView().size());
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static seedu.addressbook.util.TestUtil.getSize;
import static seedu.addressbook.util.TestUtil.isEmpty;
import static seedu.addressbook.util.TestUtil.isIdentical;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;
import seedu.addressbook.data.tag.Tag;

public class AddressBookTest {
    private Tag tagPrizeWinner;
    private Tag tagScientist;
    private Tag tagMathematician;
    private Tag tagEconomist;

    private Person aliceBetsy;
    private Person bobChaplin;
    private Person charlieDouglas;
    private Person davidElliot;

    private AddressBook defaultAddressBook;
    private AddressBook emptyAddressBook;


    @Before
    public void setUp() throws Exception {
        tagPrizeWinner   = new Tag(""prizewinner"");
        tagScientist     = new Tag(""scientist"");
        tagMathematician = new Tag(""mathematician"");
        tagEconomist     = new Tag(""economist"");

        aliceBetsy     = new Person(new Name(""Alice Betsy""),
                                    new Phone(""91235468"", false),
                                    new Email(""alice@nushackers.org"", false),
                                    new Address(""8 Computing Drive, Singapore"", false),
                                    Collections.singleton(tagMathematician));

        bobChaplin     = new Person(new Name(""Bob Chaplin""),
                                    new Phone(""94321500"", false),
                                    new Email(""bob@nusgreyhats.org"", false),
                                    new Address(""9 Computing Drive"", false),
                                    Collections.singleton(tagMathematician));

        charlieDouglas = new Person(new Name(""Charlie Douglas""),
                                    new Phone(""98751365"", false),
                                    new Email(""charlie@nusgdg.org"", false),
                                    new Address(""10 Science Drive"", false),
                                    Collections.singleton(tagScientist));

        davidElliot    = new Person(new Name(""David Elliot""),
                                    new Phone(""84512575"", false),
                                    new Email(""douglas@nuscomputing.com"", false),
                                    new Address(""11 Arts Link"", false),
                                    new HashSet<>(Arrays.asList(tagEconomist, tagPrizeWinner)));

        emptyAddressBook = new AddressBook();
        defaultAddressBook = new AddressBook(new UniquePersonList(aliceBetsy, bobChaplin));
    }

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void addPerson_personAlreadyInList_throwsDuplicatePersonException() throws Exception {
        thrown.expect(DuplicatePersonException.class);
        defaultAddressBook.addPerson(aliceBetsy);
    }

    @Test
    public void containsPerson() throws Exception {
        UniquePersonList personsWhoShouldBeIn = new UniquePersonList(aliceBetsy, bobChaplin);
        UniquePersonList personsWhoShouldNotBeIn = new UniquePersonList(charlieDouglas, davidElliot);

        for (Person personWhoShouldBeIn : personsWhoShouldBeIn) {
            assertTrue(defaultAddressBook.containsPerson(personWhoShouldBeIn));
        }
        for (Person personWhoShouldNotBeIn : personsWhoShouldNotBeIn) {
            assertFalse(defaultAddressBook.containsPerson(personWhoShouldNotBeIn));
        }

        UniquePersonList allPersons = new UniquePersonList(aliceBetsy, bobChaplin, charlieDouglas, davidElliot);

        for (Person person : allPersons) {
            assertFalse(emptyAddressBook.containsPerson(person));
        }
    }

    @Test
    public void removePerson_personExists_removesNormally() throws Exception {
        int numberOfPersonsBeforeRemoval = getSize(defaultAddressBook.getAllPersons());
        defaultAddressBook.removePerson(aliceBetsy);

        assertFalse(defaultAddressBook.containsPerson(aliceBetsy));

        int numberOfPersonsAfterRemoval = getSize(defaultAddressBook.getAllPersons());
        assertTrue(numberOfPersonsAfterRemoval == numberOfPersonsBeforeRemoval - 1);

    }

    @Test
    public void removePerson_personNotExists_throwsPersonNotFoundException() throws Exception {
        thrown.expect(PersonNotFoundException.class);
        defaultAddressBook.removePerson(charlieDouglas);
    }

    @Test
    public void clear() {
        defaultAddressBook.clear();

        assertTrue(isEmpty(defaultAddressBook.getAllPersons()));
    }

    @Test
    public void getAllPersons() throws Exception {
        UniquePersonList allPersons = defaultAddressBook.getAllPersons();
        UniquePersonList personsToCheck = new UniquePersonList(aliceBetsy, bobChaplin);

        assertTrue(isIdentical(allPersons, personsToCheck));
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.parser.Parser;
import seedu.addressbook.storage.StorageFile;
import seedu.addressbook.storage.StorageFile.InvalidStorageFilePathException;
import seedu.addressbook.storage.StorageFile.StorageOperationException;
import seedu.addressbook.ui.TextUi;


/**
 * Entry point of the Address Book application.
 * Initializes the application and starts the interaction with the user.
 */
public class Main {

    /** Version info of the program. */
    public static final String VERSION = ""AddressBook Level 2 - Version 1.0"";

    private TextUi ui;
    private StorageFile storage;
    private AddressBook addressBook;

    /** The list of person shown to the user most recently.  */
    private List<? extends ReadOnlyPerson> lastShownList = Collections.emptyList();


    public static void main(String... launchArgs) {
        new Main().run(launchArgs);
    }

    /** Runs the program until termination.  */
    public void run(String[] launchArgs) {
        start(launchArgs);
        runCommandLoopUntilExitCommand();
        exit();
    }

    /**
     * Sets up the required objects, loads up the data from the storage file, and prints the welcome message.
     *
     * @param launchArgs arguments supplied by the user at program launch
     *
     */
    private void start(String[] launchArgs) {
        try {
            this.ui = new TextUi();
            this.storage = initializeStorage(launchArgs);
            this.addressBook = storage.load();
            ui.showWelcomeMessage(VERSION, storage.getPath());

        } catch (InvalidStorageFilePathException | StorageOperationException e) {
            ui.showInitFailedMessage();
            /*
             * ==============NOTE TO STUDENTS=========================================================================
             * We are throwing a RuntimeException which is an 'unchecked' exception. Unchecked exceptions do not need
             * to be declared in the method signature.
             * The reason we are using an unchecked exception here is because the caller cannot reasonably be expected
             * to recover from an exception.
             * Cf https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html
             * =======================================================================================================
             */
            throw new RuntimeException(e);
        }
    }

    /** Prints the Goodbye message and exits. */
    private void exit() {
        ui.showGoodbyeMessage();
        System.exit(0);
    }

    /** Reads the user command and executes it, until the user issues the exit command.  */
    private void runCommandLoopUntilExitCommand() {
        Command command;
        do {
            String userCommandText = ui.getUserCommand();
            command = new Parser().parseCommand(userCommandText);
            CommandResult result = executeCommand(command);
            recordResult(result);
            ui.showResultToUser(result);

        } while (!ExitCommand.isExit(command));
    }

    /** Updates the {@link #lastShownList} if the result contains a list of Persons. */
    private void recordResult(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> personList = result.getRelevantPersons();
        if (personList.isPresent()) {
            lastShownList = personList.get();
        }
    }

    /**
     * Executes the command and returns the result.
     *
     * @param command user command
     * @return result of the command
     */
    private CommandResult executeCommand(Command command)  {
        try {
            command.setData(addressBook, lastShownList);
            CommandResult result = command.execute();
            storage.save(addressBook);
            return result;
        } catch (Exception e) {
            ui.showToUser(e.getMessage());
            throw new RuntimeException(e);
        }
    }

    /**
     * Creates the StorageFile object based on the user specified path (if any) or the default storage path.
     * @param launchArgs arguments supplied by the user at program launch
     * @throws InvalidStorageFilePathException if the target file path is incorrect.
     */
    private StorageFile initializeStorage(String[] launchArgs) throws InvalidStorageFilePathException {
        boolean isStorageFileSpecifiedByUser = launchArgs.length > 0;
        return isStorageFileSpecifiedByUser ? new StorageFile(launchArgs[0]) : new StorageFile();
    }


}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.ui;

import static seedu.addressbook.common.Messages.MESSAGE_GOODBYE;
import static seedu.addressbook.common.Messages.MESSAGE_INIT_FAILED;
import static seedu.addressbook.common.Messages.MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE;
import static seedu.addressbook.common.Messages.MESSAGE_USING_STORAGE_FILE;
import static seedu.addressbook.common.Messages.MESSAGE_WELCOME;

import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Scanner;

import seedu.addressbook.commands.CommandResult;
import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Text UI of the application.
 */
public class TextUi {

    /** A decorative prefix added to the beginning of lines printed by AddressBook */
    private static final String LINE_PREFIX = ""|| "";

    /** A platform independent line separator. */
    private static final String LS = System.lineSeparator();

    private static final String DIVIDER = ""==================================================="";

    /** Format of indexed list item */
    private static final String MESSAGE_INDEXED_LIST_ITEM = ""\t%1$d. %2$s"";


    /** Offset required to convert between 1-indexing and 0-indexing.  */
    public static final int DISPLAYED_INDEX_OFFSET = 1;

    /** Format of a comment input line. Comment lines are silently consumed when reading user input. */
    private static final String COMMENT_LINE_FORMAT_REGEX = ""#.*"";

    private final Scanner in;
    private final PrintStream out;

    public TextUi() {
        this(System.in, System.out);
    }

    public TextUi(InputStream in, PrintStream out) {
        this.in = new Scanner(in);
        this.out = out;
    }

    /**
     * Returns true if the user input line should be ignored.
     * Input should be ignored if it is parsed as a comment, is only whitespace, or is empty.
     *
     * @param rawInputLine full raw user input line.
     * @return true if the entire user input line should be ignored.
     */
    private boolean shouldIgnore(String rawInputLine) {
        return rawInputLine.trim().isEmpty() || isCommentLine(rawInputLine);
    }

    /**
     * Returns true if the user input line is a comment line.
     *
     * @param rawInputLine full raw user input line.
     * @return true if input line is a comment.
     */
    private boolean isCommentLine(String rawInputLine) {
        return rawInputLine.trim().matches(COMMENT_LINE_FORMAT_REGEX);
    }

    /**
     * Prompts for the command and reads the text entered by the user.
     * Ignores empty, pure whitespace, and comment lines.
     * Echos the command back to the user.
     * @return command (full line) entered by the user
     */
    public String getUserCommand() {
        out.print(LINE_PREFIX + ""Enter command: "");
        String fullInputLine = in.nextLine();

        // silently consume all ignored lines
        while (shouldIgnore(fullInputLine)) {
            fullInputLine = in.nextLine();
        }

        showToUser(""[Command entered:"" + fullInputLine + ""]"");
        return fullInputLine;
    }


    public void showWelcomeMessage(String version, String storageFilePath) {
        String storageFileInfo = String.format(MESSAGE_USING_STORAGE_FILE, storageFilePath);
        showToUser(
                DIVIDER,
                DIVIDER,
                MESSAGE_WELCOME,
                version,
                MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE,
                storageFileInfo,
                DIVIDER);
    }

    public void showGoodbyeMessage() {
        showToUser(MESSAGE_GOODBYE, DIVIDER, DIVIDER);
    }


    public void showInitFailedMessage() {
        showToUser(MESSAGE_INIT_FAILED, DIVIDER, DIVIDER);
    }

    /** Shows message(s) to the user */
    public void showToUser(String... message) {
        for (String m : message) {
            out.println(LINE_PREFIX + m.replace(""\n"", LS + LINE_PREFIX));
        }
    }

    /**
     * Shows the result of a command execution to the user. Includes additional formatting to demarcate different
     * command execution segments.
     */
    public void showResultToUser(CommandResult result) {
        final Optional<List<? extends ReadOnlyPerson>> resultPersons = result.getRelevantPersons();
        if (resultPersons.isPresent()) {
            showPersonListView(resultPersons.get());
        }
        showToUser(result.feedbackToUser, DIVIDER);
    }

    /**
     * Shows a list of persons to the user, formatted as an indexed list.
     * Private contact details are hidden.
     */
    private void showPersonListView(List<? extends ReadOnlyPerson> persons) {
        final List<String> formattedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : persons) {
            formattedPersons.add(person.getAsTextHidePrivate());
        }
        showToUserAsIndexedList(formattedPersons);
    }

    /** Shows a list of strings to the user, formatted as an indexed list. */
    private void showToUserAsIndexedList(List<String> list) {
        showToUser(getIndexedListForViewing(list));
    }

    /** Formats a list of strings as a viewable indexed list. */
    private static String getIndexedListForViewing(List<String> listItems) {
        final StringBuilder formatted = new StringBuilder();
        int displayIndex = 0 + DISPLAYED_INDEX_OFFSET;
        for (String listItem : listItems) {
            formatted.append(getIndexedListItem(displayIndex, listItem)).append(""\n"");
            displayIndex++;
        }
        return formatted.toString();
    }

    /**
     * Formats a string as a viewable indexed list item.
     *
     * @param visibleIndex visible index for this listing
     */
    private static String getIndexedListItem(int visibleIndex, String listItem) {
        return String.format(MESSAGE_INDEXED_LIST_ITEM, visibleIndex, listItem);
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.parser;

import static seedu.addressbook.common.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.addressbook.common.Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.addressbook.commands.AddCommand;
import seedu.addressbook.commands.ClearCommand;
import seedu.addressbook.commands.Command;
import seedu.addressbook.commands.DeleteCommand;
import seedu.addressbook.commands.ExitCommand;
import seedu.addressbook.commands.FindCommand;
import seedu.addressbook.commands.HelpCommand;
import seedu.addressbook.commands.IncorrectCommand;
import seedu.addressbook.commands.ListCommand;
import seedu.addressbook.commands.ViewAllCommand;
import seedu.addressbook.commands.ViewCommand;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Parses user input.
 */
public class Parser {

    public static final Pattern PERSON_INDEX_ARGS_FORMAT = Pattern.compile(""(?<targetIndex>.+)"");

    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile(""(?<keywords>\\S+(?:\\s+\\S+)*)""); // one or more keywords separated by whitespace

    public static final Pattern PERSON_DATA_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile(""(?<name>[^/]+)""
                    + "" (?<isPhonePrivate>p?)p/(?<phone>[^/]+)""
                    + "" (?<isEmailPrivate>p?)e/(?<email>[^/]+)""
                    + "" (?<isAddressPrivate>p?)a/(?<address>[^/]+)""
                    + ""(?<tagArguments>(?: t/[^/]+)*)""); // variable number of tags


    /**
     * Used for initial separation of command word and args.
     */
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile(""(?<commandWord>\\S+)(?<arguments>.*)"");

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group(""commandWord"");
        final String arguments = matcher.group(""arguments"");

        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return prepareFind(arguments);

        case ListCommand.COMMAND_WORD:
            return new ListCommand();

        case ViewCommand.COMMAND_WORD:
            return prepareView(arguments);

        case ViewAllCommand.COMMAND_WORD:
            return prepareViewAll(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD: // Fallthrough
        default:
            return new HelpCommand();
        }
    }

    /**
     * Parses arguments in the context of the add person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        try {
            return new AddCommand(
                    matcher.group(""name""),

                    matcher.group(""phone""),
                    isPrivatePrefixPresent(matcher.group(""isPhonePrivate"")),

                    matcher.group(""email""),
                    isPrivatePrefixPresent(matcher.group(""isEmailPrivate"")),

                    matcher.group(""address""),
                    isPrivatePrefixPresent(matcher.group(""isAddressPrivate"")),

                    getTagsFromArgs(matcher.group(""tagArguments""))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Returns true if the private prefix is present for a contact detail in the add command's arguments string.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return matchedPrefix.equals(""p"");
    }

    /**
     * Extracts the new person's tags from the add command's tag arguments string.
     * Merges duplicate tag strings.
     */
    private static Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst("" t/"", """").split("" t/""));
        return new HashSet<>(tagStrings);
    }


    /**
     * Parses arguments in the context of the delete person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {
        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new DeleteCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareView(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses arguments in the context of the view all command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareViewAll(String args) {

        try {
            final int targetIndex = parseArgsAsDisplayedIndex(args);
            return new ViewAllCommand(targetIndex);
        } catch (ParseException pe) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ViewAllCommand.MESSAGE_USAGE));
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand(MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

    /**
     * Parses the given arguments string as a single index number.
     *
     * @param args arguments string to parse as index number
     * @return the parsed index number
     * @throws ParseException if no region of the args string could be found for the index
     * @throws NumberFormatException the args string region is not a valid number
     */
    private int parseArgsAsDisplayedIndex(String args) throws ParseException, NumberFormatException {
        final Matcher matcher = PERSON_INDEX_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            throw new ParseException(""Could not find index number to parse"");
        }
        return Integer.parseInt(matcher.group(""targetIndex""));
    }


    /**
     * Parses arguments in the context of the find person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group(""keywords"").split(""\\s+"");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

    /**
     * Signals that the user input could not be parsed.
     */
    public static class ParseException extends Exception {
        ParseException(String message) {
            super(message);
        }
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.storage;

import static seedu.addressbook.parser.Parser.PERSON_DATA_ARGS_FORMAT;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;
import seedu.addressbook.storage.StorageFile.StorageOperationException;

/**
 * Decodes the storage data file into an {@code AddressBook} object.
 */
public class AddressBookDecoder {

    /**
     * Decodes {@code encodedAddressBook} into an {@code AddressBook} containing the decoded persons.
     *
     * @throws IllegalValueException if any of the fields in any encoded person string is invalid.
     * @throws StorageOperationException if the {@code encodedAddressBook} is in an invalid format.
     */
    public static AddressBook decodeAddressBook(List<String> encodedAddressBook)
            throws IllegalValueException, StorageOperationException {
        final List<Person> decodedPersons = new ArrayList<>();
        for (String encodedPerson : encodedAddressBook) {
            decodedPersons.add(decodePersonFromString(encodedPerson));
        }
        return new AddressBook(new UniquePersonList(decodedPersons));
    }

    /**
     * Decodes {@code encodedPerson} into a {@code Person}.
     *
     * @throws IllegalValueException if any field in the {@code encodedPerson} is invalid.
     * @throws StorageOperationException if {@code encodedPerson} is in an invalid format.
     */
    private static Person decodePersonFromString(String encodedPerson)
            throws IllegalValueException, StorageOperationException {
        final Matcher matcher = PERSON_DATA_ARGS_FORMAT.matcher(encodedPerson);
        if (!matcher.matches()) {
            throw new StorageOperationException(""Encoded person in invalid format. Unable to decode."");
        }

        return new Person(
                new Name(matcher.group(""name"")),
                new Phone(matcher.group(""phone""), isPrivatePrefixPresent(matcher.group(""isPhonePrivate""))),
                new Email(matcher.group(""email""), isPrivatePrefixPresent(matcher.group(""isEmailPrivate""))),
                new Address(matcher.group(""address""), isPrivatePrefixPresent(matcher.group(""isAddressPrivate""))),
                getTagsFromEncodedPerson(matcher.group(""tagArguments""))
        );
    }

    /**
     * Returns true if {@code matchedPrefix} is equal to the private prefix for contact details.
     */
    private static boolean isPrivatePrefixPresent(String matchedPrefix) {
        return ""p"".equals(matchedPrefix);
    }

    /**
     * Extracts the {@code Tag}s from the {@code tagArguments} string.
     * Merges duplicate tag strings.
     */
    private static Set<Tag> getTagsFromEncodedPerson(String tagArguments) throws IllegalValueException {
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }

        // replace first delimiter prefix, then split
        final String[] tagStrings = tagArguments.replaceFirst("" t/"", """").split("" t/"");
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tagStrings) {
            tagSet.add(new Tag(tagName));
        }

        return tagSet;
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.storage;

import java.util.ArrayList;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.Person;

/**
 * Encodes the {@code AddressBook} object into a data file for storage.
 */
public class AddressBookEncoder {

    /**
     * Encodes all the {@code Person} in the {@code toSave} into a list of decodable and readable string presentation
     * for storage.
     */
    public static List<String> encodeAddressBook(AddressBook toSave) {
        final List<String> encodedPersons = new ArrayList<>();
        toSave.getAllPersons().forEach(person -> encodedPersons.add(encodePersonToString(person)));
        return encodedPersons;
    }

    /**
     * Encodes the {@code person} into a decodable and readable string representation.
     */
    private static String encodePersonToString(Person person) {
        final StringBuilder encodedPersonBuilder = new StringBuilder();

        encodedPersonBuilder.append(person.getName());

        encodedPersonBuilder.append(person.getPhone().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""p/"").append(person.getPhone().value);

        encodedPersonBuilder.append(person.getEmail().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""e/"").append(person.getEmail().value);

        encodedPersonBuilder.append(person.getAddress().isPrivate() ? "" p"" : "" "");
        encodedPersonBuilder.append(""a/"").append(person.getAddress().value);

        person.getTags().forEach(tag -> encodedPersonBuilder.append("" t/"").append(tag.tagName));

        return encodedPersonBuilder.toString();
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.storage;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents the file used to store address book data.
 */
public class StorageFile {

    /** Default file path used if the user doesn't provide the file name. */
    public static final String DEFAULT_STORAGE_FILEPATH = ""addressbook.txt"";


    public final Path path;

    /**
     * @throws InvalidStorageFilePathException if the default path is invalid
     */
    public StorageFile() throws InvalidStorageFilePathException {
        this(DEFAULT_STORAGE_FILEPATH);
    }

    /**
     * @throws InvalidStorageFilePathException if the given file path is invalid
     */
    public StorageFile(String filePath) throws InvalidStorageFilePathException {
        path = Paths.get(filePath);
        if (!isValidPath(path)) {
            throw new InvalidStorageFilePathException(""Storage file should end with '.txt'"");
        }
    }

    /**
     * Returns true if the given path is acceptable as a storage file.
     * The file path is considered acceptable if it ends with '.txt'
     */
    private static boolean isValidPath(Path filePath) {
        return filePath.toString().endsWith("".txt"");
    }

    /**
     * Saves the {@code addressBook} data to the storage file.
     *
     * @throws StorageOperationException if there were errors converting and/or storing data to file.
     */
    public void save(AddressBook addressBook) throws StorageOperationException {
        try {
            List<String> encodedAddressBook = AddressBookEncoder.encodeAddressBook(addressBook);
            Files.write(path, encodedAddressBook);
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        }
    }

    /**
     * Loads the {@code AddressBook} data from this storage file, and then returns it.
     * Returns an empty {@code AddressBook} if the file does not exist, or is not a regular file.
     *
     * @throws StorageOperationException if there were errors reading and/or converting data from file.
     */
    public AddressBook load() throws StorageOperationException {

        if (!Files.exists(path) || !Files.isRegularFile(path)) {
            return new AddressBook();
        }

        try {
            return AddressBookDecoder.decodeAddressBook(Files.readAllLines(path));
        } catch (FileNotFoundException fnfe) {
            throw new AssertionError(""A non-existent file scenario is already handled earlier."");
        // other errors
        } catch (IOException ioe) {
            throw new StorageOperationException(""Error writing to file: "" + path);
        } catch (IllegalValueException ive) {
            throw new StorageOperationException(""File contains illegal data values; data type constraints not met"");
        }
    }

    public String getPath() {
        return path.toString();
    }

    /* Note: Note the use of nested classes below.
     * More info https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html
     */

    /**
     * Signals that the given file path does not fulfill the storage filepath constraints.
     */
    public static class InvalidStorageFilePathException extends IllegalValueException {
        public InvalidStorageFilePathException(String message) {
            super(message);
        }
    }

    /**
     * Signals that some error has occured while trying to convert and read/write data between the application
     * and the storage file.
     */
    public static class StorageOperationException extends Exception {
        public StorageOperationException(String message) {
            super(message);
        }
    }


}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.common;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * Utility methods
 */
public class Utils {

    /**
     * Returns true if any of the given items are null.
     */
    public static boolean isAnyNull(Object... items) {
        if (items == null) {
            return false;
        }
        for (Object item : items) {
            if (item == null) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if every element the given collection are unique by {@link Object#equals(Object)}.
     */
    public static boolean elementsAreUnique(Collection<?> items) {
        final Set<Object> testSet = new HashSet<>();
        for (Object item : items) {
            final boolean itemAlreadyExists = !testSet.add(item); // see Set documentation
            if (itemAlreadyExists) {
                return false;
            }
        }
        return true;
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.common;

/**
 * Container for user visible messages.
 */
public class Messages {

    public static final String MESSAGE_GOODBYE = ""Good bye!"";
    public static final String MESSAGE_INIT_FAILED = ""Failed to initialise address book application. Exiting..."";
    public static final String MESSAGE_INVALID_COMMAND_FORMAT = ""Invalid command format! \n%1$s"";
    public static final String MESSAGE_INVALID_PERSON_DISPLAYED_INDEX = ""The person index provided is invalid"";
    public static final String MESSAGE_PERSON_NOT_IN_ADDRESSBOOK = ""Person could not be found in address book"";
    public static final String MESSAGE_PERSONS_LISTED_OVERVIEW = ""%1$d persons listed!"";
    public static final String MESSAGE_PROGRAM_LAUNCH_ARGS_USAGE = ""Launch command format: "" +
            ""java seedu.addressbook.Main [STORAGE_FILE_PATH]"";
    public static final String MESSAGE_WELCOME = ""Welcome to your Address Book!"";
    public static final String MESSAGE_USING_STORAGE_FILE = ""Using storage file : %1$s"";
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows details of the person identified using the last displayed index.
 * Private contact details are not shown.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = ""view"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextHidePrivate()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;


/**
 * Deletes a person identified using it's last displayed index from the address book.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = ""delete"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Deletes the person identified by the index number used in the last person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_DELETE_PERSON_SUCCESS = ""Deleted Person: %1$s"";


    public DeleteCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            addressBook.removePerson(target);
            return new CommandResult(String.format(MESSAGE_DELETE_PERSON_SUCCESS, target));

        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        } catch (PersonNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
        }
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import seedu.addressbook.data.person.ReadOnlyPerson;

import java.util.List;


/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = ""list"";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + "": Displays all persons in the address book as a list with index numbers.\n""
            + ""Example: "" + COMMAND_WORD;


    @Override
    public CommandResult execute() {
        List<ReadOnlyPerson> allPersons = addressBook.getAllPersons().immutableListView();
        return new CommandResult(getMessageForPersonListShownSummary(allPersons), allPersons);
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.person.ReadOnlyPerson;


/**
 * Shows all details of the person identified using the last displayed index.
 * Private contact details are shown.
 */
public class ViewAllCommand extends Command {

    public static final String COMMAND_WORD = ""viewall"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Views the non-private details of the person ""
            + ""identified by the index number in the last shown person listing.\n""
            + ""Parameters: INDEX\n""
            + ""Example: "" + COMMAND_WORD + "" 1"";

    public static final String MESSAGE_VIEW_PERSON_DETAILS = ""Viewing person: %1$s"";


    public ViewAllCommand(int targetVisibleIndex) {
        super(targetVisibleIndex);
    }


    @Override
    public CommandResult execute() {
        try {
            final ReadOnlyPerson target = getTargetPerson();
            if (!addressBook.containsPerson(target)) {
                return new CommandResult(Messages.MESSAGE_PERSON_NOT_IN_ADDRESSBOOK);
            }
            return new CommandResult(String.format(MESSAGE_VIEW_PERSON_DETAILS, target.getAsTextShowAll()));
        } catch (IndexOutOfBoundsException ie) {
            return new CommandResult(Messages.MESSAGE_INVALID_PERSON_DISPLAYED_INDEX);
        }
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

/**
 * Clears the address book.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = ""clear"";
    public static final String MESSAGE_USAGE = ""Clears address book permanently.\n""
            + ""Example: "" + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = ""Address book has been cleared!"";

    @Override
    public CommandResult execute() {
        addressBook.clear();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import seedu.addressbook.common.Messages;
import seedu.addressbook.data.AddressBook;
import seedu.addressbook.data.person.ReadOnlyPerson;

import java.util.List;

import static seedu.addressbook.ui.TextUi.DISPLAYED_INDEX_OFFSET;

/**
 * Represents an executable command.
 */
public class Command {
    protected AddressBook addressBook;
    protected List<? extends ReadOnlyPerson> relevantPersons;
    private int targetIndex = -1;

    /**
     * @param targetIndex last visible listing index of the target person
     */
    public Command(int targetIndex) {
        this.setTargetIndex(targetIndex);
    }

    protected Command() {
    }

    /**
     * Constructs a feedback message to summarise an operation that displayed a listing of persons.
     *
     * @param personsDisplayed used to generate summary
     * @return summary message for persons displayed
     */
    public static String getMessageForPersonListShownSummary(List<? extends ReadOnlyPerson> personsDisplayed) {
        return String.format(Messages.MESSAGE_PERSONS_LISTED_OVERVIEW, personsDisplayed.size());
    }

    /**
     * Executes the command and returns the result.
     */
    public CommandResult execute(){
        throw new UnsupportedOperationException(""This method is to be implemented by child classes"");
    };

    /**
     * Supplies the data the command will operate on.
     */
    public void setData(AddressBook addressBook, List<? extends ReadOnlyPerson> relevantPersons) {
        this.addressBook = addressBook;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Extracts the the target person in the last shown list from the given arguments.
     *
     * @throws IndexOutOfBoundsException if the target index is out of bounds of the last viewed listing
     */
    protected ReadOnlyPerson getTargetPerson() throws IndexOutOfBoundsException {
        return relevantPersons.get(getTargetIndex() - DISPLAYED_INDEX_OFFSET);
    }

    public int getTargetIndex() {
        return targetIndex;
    }

    public void setTargetIndex(int targetIndex) {
        this.targetIndex = targetIndex;
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.addressbook.data.exception.IllegalValueException;
import seedu.addressbook.data.person.Address;
import seedu.addressbook.data.person.Email;
import seedu.addressbook.data.person.Name;
import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.Phone;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.tag.Tag;

/**
 * Adds a person to the address book.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = ""add"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Adds a person to the address book. ""
            + ""Contact details can be marked private by prepending 'p' to the prefix.\n""
            + ""Parameters: NAME [p]p/PHONE [p]e/EMAIL [p]a/ADDRESS  [t/TAG]...\n""
            + ""Example: "" + COMMAND_WORD
            + "" John Doe p/98765432 e/johnd@gmail.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney"";

    public static final String MESSAGE_SUCCESS = ""New person added: %1$s"";
    public static final String MESSAGE_DUPLICATE_PERSON = ""This person already exists in the address book"";

    private final Person toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name,
                      String phone, boolean isPhonePrivate,
                      String email, boolean isEmailPrivate,
                      String address, boolean isAddressPrivate,
                      Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Person(
                new Name(name),
                new Phone(phone, isPhonePrivate),
                new Email(email, isEmailPrivate),
                new Address(address, isAddressPrivate),
                tagSet
        );
    }

    public AddCommand(Person toAdd) {
        this.toAdd = toAdd;
    }

    public ReadOnlyPerson getPerson() {
        return toAdd;
    }

    @Override
    public CommandResult execute() {
        try {
            addressBook.addPerson(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniquePersonList.DuplicatePersonException dpe) {
            return new CommandResult(MESSAGE_DUPLICATE_PERSON);
        }
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;


/**
 * Shows help instructions.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = ""help"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Shows program usage instructions.\n""
            + ""Example: "" + COMMAND_WORD;

    @Override
    public CommandResult execute() {
        return new CommandResult(
                AddCommand.MESSAGE_USAGE
                + ""\n"" + DeleteCommand.MESSAGE_USAGE
                + ""\n"" + ClearCommand.MESSAGE_USAGE
                + ""\n"" + FindCommand.MESSAGE_USAGE
                + ""\n"" + ListCommand.MESSAGE_USAGE
                + ""\n"" + ViewCommand.MESSAGE_USAGE
                + ""\n"" + ViewAllCommand.MESSAGE_USAGE
                + ""\n"" + HelpCommand.MESSAGE_USAGE
                + ""\n"" + ExitCommand.MESSAGE_USAGE
        );
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;


/**
 * Represents an incorrect command. Upon execution, produces some feedback to the user.
 */
public class IncorrectCommand extends Command {

    public final String feedbackToUser;

    public IncorrectCommand(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
    }

    @Override
    public CommandResult execute() {
        return new CommandResult(feedbackToUser);
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import seedu.addressbook.data.person.ReadOnlyPerson;

/**
 * Finds and lists all persons in address book whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = ""find"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Finds all persons whose names contain any of ""
            + ""the specified keywords (case-sensitive) and displays them as a list with index numbers.\n""
            + ""Parameters: KEYWORD [MORE_KEYWORDS]...\n""
            + ""Example: "" + COMMAND_WORD + "" alice bob charlie"";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    /**
     * Returns a copy of keywords in this command.
     */
    public Set<String> getKeywords() {
        return new HashSet<>(keywords);
    }

    @Override
    public CommandResult execute() {
        final List<ReadOnlyPerson> personsFound = getPersonsWithNameContainingAnyKeyword(keywords);
        return new CommandResult(getMessageForPersonListShownSummary(personsFound), personsFound);
    }

    /**
     * Retrieves all persons in the address book whose names contain some of the specified keywords.
     *
     * @param keywords for searching
     * @return list of persons found
     */
    private List<ReadOnlyPerson> getPersonsWithNameContainingAnyKeyword(Set<String> keywords) {
        final List<ReadOnlyPerson> matchedPersons = new ArrayList<>();
        for (ReadOnlyPerson person : addressBook.getAllPersons()) {
            final Set<String> wordsInName = new HashSet<>(person.getName().getWordsInName());
            if (!Collections.disjoint(wordsInName, keywords)) {
                matchedPersons.add(person);
            }
        }
        return matchedPersons;
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

/**
 * Terminates the program.
 */
public class ExitCommand extends Command {

    public static final String COMMAND_WORD = ""exit"";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "": Exits the program.\n""
            + ""Example: "" + COMMAND_WORD;
    public static final String MESSAGE_EXIT_ACKNOWEDGEMENT = ""Exiting Address Book as requested ..."";

    @Override
    public CommandResult execute() {
        return new CommandResult(MESSAGE_EXIT_ACKNOWEDGEMENT);
    }

    public static boolean isExit(Command command) {
        return command instanceof ExitCommand; // instanceof returns false if it is null
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.commands;

import seedu.addressbook.data.person.ReadOnlyPerson;

import java.util.List;
import java.util.Optional;

/**
 * Represents the result of a command execution.
 */
public class CommandResult {

    /** The feedback message to be shown to the user. Contains a description of the execution result */
    public final String feedbackToUser;

    /** The list of persons that was produced by the command */
    private final List<? extends ReadOnlyPerson> relevantPersons;

    public CommandResult(String feedbackToUser) {
        this.feedbackToUser = feedbackToUser;
        relevantPersons = null;
    }

    public CommandResult(String feedbackToUser, List<? extends ReadOnlyPerson> relevantPersons) {
        this.feedbackToUser = feedbackToUser;
        this.relevantPersons = relevantPersons;
    }

    /**
     * Returns a list of persons relevant to the command command result, if any.
     */
    public Optional<List<? extends ReadOnlyPerson>> getRelevantPersons() {
        return Optional.ofNullable(relevantPersons);
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data;

import seedu.addressbook.data.person.Person;
import seedu.addressbook.data.person.ReadOnlyPerson;
import seedu.addressbook.data.person.UniquePersonList;
import seedu.addressbook.data.person.UniquePersonList.DuplicatePersonException;
import seedu.addressbook.data.person.UniquePersonList.PersonNotFoundException;

/**
 * Represents the entire address book. Contains the data of the address book.
 */
public class AddressBook {

    private final UniquePersonList allPersons;

    /**
     * Creates an empty address book.
     */
    public AddressBook() {
        allPersons = new UniquePersonList();
    }

    /**
     * Constructs an address book with the given data.
     *
     * @param persons external changes to this will not affect this address book
     */
    public AddressBook(UniquePersonList persons) {
        this.allPersons = new UniquePersonList(persons);
    }

    /**
     * Adds a person to the address book.
     *
     * @throws DuplicatePersonException if an equivalent person already exists.
     */
    public void addPerson(Person toAdd) throws DuplicatePersonException {
        allPersons.add(toAdd);
    }

    /**
     * Returns true if an equivalent person exists in the address book.
     */
    public boolean containsPerson(ReadOnlyPerson key) {
        return allPersons.contains(key);
    }

    /**
     * Removes the equivalent person from the address book.
     *
     * @throws PersonNotFoundException if no such Person could be found.
     */
    public void removePerson(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        allPersons.remove(toRemove);
    }

    /**
     * Clears all persons and tags from the address book.
     */
    public void clear() {
        allPersons.clear();
    }

    /**
     * Returns a new UniquePersonList of all persons in the address book at the time of the call.
     */
    public UniquePersonList getAllPersons() {
        return new UniquePersonList(allPersons);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AddressBook // instanceof handles nulls
                        && this.allPersons.equals(((AddressBook) other).allPersons));
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's phone number in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidPhone(String)}
 */
public class Phone {

    public static final String EXAMPLE = ""123456789"";
    public static final String MESSAGE_PHONE_CONSTRAINTS = ""Person phone numbers should only contain numbers"";
    public static final String PHONE_VALIDATION_REGEX = ""\\d+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given phone number.
     *
     * @throws IllegalValueException if given phone string is invalid.
     */
    public Phone(String phone, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedPhone = phone.trim();
        if (!isValidPhone(trimmedPhone)) {
            throw new IllegalValueException(MESSAGE_PHONE_CONSTRAINTS);
        }
        this.value = trimmedPhone;
    }

    /**
     * Returns true if the given string is a valid person phone number.
     */
    public static boolean isValidPhone(String test) {
        return test.matches(PHONE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Phone // instanceof handles nulls
                && this.value.equals(((Phone) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's email in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidEmail(String)}
 */
public class Email {

    public static final String EXAMPLE = ""valid@e.mail"";
    public static final String MESSAGE_EMAIL_CONSTRAINTS =
            ""Person emails should be 2 alphanumeric/period strings separated by '@'"";
    public static final String EMAIL_VALIDATION_REGEX = ""[\\w\\.]+@[\\w\\.]+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given email.
     *
     * @throws IllegalValueException if given email address string is invalid.
     */
    public Email(String email, boolean isPrivate) throws IllegalValueException {
        this.isPrivate = isPrivate;
        String trimmedEmail = email.trim();
        if (!isValidEmail(trimmedEmail)) {
            throw new IllegalValueException(MESSAGE_EMAIL_CONSTRAINTS);
        }
        this.value = trimmedEmail;
    }

    /**
     * Returns true if the given string is a valid person email.
     */
    public static boolean isValidEmail(String test) {
        return test.matches(EMAIL_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Email // instanceof handles nulls
                && this.value.equals(((Email) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }


    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.person;

import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * A read-only immutable interface for a Person in the addressbook.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyPerson {

    Name getName();
    Phone getPhone();
    Email getEmail();
    Address getAddress();

    /**
     * Returns a new TagSet that is a deep copy of the internal TagSet,
     * changes on the returned set will not affect the person's internal tags.
     */
    Set<Tag> getTags();

    /**
     * Returns true if both persons have the same identity fields (name and telephone).
     */
    default boolean isSamePerson(ReadOnlyPerson other) {
        return (other == this)
                || (other != null
                    && other.getName().equals(this.getName())
                    && other.getPhone().equals(this.getPhone()));
    }

    /**
     * Returns true if all data in this object is the same as that in another
     * (Note: interfaces cannot override .equals)
     */
    default boolean hasSameData(ReadOnlyPerson other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                    && other.getName().equals(this.getName()) // state checks here onwards
                    && other.getPhone().equals(this.getPhone())
                    && other.getEmail().equals(this.getEmail())
                    && other.getAddress().equals(this.getAddress())
                    && other.getTags().equals(this.getTags()));
    }

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsTextShowAll() {
        final StringBuilder builder = new StringBuilder();
        final String detailIsPrivate = ""(private) "";
        builder.append(getName())
                .append("" Phone: "");
        if (getPhone().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getPhone())
                .append("" Email: "");
        if (getEmail().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getEmail())
                .append("" Address: "");
        if (getAddress().isPrivate()) {
            builder.append(detailIsPrivate);
        }
        builder.append(getAddress())
                .append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }

    /**
     * Formats a person as text, showing only non-private contact details.
     */
    default String getAsTextHidePrivate() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (!getPhone().isPrivate()) {
            builder.append("" Phone: "").append(getPhone());
        }
        if (!getEmail().isPrivate()) {
            builder.append("" Email: "").append(getEmail());
        }
        if (!getAddress().isPrivate()) {
            builder.append("" Address: "").append(getAddress());
        }
        builder.append("" Tags: "");
        for (Tag tag : getTags()) {
            builder.append(tag);
        }
        return builder.toString();
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.person;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import seedu.addressbook.common.Utils;
import seedu.addressbook.data.exception.DuplicateDataException;



/**
 * A list of persons. Does not allow null elements or duplicates.
 *
 * @see Person#equals(Object)
 * @see Utils#elementsAreUnique(Collection)
 */
public class UniquePersonList implements Iterable<Person> {



    private final List<Person> internalList = new ArrayList<>();

    /**
     * Constructs empty person list.
     */
    public UniquePersonList() {}

    /**
     * Constructs a person list with the given persons.
     */
    public UniquePersonList(Person... persons) throws DuplicatePersonException {
        final List<Person> initialTags = Arrays.asList(persons);
        if (!Utils.elementsAreUnique(initialTags)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(initialTags);
    }

    /**
     * Constructs a list from the items in the given collection.
     * @param persons a collection of persons
     * @throws DuplicatePersonException if the {@code persons} contains duplicate persons
     */
    public UniquePersonList(Collection<Person> persons) throws DuplicatePersonException {
        if (!Utils.elementsAreUnique(persons)) {
            throw new DuplicatePersonException();
        }
        internalList.addAll(persons);
    }

    /**
     * Constructs a shallow copy of the list.
     */
    public UniquePersonList(UniquePersonList source) {
        internalList.addAll(source.internalList);
    }

    /**
     * Returns an unmodifiable java List view with elements cast as immutable {@link ReadOnlyPerson}s.
     * For use with other methods/libraries.
     * Any changes to the internal list/elements are immediately visible in the returned list.
     */
    public List<ReadOnlyPerson> immutableListView() {
        return Collections.unmodifiableList(internalList);
    }


    /**
     * Checks if the list contains an equivalent person as the given argument.
     * The {@link ReadOnlyPerson#isSamePerson} method is used for this comparison, which
     * defines a weaker notion of equality.
     */
    public boolean contains(ReadOnlyPerson toCheck) {
        for (Person p : internalList) {
            if (p.isSamePerson(toCheck)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a person to the list.
     *
     * @throws DuplicatePersonException if the person to add is a duplicate of an existing person in the list.
     *    The @link{ReadOnlyPerson#isSamePerson} method is used for this comparison,
     *    which defines a weaker notion of equality.
     */
    public void add(Person toAdd) throws DuplicatePersonException {
        if (contains(toAdd)) {
            throw new DuplicatePersonException();
        }
        internalList.add(toAdd);
    }

    /**
     * Removes the equivalent person from the list.
     *
     * @throws PersonNotFoundException if no such person could be found in the list.
     */
    public void remove(ReadOnlyPerson toRemove) throws PersonNotFoundException {
        final boolean personFoundAndDeleted = internalList.remove(toRemove);
        if (!personFoundAndDeleted) {
            throw new PersonNotFoundException();
        }
    }

    /**
     * Clears all persons in list.
     */
    public void clear() {
        internalList.clear();
    }

    @Override
    public Iterator<Person> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniquePersonList // instanceof handles nulls
                        && this.internalList.equals(((UniquePersonList) other).internalList));
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicatePersonException extends DuplicateDataException {
        protected DuplicatePersonException() {
            super(""Operation would result in duplicate persons"");
        }
    }

    /**
     * Signals that an operation targeting a specified person in the list would fail because
     * there is no such matching person in the list.
     */
    public static class PersonNotFoundException extends Exception {}
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Person's address in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidAddress(String)}
 */
public class Address {

    public static final String EXAMPLE = ""123, some street"";
    public static final String MESSAGE_ADDRESS_CONSTRAINTS = ""Person addresses can be in any format"";
    public static final String ADDRESS_VALIDATION_REGEX = "".+"";

    public final String value;
    private boolean isPrivate;

    /**
     * Validates given address.
     *
     * @throws IllegalValueException if given address string is invalid.
     */
    public Address(String address, boolean isPrivate) throws IllegalValueException {
        String trimmedAddress = address.trim();
        this.isPrivate = isPrivate;
        if (!isValidAddress(trimmedAddress)) {
            throw new IllegalValueException(MESSAGE_ADDRESS_CONSTRAINTS);
        }
        this.value = trimmedAddress;
    }

    /**
     * Returns true if a given string is a valid person address.
     */
    public static boolean isValidAddress(String test) {
        return test.matches(ADDRESS_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Address // instanceof handles nulls
                && this.value.equals(((Address) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isPrivate() {
        return isPrivate;
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.person;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import seedu.addressbook.data.tag.Tag;

/**
 * Represents a Person in the address book.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Person implements ReadOnlyPerson {

    private Name name;
    private Phone phone;
    private Email email;
    private Address address;

    private final Set<Tag> tags = new HashSet<>();

    /**
     * Assumption: Every field must be present and not null.
     */
    public Person(Name name, Phone phone, Email email, Address address, Set<Tag> tags) {
        this.name = name;
        this.phone = phone;
        this.email = email;
        this.address = address;
        this.tags.addAll(tags);
    }

    /**
     * Copy constructor.
     */
    public Person(ReadOnlyPerson source) {
        this(source.getName(), source.getPhone(), source.getEmail(), source.getAddress(), source.getTags());
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public Phone getPhone() {
        return phone;
    }

    @Override
    public Email getEmail() {
        return email;
    }

    @Override
    public Address getAddress() {
        return address;
    }

    @Override
    public Set<Tag> getTags() {
        return new HashSet<>(tags);
    }

    /**
     * Replaces this person's tags with the tags in the argument tag set.
     */
    public void setTags(Set<Tag> replacement) {
        tags.clear();
        tags.addAll(replacement);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyPerson // instanceof handles nulls
                && this.hasSameData((ReadOnlyPerson) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, phone, email, address, tags);
    }

    @Override
    public String toString() {
        return getAsTextShowAll();
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.person;

import seedu.addressbook.data.exception.IllegalValueException;

import java.util.Arrays;
import java.util.List;

/**
 * Represents a Person's name in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String EXAMPLE = ""John Doe"";
    public static final String MESSAGE_NAME_CONSTRAINTS = ""Person names should be spaces or alphabetic characters"";
    public static final String NAME_VALIDATION_REGEX = ""[\\p{Alpha} ]+"";
    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = trimmedName;
    }

    /**
     * Returns true if the given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }

    /**
     * Retrieves a listing of every word in the name, in order.
     */
    public List<String> getWordsInName() {
        return Arrays.asList(fullName.split(""\\s+""));
    }

    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.exception;

/**
 * Signals an error caused by duplicate data where there should be none.
 */
public abstract class DuplicateDataException extends IllegalValueException {
    public DuplicateDataException(String message) {
        super(message);
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.exception;

/**
 * Signals that some given data does not fulfill some constraints.
 */
public class IllegalValueException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public IllegalValueException(String message) {
        super(message);
    }
}
",0.62,2.26
sc1_v5,ffc79e3,"package seedu.addressbook.data.tag;

import seedu.addressbook.data.exception.IllegalValueException;

/**
 * Represents a Tag in the address book.
 * Guarantees: immutable; name is valid as declared in {@link #isValidTagName(String)}
 */
public class Tag {

    public static final String MESSAGE_TAG_CONSTRAINTS = ""Tags names should be alphanumeric"";
    public static final String TAG_VALIDATION_REGEX = ""\\p{Alnum}+"";

    public final String tagName;

    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid tag name.
     */
    public static boolean isValidTagName(String test) {
        return test.matches(TAG_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    @Override
    public String toString() {
        return '[' + tagName + ']';
    }

}
",0.62,2.26
